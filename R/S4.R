vame_slot_nms_get <- function() {
  # start:vame_slot_nms
  # contents generated by dev/01_data.R; do not modify manually
  c("value_space_dt_subset", "var_meta_get", "var_meta_set", "var_rename",
  "vame_subset", "var_remove", "vame_union_append", "var_set_meta_get",
  "var_set_meta_set")
  # stop:vame_slot_nms
}

methods::setClass(
  Class = "VariableMetadata",
  slots = structure(
    rep("function", length(vame_slot_nms_get())),
    names = vame_slot_nms_get()
  )
)

#' @title Variable Metadata
#' @description
#' Create a VariableMetadata object.
#' @name VariableMetadata
NULL

#' @rdname VariableMetadata
#' @section Functions:
#' - `vame::VariableMetadata`: Use this function to create a new
#'   VariableMetadata object.
#' @param var_nm_dt `[data.table]`
#' 
#' Contains information for individual variables. Must contain at a minimum
#' column `var_nm`.
#' @param var_nm_set_dt `[data.table]`
#' 
#' Contains information for sets of variables --- e.g. a common value space.
#' Must contain at a minimum column `var_nm_set`.
#' @examples
#' vd <- vame::VariableMetadata(
#'   var_nm_dt = data.table::data.table(
#'     var_nm = c("a", "b", "c"),
#'     flavour = c("tasty", "rancid", "bitter")
#'   ),
#'   var_nm_set_dt = data.table::data.table(
#'     var_nm_set = list(c("a", "b"))
#'   )
#' )
#' vd@var_rename("a", "A")
#' stopifnot(identical(vd@var_meta_get("A", "flavour"), "tasty"))
#' @export
#' @importFrom data.table := .SD
VariableMetadata <- function(var_nm_dt, var_nm_set_dt) {
  pkg_env <- environment(VariableMetadata)
  funs <- new.env(parent = pkg_env)
  funs$data <- new.env(parent = emptyenv())
  funs$data$var_nm_dt <- var_nm_dt
  funs$data$var_nm_set_dt <- var_nm_set_dt
  data <- NULL # appease R CMD CHECK
  local(
    expr = {
      assert_var_nm <- function(
        var_nm,
        assertion_type = dbc::assertion_type_default()
      ) {
        dbc::assert_is_character_nonNA_atom(
          var_nm,
          assertion_type = assertion_type
        )
        dbc::assert_atom_is_in_set(
          var_nm,
          set = vnd_get()[["var_nm"]],
          assertion_type = assertion_type
        )
      }
      assert_var_meta_nm <- function(
        meta_nm,
        assertion_type = dbc::assertion_type_default()
      ) {
        dbc::assert_is_character_nonNA_atom(
          meta_nm,
          assertion_type = dbc::assertion_type_default()
        )
        dbc::assert_atom_is_in_set(
          meta_nm,
          set = names(vnd_get()),
          assertion_type = dbc::assertion_type_default()
        )
      }
      assert_var_set_meta_nm <- function(
        meta_nm,
        assertion_type = dbc::assertion_type_default()
      ) {
        dbc::assert_is_character_nonNA_atom(
          meta_nm,
          assertion_type = dbc::assertion_type_default()
        )
        dbc::assert_atom_is_in_set(
          meta_nm,
          set = names(vnsd_get()),
          assertion_type = dbc::assertion_type_default()
        )
      }
      vnd_get <- function() {
        out <- data[["var_nm_dt"]]
        if (nrow(out) == 0) {
          stop("vnd has no rows")
        }
        return(out[])
      }
      vnd_implied_get <- function() {
        vnsd <- vnsd_get()
        dt <- data.table::data.table(
          var_nm = unlist(vnsd[["var_nm_set"]]),
          var_nm_set_dt_pos = vapply(
            seq_along(vnsd[["var_nm_set"]]),
            function(i) {
              rep(i, length(vnsd[["var_nm_set"]]))
            },
            integer(1L)
          )
        )
        data.table::setkeyv(dt, names(dt))
        return(dt[])
      }
      vnd_vnsd_linkage_refresh <- function() {
        vnd <- vnd_get()
        vndi <- vnd_implied_get()
        data.table::setkeyv(vnd, intersect(names(vndi), names(vnd)))
        i.var_nm_set_dt_pos <- NULL # appease R CMD CHECK
        vnd[
          i = vndi,
          on = "var_nm",
          j = "var_nm_set_dt_pos" := i.var_nm_set_dt_pos
        ]
        data.table::setkeyv(vnd, intersect(names(vndi), names(vnd)))
        vnd_set(vnd)
        return(invisible(NULL))
      }
      vnd_vnsd_intersect <- function() {
        vnd <- vnd_get()
        vndi <- vnd_implied_get()
        rm_var_nms <- union(
          setdiff(
            vnd[["var_nm"]],
            vndi[["var_nm"]]
          ),
          setdiff(
            vndi[["var_nm"]],
            vnd[["var_nm"]]
          )
        )
        if (length(rm_var_nms) > 0) {
          var_remove(rm_var_nms)
          vnsd <- vnsd_get()
          vnsd_subset <- vapply(vnsd[["var_nm_set"]], length, integer(1L)) > 0L
          vnsd <- vnsd[vnsd_subset, ]
          vnsd_set(vnsd)
        }
        vnd_vnsd_linkage_refresh()
      }
      vnd_set <- function(dt) {
        data[["var_nm_dt"]] <- dt
      }
      vnsd_get <- function() {
        out <- data[["var_nm_set_dt"]]
        if (nrow(out) == 0) {
          stop("vnsd has no rows")
        }
        return(out[])
      }
      vnsd_set <- function(dt) {
        data[["var_nm_set_dt"]] <- dt
      }
      var_set_pos_get <- function(var_nm) {
        vnd <- vnd_get()
        vnd[["var_nm_set_dt_pos"]][data.table::chmatch(var_nm, vnd[["var_nm"]])]
      }
      value_space_get <- function(pos) {
        vnsd <- vnsd_get()
        return(vnsd[["value_space"]][[pos]])
      }
      value_space_set <- function(pos, value_space) {
        vnsd <- value_space_get()
        vnsd[["value_space"]][[pos]] <- value_space
      }
      value_space_dt_subset_expr <- function(var_nm, expr) {
        dbc::assert_is_language_object(expr, assertion_type = "prod_input")
        pos <- var_set_pos_get(var_nm)
        vs <- value_space_get(pos)
        dt <- vs[["dt"]]
        if (!data.table::is.data.table(dt)) {
          stop("Column \"", var_nm, "\" value space is not a data.table")
        }
        dt_expr <- substitute(dt[i = expr], list(expr = expr))
        dt <- eval(dt_expr)
        value_space_set(pos, dt)
        return(invisible(NULL))
      }
      # slot:value_space_dt_subset
      value_space_dt_subset <- function(
        var_nm,
        expr
      ) {
        assert_var_nm(var_nm)
        expr <- substitute(expr)
        value_space_dt_subset_expr(var_nm, expr)
      }
      # slot:var_meta_get
      var_meta_get <- function(var_nm, meta_nm) {
        assert_var_nm(var_nm)
        assert_var_meta_nm(meta_nm)
        vnd <- vnd_get()
        jdt <- data.table::setDT(list(var_nm = var_nm))
        out <- vnd[
          i = jdt,
          on = "var_nm",
          j = .SD[[1]],
          .SDcols = meta_nm
        ]
        return(out)
      }
      # slot:var_meta_set
      var_meta_set <- function(
        var_nm,
        meta_nm,
        value
      ) {
        assert_var_nm(var_nm)
        vnd <- vnd_get()
        data.table::set(
          vnd,
          i = data.table::chmatch(var_nm, vnd[["var_nm"]]),
          j = meta_nm,
          value = value
        )
        return(invisible(NULL))
      }
      # slot:var_rename
      var_rename <- function(old, new) {
        assert_var_nm(old)
        dbc::assert_is_character_nonNA_atom(new)
        vnd <- vnd_get()
        vnsd <- vnsd_get()
        jdt <- data.table::data.table(var_nm = old, new = new)
        i.new <- NULL # appease R CMD CHECK
        vnd[
          i = jdt,
          on = "var_nm",
          j = "var_nm" := i.new
        ]
        tmp <- vnd[
          j = list(var_nm_set = list(.SD[["var_nm"]])),
          keyby = "var_nm_set_dt_pos"
        ]
        data.table::set(vnsd, j = "var_nm_set", value = tmp[["var_nm_set"]])
        invisible(NULL)
      }
      vame_subset_expr <- function(expr) {
        dbc::assert_is_language_object(expr, assertion_type = "prod_input")
        vnd <- vnd_get()
        dt_expr <- substitute(vnd[i = expr], list(expr = expr))
        vnd <- eval(dt_expr)
        vnd_set(vnd)

        vnd_vnsd_intersect()
      }
      # slot:vame_subset
      vame_subset <- function(expr) {
        expr <- substitute(expr)
        vame_subset_expr(expr)
        invisible(NULL)
      }
      # slot:var_remove
      var_remove <- function(var_nms) {
        lapply(seq_along(var_nms), function(i) {
          assert_var_nm(var_nms[i])
        })        
        expr <- substitute(!var_nm %in% var_nms, list(var_nms = var_nms))
        vame_subset_expr(expr)
      }
      # slot:vame_union_append
      vame_union_append <- function(x) {
        e <- environment(x@remove)
        vnd_1 <- vnd_get()
        vnsd_1 <- vnsd_get()
        vnd_2 <- e[["vnd_get"]]()
        vnsd_2 <- e[["vnsd_get"]]()
        vnd <- rbind(vnd_1, vnd_2)
        vnsd <- rbind(vnsd_1, vnsd_2)
        vnsd <- vnsd[!duplicated(vnsd[["var_nm_set"]]), ]
        vnd_set(vnd)
        vnd_vnsd_linkage_refresh()
        vnsd_set(vnsd)
        return(invisible(NULL))
      }
      # slot:var_set_meta_get
      var_set_meta_get <- function(
        var_nm,
        meta_nm
      ) {
        assert_var_nm(var_nm)
        assert_var_set_meta_nm(meta_nm)
        pos <- var_set_pos_get(var_nm = var_nm)
        vnsd <- vnsd_get()
        vnsd[[meta_nm]][[pos]]
      }
      # slot:var_set_meta_set
      var_set_meta_set <- function(
        var_nm,
        meta_nm,
        value
      ) {
        assert_var_nm(var_nm)
        pos <- var_set_pos_get(var_nm = var_nm)
        vnsd <- vnsd_get()
        data.table::set(
          vnsd,
          i = pos,
          j = meta_nm,
          value = value
        )
        vnsd_set(vnsd)
      }
    },
    envir = funs
  )
  funs[["vnd_vnsd_intersect"]]()
  arg_list <- list(
    Class = "VariableMetadata"
  )
  fun_list <- lapply(vame_slot_nms_get(), function(fun_nm) {
    funs[[fun_nm]]
  })
  names(fun_list) <- vame_slot_nms_get()
  arg_list <- c(arg_list, fun_list)
  do.call(methods::new, arg_list, quote = TRUE)
}

methods::setMethod(
  f = "print",
  signature = "VariableMetadata",
  definition = function(x) {
    cat(
      "VariableMetadata object ----\n",
      "Functions:\n",
      vapply(vame_slot_nms_get(), function(obj_nm) {
        paste0("  @", obj_nm, "()\n")
      }, character(1L))
    )
  }
)

methods::setMethod(
  f = "show",
  signature = "VariableMetadata",
  definition = function(object) {
    print(object)
  }
)
