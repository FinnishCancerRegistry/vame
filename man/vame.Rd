% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/01_package_vame.R
\docType{package}
\name{vame}
\alias{vame}
\title{vame: Variable Metadata}
\description{
\code{vame} makes it simpler to define and make use of metadata pertaining
to one more variables (e.g. a tabular dataset).

\href{https://github.com/FinnishCancerRegistry/vame/actions/workflows/R-CMD-check.yaml}{\if{html}{\figure{https://github.com/FinnishCancerRegistry/vame/actions/workflows/R-CMD-check.yaml/badge.svg}}}
}
\section{Recommended installation}{
\if{html}{\out{<div class="sourceCode r">}}\preformatted{devtools::install_github(
  "FinnishCancerRegistry/vame",
  ref = readline("enter latest tag on github: ")
)
}\if{html}{\out{</div>}}
}

\section{Example of use}{
Suppose you have a tabular dataset. You have ID columns, stratifying columns
(e.g. demographical data), dates, what have you. \code{vame} makes it easy to
define what kind of data each column contains. For instance you can define
the precise set of category values that a categorical column can have.
Further, this package makes quick work of writing assertions on columns
or entire datasets, of producing stratum tables for the purpose of computing
statistics within each stratum, and retrieving labels for (e.g.
integer-valued) categorical variables.

Consider the following tiny dataset of child patients.

\if{html}{\out{<div class="sourceCode r">}}\preformatted{dt <- data.table::data.table(
  subject_id = 1:3,
  birth_date = as.Date(c("2001-01-01", "2002-01-01", "2003-01-01")),
  dg_age = c(10.5, 15.2, 20.0),
  dg_age_group = 3:5,
  ex_age = c(21.0, 20.0, 19.0),
  ex_age_group = c(5L, 4L, 4L),
  social_class = c(0L, 0L, 1L)
)

# "type" is up to you. you may want to write code that takes type into account.
# however, type "categorical" is special: stratum tables and labels can
# be retrieved for categorical columns only.
age_group_labels <- data.table::data.table(
  value = 1:18,
  label = paste0(0:17 * 5, "-", c(1:17 * 5 - 1, 120))
)
var_dt <- data.table::data.table(
  var_nm = c("subject_id", "birth_date",
             "dg_age", "dg_age_group",
             "ex_age", "ex_age_group",
             "social_class"),
  class_set = list(
    "integer", "Date",
    "numeric", "integer",
    "numeric", "integer",
    "integer"
  ),
  type = c("id", "date",
            "duration", "categorical",
            "duration", "categorical",
            "categorical"),
  label_set = list(
    NULL, NULL,
    NULL, age_group_labels,
    NULL, age_group_labels,
    data.table::data.table(
      value = 0:3,
      label = c("student", "labourer", "professional", "entrepreneur")
    )
  )
)

age_bounds <- list(
  lo = 0.0, hi = 120.0,
  lo_inclusive = TRUE, hi_inclusive = FALSE
)
value_spaces <- list(
  # element names such as subject_id, birth_date not necessary ---
  # I used them for readability.
  subject_id = list(
    bounds = list(
      lo = 1L, hi = 100L,
      lo_inclusive = TRUE, hi_inclusive = TRUE
    )
  ),
  birth_date = list(
    bounds = list(
      lo = as.Date("2001-01-01"),
      hi = as.Date("2019-12-31"),
      lo_inclusive = TRUE,
      hi_inclusive = TRUE
    )
  ),
  dg_age = list(bounds = age_bounds),
  ex_age = list(bounds = age_bounds),
  age_group = list(
    # this is the joint category space of dg_age_group and ex_age_group.
    # ex_age_group cannot be lower than dg_age_group by definition!
    dt = data.table::data.table(
      dg_age_group = 1:18
    )[
      j = list(ex_age_group = .SD[["dg_age_group"]]:18),
      keyby = "dg_age_group",
      .SDcols = "dg_age_group"
    ]
  ),
  social_class = list(
    set = 0:3
  )
)
var_set_dt <- data.table::data.table(
  id = c("subject_id", "birth_date",
        "dg_age", "ex_age",
        "age_group",
        "social_class"),
  var_nm_set = list(
    "subject_id", "birth_date",
    "dg_age", "ex_age",
    c("dg_age_group", "ex_age_group"),
    "social_class"
  ),
  value_space = value_spaces
)
vardef <- vame::VariableMetadata(
  var_dt = var_dt,
  var_set_dt = var_set_dt
)

# producing and using stratum tables
sdt <- vardef@vame_category_space_dt(
  c("dg_age_group", "ex_age_group", "social_class")
)
print(sdt)
ndt <- dt[i = sdt, on = names(sdt), j = .N, keyby = .EACHI]
print(ndt)

# retrieving labels
ndt[, "social_class_label" := vardef@var_labels(ndt[["social_class"]])]

# writing assertions (checks) on function input data
my_fun_1 <- function(dataset) \{
  vardef@dbc@assert_is_dataset(dataset)
  return(nrow(dataset))
\}
my_fun_2 <- function(dg_age) \{
  vardef@dbc@assert_is_var(dg_age, var_nm = "dg_age")
\}
}\if{html}{\out{</div>}}
}

\section{News}{

\subsection{News for version 0.1.9}{
\subsection{vm@var_remove}{

\code{vm@var_remove} can now remove multiple variables in one go.
}

\subsection{vm@var_set_value_space_eval}{

\code{vame::var_set_value_space_eval} + \code{vm@var_set_value_space_eval} gain
arg \code{var_nms}. You can now evaluate the value space for only a subset of
the variables in the set.
}

}

\subsection{News for version 0.1.8}{
\subsection{vm@vame_copy}{

New slot fun \code{vm@vame_copy} + new exported fun \code{vame::vame_copy}.
}

}

\subsection{News for version 0.1.7}{
\subsection{vame::VariableMetadata}{

New \code{value_space} type: "unrestricted". Use this when a variable must
be of a certain class but can take any value. E.g.
\code{list(unrestricted = list(class_set = c("IDate", "Date")))}.
}

\subsection{vame::VariableMetadata}{

New \code{value_space} type: "regex". Use this when all values of a variable
must match a specific regex. E.g. \code{list(regex = "^[a-z]$")}.
}

\subsection{vm@var_set_value_space_eval}{

New exported fun \code{vame::var_set_value_space_eval} --- alternative for
\code{vm@var_set_value_space_eval}.
}

}

\subsection{News for version 0.1.6}{
\subsection{vm@vame_union_append}{

fix \code{vame_union_append} --- no longer attempt to remove duplicates
in rbind'd \code{var_dt} because some \code{by} columns may be of type \code{list}
which is not supported by \code{duplicated}.
}

}

\subsection{News for version 0.1.5}{
\subsection{vm@vame_union_append}{

Robustify \code{vame_union_append} --- use \verb{use.names = TRUE, fill = TRUE}
in \code{rbind} calls.
}

}

\subsection{News for version 0.1.4}{
\subsection{vm@vame_union_append}{

Fixed \code{vame_union_append} --- used to always raise an error due to
a misnamed object.
}

}

\subsection{News for version 0.1.3}{
\subsection{vm@var_aggregate}{

New slot \code{var_aggregate}.
}

\subsection{vm@var_assert}{

\code{vm@var_assert} gains arg \code{env}. This is passed
to \code{vm@var_value_space_eval}.
}

\subsection{vm@var_is_aggregateable_to}{

New slot \code{var_is_aggregateable_to}.
}

}

\subsection{News for version 0.1.2}{
\subsection{vm@assert_is_var_set_id}{

\code{var_set_dt$id} no longer needs to be of class character. For clarity
us character, for marginal speed improvement use integer.
}

\subsection{vm@vame_category_space_dt}{

Also \code{bounds} value space can be used when creating category spaces.
}

\subsection{vm@vame_category_space_dt_list}{

Also \code{bounds} value space can be used when creating category spaces.
}

\subsection{vm@var_assert}{

Added arguments \code{x_nm}, \code{call}.
}

}

\subsection{News for version 0.1.1}{
\subsection{vm@var_assert}{

Fixed \code{var_assert} handling of a value space based on \code{bounds}.
}

\subsection{vm@var_set_value_space_eval}{

New slot \code{vm@var_set_value_space_eval}.
}

\subsection{vm@var_value_space_eval}{

New slot \code{vm@var_value_space_eval}.
}

}

\subsection{News for version 0.1.0}{
\subsection{vame::VariableMetadata}{

First release.
}

}
}

