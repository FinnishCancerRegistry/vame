% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/01_package_vame.R
\docType{package}
\name{vame}
\alias{vame-package}
\alias{vame}
\title{vame: Variable Metadata}
\description{
\code{vame} makes it simpler to define and make use of metadata pertaining
to one more variables (e.g. a tabular dataset). It implements the
\code{VariableMetadata} class, which contains the metadata. The various metadata
are accessed using slot functions such as \code{vm@var_description_get}.

The \code{VariableMetadata} class is intended for storing metadata for which there
is "one right way". For instance, a variable has one correct description in
text.

See the help page \code{?vame::VariableMetadata} for more information. In
particular see the examples.

\href{https://github.com/FinnishCancerRegistry/vame/actions/workflows/R-CMD-check.yaml}{\if{html}{\figure{https://github.com/FinnishCancerRegistry/vame/actions/workflows/R-CMD-check.yaml/badge.svg}}}
}
\section{Basic example}{
\if{html}{\out{<div class="sourceCode r">}}\preformatted{# vame::VariableMetadata

# maybe the most important type of metadata: what values are different
# variables allowed to have? here we define value_space objects for that.
value_space_d <- function() 1:3 * 100L
vm <- vame::VariableMetadata(
  var_dt = data.table::data.table(
    var_nm = c("a", "b", "c", "d", "e", "f", "g", "h"),
    type = c("categorical", "categorical",
             "categorical",
             "my_type_1", "my_type_2", "my_type_3", "my_type_4", "my_type_5")
  ),
  var_set_dt = data.table::data.table(
    id = c("ab", "c", "d", "e", "f", "g", "h"),
    var_nm_set = list(
      ab = c("a", "b"),
      c = "c", d = "d", e = "e", f = "f", g = "g", h = "h"),
    value_space = list(
      ab = list(dt = data.table::data.table(
        a = c(1L, 2L, 2L),
        b = c(11L, 21L, 22L)
      )),
      c = list(set = c("a", "b")),
      d = list(expr = quote(value_space_d())),
      e = list(bounds = list(
        lo = 0.0, hi = 10.0,
        lo_inclusive = TRUE, hi_inclusive = TRUE
      )),
      f = list(bounds = list(
        lo = as.Date("1901-01-01"), hi = as.Date("2023-12-31"),
        lo_inclusive = TRUE, hi_inclusive = TRUE
      )),
      g = list(unrestricted = list(class_set = c("IDate", "Date"))),
      h = list(regex = "^[a-z]$")
    )
  )
)

# this information can be used to e.g. verify data.
vm@var_assert(1L, var_nm = "a")
vm@var_assert(21L, var_nm = "b")
vm@var_assert("a", var_nm = "c")
vm@var_assert(100L, var_nm = "d")
vm@var_assert(c(0.0, 10.0), var_nm = "e")
vm@var_assert(as.Date("1901-01-01"), var_nm = "f")
vm@var_assert(data.table::as.IDate("1901-01-01"), var_nm = "g")
vm@var_assert(letters, var_nm = "h")
my_fun <- function(e_values) \{
  vm@var_assert(e_values, var_nm = "e")
  e_values + 1
\}
my_fun(0.0)

# VariableMetadata objects can be modified after creation.
# lets change some metadata.
vm@var_meta_set(var_nm = "f", meta_nm = "type", value = "my_date")
stopifnot(
  vm@var_meta_get(var_nm = "f", meta_nm = "type") == "my_date"
)
vm@var_set_value_space_set(id = "c", value_space = list(set = c("x", "z")))
stopifnot(
  identical(vm@var_set_value_space_get(id = "c"), list(set = c("x", "z")))
)

# renaming, removing variables
vm <- vame::VariableMetadata(
  var_dt = data.table::data.table(
    var_nm = c("a", "b", "c"),
    flavour = c("tasty", "rancid", "bitter")
  ),
  var_set_dt = data.table::data.table(
    id = "set_01",
    var_nm_set = list(c("a", "b")),
    value_space = list(list(dt = data.table::data.table(
      a = 1:2,
      b = 3:4
    )))
  )
)

vm@var_rename("a", "A")
stopifnot(
  identical(vm@var_meta_get("A", "flavour"), "tasty"),
  identical(names(vm@var_set_value_space_get("set_01")[["dt"]]), c("A", "b")),
  identical(vm@var_set_meta_get("set_01", "var_nm_set"), c("A", "b"))
)

vm@var_set_rename("set_01", "Ab")
stopifnot(
  identical(vm@var_set_meta_get_all("id"), c("Ab" = "Ab"))
)

vm@var_remove("b")
stopifnot(
  identical(names(vm@var_set_value_space_get("Ab")[["dt"]]), "A"),
  identical(vm@var_set_meta_get("Ab", "var_nm_set"), "A")
)

vm@var_set_remove("Ab")
stopifnot(
  identical(length(vm@var_set_meta_get_all("var_nm_set")), 0L)
)

# another important feature is the possibility of retrieving a table of
# allowed categories for one or more variables. this comes up when (a subset
# of) observed data contains only some of the categories (think one age
# group for one sex is not present in data) but we want all possible
# categories to appear in our statistics. if we have defined these
# categories in advance as value_space objects, they are usable in this
# regard as well.
dt_01 <- data.table::CJ(a = 1:3, b = 3:1, c = 1:3)
dt_02 <- data.table::CJ(d = 1:2, e = 2:1)
vm <- vame::VariableMetadata(
  var_dt = data.table::data.table(
    var_nm = c("a", "b", "c", "d", "e", "f"),
    type = "categorical"
  ),
  var_set_dt = data.table::data.table(
    id = c("abc", "de", "f"),
    var_nm_set = list(
      abc = c("a", "b", "c"),
      de = c("d", "e"),
      f = "f"
     ),
    value_space = list(
      abc = list(dt = dt_01),
      de = list(expr = quote(\{
        dt_02[
          i = !duplicated(dt_02, by = var_nms),
          j = .SD,
          .SDcols = var_nms
        ]
      \})),
      f = list(bounds = list(
        lo = 0L, hi = 10L,
        lo_inclusive = TRUE, hi_inclusive = TRUE
      ))
    )
  )
)

stopifnot(
  all.equal(
    vm@vame_category_space_dt(c("a", "b")),
    dt_01[
      i = !duplicated(dt_01, by = c("a", "b")),
      j = .SD,
      .SDcols = c("a", "b")
    ],
    check.attributes = FALSE
  ),
  all.equal(
    vm@vame_category_space_dt(c("d", "e")),
    dt_02,
    check.attributes = FALSE
  ),
  all.equal(
    vm@vame_category_space_dt(c("a", "f")),
    data.table::CJ(a = 1:3, f = 0:10),
    check.attributes = FALSE
  )
)

# getting category space data.tables --- here a variable appears in
# two different value spaces. this can be handy for defining joint value
# spaces and also conversions & aggregations.
dt_01 <- data.table::CJ(a = 1:3, b = 3:1, c = 1:3)
dt_02 <- data.table::CJ(a = 0:1, e = 2:1)
dt_03 <- data.table::data.table(a = 0:3, a_2 = c(1L,1L, 2L,2L))
vm <- vame::VariableMetadata(
  var_dt = data.table::data.table(
    var_nm = c("a", "b", "c", "e", "a_2"),
    type = "categorical"
  ),
  var_set_dt = data.table::data.table(
    id = c("set_01", "set_02", "set_03"),
    var_nm_set = list(c("a", "b", "c"), c("a", "e"), c("a", "a_2")),
    value_space = list(
      list(dt = dt_01),
      list(dt = dt_02),
      list(dt = dt_03)
    )
  )
)

obs <- vm@vame_category_space_dt(c("a", "b", "e"))
exp <- data.table::data.table(
  a = c(0L, 0L, 1L, 1L, 1L, 1L, 1L, 1L, 2L, 2L, 2L, 3L, 3L, 3L),
  b = c(NA, NA, 1L, 1L, 2L, 2L, 3L, 3L, 1L, 2L, 3L, 1L, 2L, 3L),
  e = c(1L, 2L, 1L, 2L, 1L, 2L, 1L, 2L, NA, NA, NA, NA, NA, NA)
)
data.table::setkeyv(obs, names(obs))
data.table::setkeyv(exp, names(exp))
stopifnot(
  all.equal(obs, exp, check.attributes = FALSE)
)

stopifnot(
  vm@var_is_aggregateable_to("a", "a_2"),
  identical(vm@var_aggregate(0:1, "a", "a_2"), c(1L,1L))
)

# getting labels for variable levels
dt_01 <- data.table::CJ(a = 1:3, b = 3:1, c = 4:5)
vm <- vame::VariableMetadata(
  var_dt = data.table::data.table(
    var_nm = c("a", "b", "c"),
    type = "categorical",
    labeler = list(
      a = data.table::data.table(
        x = 1:3,
        en = paste0("a_level_", 1:3)
      ),
      b = quote(\{
        dt <- data.table::data.table(
          x = 1:3,
          en = paste0("b_level_", 1:3)
        )
        dt[[label_nm]][match(x, dt[["x"]])]
      \}),
      c = NULL
    )
  ),
  var_set_dt = data.table::data.table(
    id = c("set_01"),
    var_nm_set = list(c("a", "b", "c")),
    value_space = list(
      list(dt = dt_01)
    )
  )
)

obs <- vm@var_labels_get(x = 1:4, var_nm = "a", label_nm = "en")
exp <- c(paste0("a_level_", 1:3), NA)
stopifnot(
  identical(obs, exp)
)

obs <- tryCatch(
  vm@var_labels_get(
    x = 1:4,
    var_nm = "a",
    label_nm = "this does not exist"
  ),
  error = function(e) e[["message"]]
)
exp <- paste0(
  "label_nm = \\"this does not exist\\"",
  " not one of the defined label names: \\"en\\""
)
stopifnot(
  grepl(exp, obs)
)

obs <- tryCatch(
  vm@var_labels_get(
    x = 1:4,
    var_nm = "c",
    label_nm = "en"
  ),
  error = function(e) e[["message"]]
)
exp <- "Variable \\"c\\" has no labeler defined"
stopifnot(
  grepl(exp, obs)
)

# adding data to a pre-existing VariableMetadata object
vm_1 <- vame::VariableMetadata(
  var_dt = data.table::data.table(
    var_nm = c("a", "b"),
    type = "categorical",
    labeler = list(
      a = data.table::data.table(x = 1:2, label = c("a_1", "a_2")),
      b = NULL
    )
  ),
  var_set_dt = data.table::data.table(
    id = "ab",
    var_nm_set = list(ab = c("a", "b")),
    value_space = list(ab = list(dt = data.table::CJ(a = 1:2, b = 3:4)))
  )
)
# note that vm_2 var_dt does not have columns "type", "labeler" --- those
# will be NA / NULL for "c" and "d".
vm_2 <- vame::VariableMetadata(
  var_dt = data.table::data.table(var_nm = c("c", "d")),
  var_set_dt = data.table::data.table(
    id = "cd",
    var_nm_set = list(cd = c("c", "d")),
    value_space = list(cd = list(dt = data.table::CJ(c = 5:6, d = 7:8)))
  )
)
vm_1@vame_union_append(vm_2)
stopifnot(
  c("ab", "cd") \%in\% vm_1@var_set_meta_get_all("id")
)

# taking a copy of a VariableMetadata object
vm_3 <- vm_2@vame_copy()
vm_2@var_rename("d", "dd")
stopifnot(
  "d" \%in\% vm_3@var_meta_get_all("var_nm"),
  !"d" \%in\% vm_2@var_meta_get_all("var_nm"),
  "dd" \%in\% vm_2@var_meta_get_all("var_nm")
)

}\if{html}{\out{</div>}}
}

\section{Recommended installation}{
\if{html}{\out{<div class="sourceCode r">}}\preformatted{devtools::install_github(
  "FinnishCancerRegistry/vame@release"
)
}\if{html}{\out{</div>}}
}

\section{News}{

\subsection{News for version 1.10.4}{
\subsection{vame::print.VariableMetadata}{

Improved \code{print} method of \code{VariableMetadata}. It no longer prints all
available functions (a long list). Instead now simply \code{var_dt},
\code{var_set_dt}  (first five rows), and names of \code{vame_list} are printed.
}

\subsection{vm@vame_list_print}{

New function \code{vm@vame_list_print}.
}

\subsection{vm@var_dt_print}{

New function \code{vm@var_dt_print}.
}

\subsection{vm@var_set_dt_print}{

New function \code{vm@var_set_dt_print}.
}

}

\subsection{News for version 1.10.3}{
\subsection{vm@vame_subset}{

\code{vm@vame_subset} now allows \code{var_dt_expr} and \code{var_set_dt_expr} to
themselves be quoted expressions (\code{name} / \code{call} objects).
}

}

\subsection{News for version 1.10.2}{
\subsection{vm@vame_subset}{

\code{vm@vame_subset} fix: in 1.10.1 (but not before) mistakenly evaluated
\code{var_dt_expr} when \code{var_set_dt_expr} was supposed to be evaluted.
}

}

\subsection{News for version 1.10.1}{
\subsection{vm@vame_subset}{

\code{vm@vame_subset} arg \code{enclos} default fixed. Now uses the environment
where \code{vm@vame_subset} is called.
}

}

\subsection{News for version 1.10.0}{
\subsection{vm@vame_subset}{

\code{vm@vame_subset} gained argument \code{enclos}.
}

}

\subsection{News for version 1.9.4}{
\subsection{vm@var_aggregate}{

\code{vm@var_aggregate} optimised to simply return \code{x} if
\code{from_var_nm == to_var_nm}.
}

\subsection{vm@var_aggregate}{

\code{vm@var_aggregate} now checks that \code{x} and the \code{value_space} of
\code{from_var_nm} have identical class vectors and raises an informative
error if that is not the case.
}

}

\subsection{News for version 1.9.3}{
\subsection{vm@vame_union_append}{

Fixed a bug which sometimes caused an issue with refreshing
\code{var_dt$var_set_dt_pos_set}.
}

}

\subsection{News for version 1.9.2}{
\subsection{vm@vame_union_append}{

Fixed a bug which sometimes caused an issue with \code{vm@vame_union_append}:
\code{var_dt$var_set_dt_pos_set} could be created as an \code{integer}
column instead of the intended \code{list} column.
}

}

\subsection{News for version 1.9.1}{
\subsection{vm@vame_make}{

Improved \code{callbacks} deprecation message.
}

}

\subsection{News for version 1.9.0}{
\subsection{vm@vame_make}{

\code{vm@vame_make} gains arg \code{optional_steps} to replace \code{callbacks}.
Using \code{callbacks} throws a warning now, an error starting in 1.10.0
and it will be removed in 1.11.0.
}

}

\subsection{News for version 1.8.0}{
\subsection{vm@var_set_make}{

\code{vm@var_set_make} now deletes all other columns except \code{var_nms} from output
if such exist. Previously the user could request for e.g.
\code{var_nms = "my_var_1"} only, but if the underlying \code{maker} was defined for
e.g. \code{c("my_var_1", "my_var_2")}, then both were included in output.
So now only \code{"my_var_1"} would be included.
}

}

\subsection{News for version 1.7.0}{
\subsection{vame::VariableMetadata}{

\code{vame::VariableMetadata} now raises an error if \code{var_dt$var_nm} has any
duplicates.
}

\subsection{vame::VariableMetadata}{

\code{vame::VariableMetadata} now raises an error if \code{var_set_dt$id} has any
duplicates.
}

}

\subsection{News for version 1.6.0}{
\subsection{vm@var_set_value_space_eval}{

\code{vm@var_set_value_space_eval} now can make use of a \code{labeler} of class
\code{data.table} in cases where no \code{value_space} is defined for the \code{id},
but \code{var_nms} is of length one, and that variable has such a \code{labeler}.
}

\subsection{vm@var_set_value_space_eval}{

\code{vm@var_set_value_space_eval} now also allows the evaluation result of
a \code{value_space} of type \code{expr} or \code{fun} to be a \code{value_space} object
in itself. In fact that is recommended from now on.
}

}

\subsection{News for version 1.5.0}{
\subsection{vm@vame_harmonise_dt}{

New function \code{vm@vame_harmonise_dt}.
}

\subsection{vm@var_meta_is_defined}{

\code{vm@var_meta_is_defined} now also allows \code{var_nm = NULL}. Then it returns
\code{TRUE/FALSE} depending on whether \code{meta_nm} is a column name of \code{var_dt}.
}

\subsection{vm@var_set_meta_is_defined}{

\code{vm@var_set_meta_is_defined} now also accepts \code{id = NULL}. Then
\code{vm@var_set_meta_is_defined} tests whether \code{meta_nm} is a column name of
\code{var_set_dt}.
}

\subsection{vm@var_var_set_dt_id_set_get}{

New function \code{vm@var_var_set_dt_id_set_get}.
}

\subsection{vm@var_var_set_dt_pos_set_get}{

New function \code{vm@var_var_set_dt_pos_set_get}.
}

}

\subsection{News for version 1.4.0}{
\subsection{vm@vame_union_append}{

\code{vm@vame_union_append} now adds metadata from \code{vm_2} into \code{vm} even for
pre-existing variables where that particular metadata is missing in
\code{vm}. Previously only new variables were added and pre-existing variables'
metadata were untouched.
}

}

\subsection{News for version 1.3.1}{
\subsection{vame}{

All functions that auto-infer \code{id}/\code{ids} which require multiple
metadata for the \code{id} now makes use of the preference defined in the
function. For instance, requiring an \code{id} to have either \code{sampler} or
\code{value_space} now causes the \code{id} value with \code{sampler} defined to
be preferred even if a separate one has \code{value_space}.
}

\subsection{vm@vame_value_space_sample}{

\code{vm@vame_value_space_sample} arg \code{ids} auto-inference now only finds
\code{ids} which have either \code{sampler} or \code{value_space}.
}

\subsection{vm@vame_value_space_sample_default}{

\code{vm@vame_value_space_sample_default} arg \code{ids} auto-inference now only finds
\code{ids} which have either \code{sampler} or \code{value_space}.
}

\subsection{vm@var_set_value_space_sample}{

\code{vm@var_set_value_space_sample} arg \code{id} auto-inference now only finds
one \code{id} which has either \code{sampler} or \code{value_space}.
}

}

\subsection{News for version 1.3.0}{
\subsection{vm@vame_make}{

\code{vm@vame_make} now sets the attribute \code{vame_make_meta} on its output.
}

\subsection{vm@var_set_make}{

\code{vm@var_set_make} now sets attribute \code{var_set_make_meta} on its output.
}

\subsection{vm@var_set_maker_get_dep_var_nm_sets}{

New function \code{vm@var_set_maker_get_dep_var_nm_sets}.
}

}

\subsection{News for version 1.2.0}{
\subsection{vm@vame_make}{

Rename \code{vm@vame_make} \code{callbacks} element \code{pre_loop} to \code{pre_lapply}.
}

\subsection{vm@vame_make}{

\code{vm@vame_make} gains \code{callbacks} element \code{lapply_on_entry}.
}

\subsection{vm@vame_make}{

\code{vm@vame_make} gains \code{callbacks} element \code{lapply_on_exit}.
}

\subsection{vm@vame_make}{

\code{vm@vame_make} gains \code{callbacks} element \code{lapply_pre_var_set_make}.
}

\subsection{vm@vame_make}{

Rename \code{vm@vame_make} \code{callbacks} element \code{post_var_set_make} to
\code{lapply_post_var_set_make}.
}

\subsection{vm@var_set_make}{

\code{vm@var_set_make} can now handle a \code{maker} of type \code{list} with element
\code{dep_var_nm_sets}.
}

\subsection{vm@var_set_maker_set}{

A \code{maker} of type \code{list} can now have element \code{dep_var_nm_sets} instead
of \code{dep_var_nm_set}. \code{dep_var_nm_sets} must be a \code{list} of variable name
sets --- different allowed options. If your \code{maker} only works on one
specific set of dependency variables, it is easier for you to keep using
\code{dep_var_nm_set}. The possibility of using \code{dep_var_nm_sets} was added
to enable writing a \code{maker} such as
\code{quote(switch(dep_var_nm_set, b = b + 1L, c = c - 1L))}, where the target
variable can be made using either \code{b} or \code{c}.
}

}

\subsection{News for version 1.1.1}{
\subsection{vame::self}{

Fixed \code{vame::self()} --- it failed to find the \code{VariableMetadata} object
in some cases although it is intended to work until deletion.
}

}

\subsection{News for version 1.1.0}{
\subsection{vame::self}{

\code{vame::self()} deprecated. Refer to the \code{vame::VariableMetadata} itself
using \code{vm}.
}

\subsection{vm@var_description_get}{

\code{vm@var_description_get} now makes variables \code{var_nm}, \code{descr_nm}, and \code{vm}
available for \code{describer} types \code{function} and \code{call}.
}

\subsection{vm@var_labels_get}{

\code{vm@var_labels_get} now makes variables \code{x}, \code{var_nm}, \code{label_nm}, and \code{vm}
available for \code{labeler} types \code{function} and \code{call}.
}

\subsection{vm@var_set_value_space_eval}{

\code{vm@var_set_value_space_eval} now makes variables \code{id}, \code{var_nms}, and \code{vm}
available for \code{labeler} types \code{function} and \code{call}.
}

\subsection{vm@var_set_value_space_sample}{

\code{vm@var_set_value_space_sample} object \code{x} passed to the \code{sampler} renamed
to \code{vm}. It is the \code{VariableMetadata} object itself.
}

}

\subsection{News for version 1.0.1}{
\subsection{vm@vame_make}{

\code{vm@vame_make} gains \code{callbacks} element \code{on_entry}.
}

\subsection{vm@vame_make}{

\code{vm@vame_make} gains \code{callbacks} element \code{pre_loop}.
}

}

\subsection{News for version 1.0.0}{
\subsection{vm@vame_make}{

\code{vm@vame_make} gains argument \code{callbacks}.
}

}

\subsection{News for version 0.5.8}{
\subsection{vame}{

An individual description text for a \code{describer} can now be a \code{character}
string vector (without \code{NA}) with more than one element. Formerly
length one was required.
}

\subsection{vame}{

The elements of a \code{describer} of type \code{list} can now be vectors with
more than one element. Formerly only vectors of length one were allowed.
}

}

\subsection{News for version 0.5.7}{
\subsection{vm@var_meta_set}{

\code{vm@var_meta_set} now always wraps \code{value} into a list before adding
it into \code{vm} when \code{meta_nm \%in\% c("describer", "labeler")} --- those are
known \code{list} columns.
}

\subsection{vm@var_set_meta_set}{

\code{vm@var_set_meta_set} now always wraps \code{value} into a list before adding
it into \code{vm} when \code{meta_nm \%in\% c("value_space", "maker")} --- those are
known \code{list} columns.
}

}

\subsection{News for version 0.5.6}{
\subsection{vm@vame_meta_set}{

\code{vm@vame_meta_set} now checks \code{value} for validity for "officially"
defined metadata such as \code{sampler}. Formerly this was done only by
the corresponding wrapper such as \code{vm@vame_value_space_sampler_set}.
}

\subsection{vm@var_meta_set}{

\code{vm@var_meta_set} now checks \code{value} for validity for "officially" defined
metadata such as \code{describer}. Formerly this was done only by
the corresponding wrapper such as \code{vm@var_describer_set}.
}

\subsection{vm@var_set_meta_set}{

\code{vm@var_set_meta_set} now checks \code{value} for validity for "officially"
defined metadata such as \code{value_space}. Formerly this was done only by
the corresponding wrapper such as \code{vm@var_set_value_space_set}.
}

}

\subsection{News for version 0.5.5}{
\subsection{vm@vame_copy}{

\code{vm@vame_copy} now also copies \code{vame_list}.
}

}

\subsection{News for version 0.5.4}{
\subsection{vm@vame_subset}{

Fix use of \code{substitute} in turning args \code{var_dt_expr} + \code{var_set_dt_expr}
into a quoted expression.
}

}

\subsection{News for version 0.5.3}{
\subsection{vame}{

Fixed an extra comma in a function call when
\code{ids} was \code{NULL} and \code{var_nms} was used to infer the \code{ids}
(e.g. \code{vm@var_set_make}).
}

\subsection{vm@var_set_make}{

\code{vm@var_set_make} passing \code{var_nms} fixed. It used to pass the
\code{var_nm_set} for the corresponding variable set, now it passes arg
\code{var_nms} (whether inferred or user-given) as intended.
}

\subsection{vm@var_set_maker_set}{

\code{maker} objects of type \code{function} can no longer have \code{...} in their
definition to enable proper checks on inputs when the \code{maker} is called.
}

\subsection{vm@var_set_maker_set}{

\code{vm@var_set_maker_set} now ignores arguments passed via \code{data} to a
\code{maker} of type \code{function} that do not correspond to any argument name.
}

\subsection{vm@var_set_value_space_sample}{

\code{vm@var_set_value_space_sample} arg \code{id} now \code{NULL} by default.
You can supply either \code{id} or \code{var_nms} and the other one is inferred,
if \code{NULL}.
}

}

\subsection{News for version 0.5.2}{
\subsection{vm@vame_make}{

\code{vm@vame_make} gains argument \code{var_nms}. You can now pass either \code{ids} or
\code{var_nms} or both.
}

\subsection{vm@vame_make}{

\code{vm@vame_make} automatically determines the appropriate order of \code{ids}
(whether user-supplied or inferred) in which their \code{maker}s should be
called. For instance if \code{maker} for \code{ids[1]} requires the variables
created by the \code{maker} for \code{ids[2]}, then the latter is called first.
}

\subsection{vm@var_set_make}{

\code{vm@var_set_make} gains argument \code{var_nms}. You can now pass either \code{id} or
\code{var_nms} or both.
}

\subsection{vm@var_set_make}{

\code{vm@var_set_make} now raises an informative error if \code{data} did not
contain something the \code{maker} needs.
}

}

\subsection{News for version 0.5.1}{
\subsection{vame::vame_value_space_sample_default}{

Fixed a utility function used by \code{vame::vame_value_space_sample_default}.
}

}

\subsection{News for version 0.5.0}{
\subsection{vame::VariableMetadata}{

\code{vame::VariableMetadata} now automatically sets \code{var_dt$type} to
\code{"categorical"} where the variable's \code{value_space} is of type
\code{dt} or \code{set} or when \code{var_dt$labeler} has been defined. Remember that
this only occurs when \code{vame::VariableMetadata} is called and any
additional variables you add later will not be treated automatically.
Also, if \code{var_dt$type} was already something other than \code{NA} for a
variable, the automatic determination is not attempted.
}

}

\subsection{News for version 0.4.1}{
\subsection{vm@var_dt_copy}{

\code{vm@var_dt_copy} now actually returns \code{var_dt} instead of \code{var_set_dt}.
}

\subsection{vm@var_set_dt_copy}{

\code{vm@var_set_dt_copy} now actually returns \code{var_set_dt} instead of \code{var_dt}.
}

}

\subsection{News for version 0.4.0}{
\subsection{vame::VariableMetadata}{

\code{var_dt$labeler} of class \code{data.table} specs changed: Now column
containing values for the variable in question must be named \code{x}.
Formerly this was \code{level}.
}

\subsection{vame::VariableMetadata}{

Added recommendations for constructing \code{vame::VariableMetadata} objects into
documentation.
}

\subsection{vm@vame_value_space_sample}{

\code{vm@vame_value_space_sample} gains arguments \code{ids} and \code{data}.
}

\subsection{vm@vame_value_space_sample_default}{

\code{vm@vame_value_space_sample_default} gains arguments \code{ids} and \code{data}.
}

\subsection{vm@var_aggregate}{

\code{vm@var_aggregate} now always considers it possible to aggregate to
\code{to_var_nm} if it only has one value.
}

\subsection{vm@var_describer_get}{

New function \code{vm@var_describer_get}.
}

\subsection{vm@var_describer_set}{

New function \code{vm@var_describer_set}.
}

\subsection{vm@var_description_get}{

New function \code{vm@var_description_get}.
}

\subsection{vm@var_description_get}{

\code{vm@var_description_get} arg \code{description_name} renamed to \code{descr_nm}.
}

\subsection{vm@var_labels_get}{

\code{vm@var_labels_get} arg \code{label_col_nm} renamed to \code{label_nm}.
}

\subsection{vm@var_meta_is_defined}{

\code{vm@var_meta_is_defined} internal problem fixed.
}

\subsection{vm@var_set_make}{

\code{vm@var_set_make} argument \code{data} can now also be a \code{list} object.
}

\subsection{vm@var_set_value_space_sample}{

\code{vm@var_set_value_space_sample} now has new arg \code{data}. Pass your data via
\code{data} when you have a conditional sampling method.
}

}

\subsection{News for version 0.3.0}{
\subsection{vame::self}{

New function \code{vame::self}.
}

\subsection{vm@vame_make}{

New function \code{vm@vame_make}.
}

\subsection{vm@var_set_make}{

New function \code{vm@var_set_make}.
}

\subsection{vm@var_set_maker_get}{

New function \code{vm@var_set_maker_get}.
}

\subsection{vm@var_set_maker_set}{

New function \code{vm@var_set_maker_set}.
}

}

\subsection{News for version 0.2.2}{
\subsection{vame::VariableMetadata}{

\code{vame::VariableMetadata} gains arg \code{vame_list}.
}

\subsection{vm@vame_list_copy}{

New function \code{vm@vame_list_copy}.
}

\subsection{vm@vame_meta_get}{

New function \code{vm@vame_meta_get}.
}

\subsection{vm@vame_meta_is_defined}{

New function \code{vm@vame_meta_is_defined}.
}

\subsection{vm@vame_meta_set}{

New function \code{vm@vame_meta_set}.
}

\subsection{vm@vame_value_space_sample}{

New function \code{vm@var_set_meta_is_defined}.
}

\subsection{vm@vame_value_space_sample_default}{

New function \code{vm@vame_value_space_sample_default}.
}

\subsection{vm@vame_value_space_sampler_get}{

New function \code{vm@vame_value_space_sampler_get}.
}

\subsection{vm@vame_value_space_sampler_set}{

New function \code{vm@vame_value_space_sampler_set}.
}

\subsection{vm@var_dt_copy}{

New function \code{vm@var_dt_copy}.
}

\subsection{vm@var_meta_is_defined}{

New function \code{vm@var_meta_is_defined}.
}

\subsection{vm@var_meta_set}{

\code{vm@var_meta_set} now wraps \code{value} into a list if it isn't a list
and if the target column is a list.
}

\subsection{vm@var_rename}{

Fix renaming multiple variables on one go.
}

\subsection{vm@var_set_dt_copy}{

New function \code{vm@var_set_dt_copy}.
}

\subsection{vm@var_set_meta_is_defined}{

New function \code{vm@var_set_meta_is_defined}.
}

\subsection{vm@var_set_meta_set}{

\code{vm@var_set_meta_set} now wraps \code{value} into a list if it isn't a list
and if the target column is a list.
}

\subsection{vm@var_set_value_space_sample}{

New slot function \code{var_set_value_space_sample}.
}

\subsection{vm@var_set_value_space_sampler_get}{

New slot function \code{var_set_value_space_sampler_get}.
}

\subsection{vm@var_set_value_space_sampler_set}{

New slot function \code{var_set_value_space_sampler_set}.
}

\subsection{vm@var_value_space_sample}{

New function \code{vm@var_value_space_sample}.
}

}

\subsection{News for version 0.2.1}{
\subsection{vm@var_labeler_set}{

A \code{labeler} can now also be of class \code{call}.
}

\subsection{vm@var_labels_get}{

\code{vm@var_labels_get} now can handle \code{labeler}s of class \code{call}.
Added argument \code{labeler_env} for this purpose.
}

}

\subsection{News for version 0.2.0}{
\subsection{VariableMetadata}{

\code{label_dt} was renamed to \code{labeler}.
}

\subsection{vm@vame_subset}{

Rename \code{expr} to \code{var_dt_expr}. Add arg \code{var_set_dt_expr}.
}

\subsection{vm@vame_union_append}{

Rename \code{x} to \code{vm_2}.
}

\subsection{vm@var_labeler_set}{

A \code{labeler} can now be of type \code{function} in addition to \code{data.table}.
}

\subsection{vm@var_labels_get}{

\code{vm@var_labels_get} now can handle \code{labeler}s of type \code{function}.
}

\subsection{vm@var_meta_get_all}{

\code{vm@var_meta_get_all} now always sets \code{var_dt$var_nm} as the names
of the output list or vector.
}

\subsection{vm@var_rename}{

Rename \code{old} to \code{old_var_nms} and \code{new} to \code{new_var_nms}.
}

\subsection{vm@var_set_meta_get_all}{

\code{vm@var_set_meta_get_all} now always sets \code{var_set_dt$id} as the names
of the output list or vector.
}

\subsection{vm@var_set_rename}{

Rename \code{old} to \code{old_ids} and \code{new} to \code{new_ids}.
}

\subsection{vm@var_set_var_nm_set_get}{

Rename \code{vm@var_set_get} to \code{vm@var_set_var_nm_set_get}.
}

\subsection{vm@var_set_var_nm_set_get_all}{

Rename \code{vm@var_set_list_get} to \code{vm@var_set_var_nm_set_get_all}.
}

\subsection{vm@var_set_var_nm_set_set}{

New function \code{vm@var_set_var_nm_set_set}.
}

}

\subsection{News for version 0.1.9}{
\subsection{vm@var_remove}{

\code{vm@var_remove} can now remove multiple variables in one go.
}

\subsection{vm@var_set_value_space_eval}{

\code{vame::var_set_value_space_eval} + \code{vm@var_set_value_space_eval} gain
arg \code{var_nms}. You can now evaluate the value space for only a subset of
the variables in the set.
}

}

\subsection{News for version 0.1.8}{
\subsection{vm@vame_copy}{

New slot fun \code{vm@vame_copy} + new exported fun \code{vame::vame_copy}.
}

}

\subsection{News for version 0.1.7}{
\subsection{vame::VariableMetadata}{

New \code{value_space} type: "unrestricted". Use this when a variable must
be of a certain class but can take any value. E.g.
\code{list(unrestricted = list(class_set = c("IDate", "Date")))}.
}

\subsection{vame::VariableMetadata}{

New \code{value_space} type: "regex". Use this when all values of a variable
must match a specific regex. E.g. \code{list(regex = "^[a-z]$")}.
}

\subsection{vm@var_set_value_space_eval}{

New exported fun \code{vame::var_set_value_space_eval} --- alternative for
\code{vm@var_set_value_space_eval}.
}

}

\subsection{News for version 0.1.6}{
\subsection{vm@vame_union_append}{

fix \code{vame_union_append} --- no longer attempt to remove duplicates
in rbind'd \code{var_dt} because some \code{by} columns may be of type \code{list}
which is not supported by \code{duplicated}.
}

}

\subsection{News for version 0.1.5}{
\subsection{vm@vame_union_append}{

Robustify \code{vame_union_append} --- use \verb{use.names = TRUE, fill = TRUE}
in \code{rbind} calls.
}

}

\subsection{News for version 0.1.4}{
\subsection{vm@vame_union_append}{

Fixed \code{vame_union_append} --- used to always raise an error due to
a misnamed object.
}

}

\subsection{News for version 0.1.3}{
\subsection{vm@var_aggregate}{

New slot \code{var_aggregate}.
}

\subsection{vm@var_assert}{

\code{vm@var_assert} gains arg \code{env}. This is passed
to \code{vm@var_value_space_eval}.
}

\subsection{vm@var_is_aggregateable_to}{

New slot \code{var_is_aggregateable_to}.
}

}

\subsection{News for version 0.1.2}{
\subsection{vm@vame_category_space_dt}{

Also \code{bounds} value space can be used when creating category spaces.
}

\subsection{vm@vame_category_space_dt_list}{

Also \code{bounds} value space can be used when creating category spaces.
}

\subsection{vm@var_assert}{

Added arguments \code{x_nm}, \code{call}.
}

}

\subsection{News for version 0.1.1}{
\subsection{vm@var_assert}{

Fixed \code{var_assert} handling of a value space based on \code{bounds}.
}

\subsection{vm@var_set_value_space_eval}{

New slot \code{vm@var_set_value_space_eval}.
}

\subsection{vm@var_value_space_eval}{

New slot \code{vm@var_value_space_eval}.
}

}

\subsection{News for version 0.1.0}{
\subsection{vame::VariableMetadata}{

First release.
}

}
}

\author{
\strong{Maintainer}: Joonas Miettinen \email{joonas.miettinen@cancer.fi} (\href{https://orcid.org/0000-0001-8624-6754}{ORCID})

}
