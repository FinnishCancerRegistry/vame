% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/01_package_vame.R
\docType{package}
\name{vame}
\alias{vame-package}
\alias{vame}
\title{vame: Variable Metadata}
\description{
\code{vame} makes it simpler to define and make use of metadata pertaining
to one more variables (e.g. a tabular dataset). It implements the
\code{VariableMetadata} class, which contains the metadata. The various metadata
are accessed using slot functions such as \code{vm@var_description_get}.

The \code{VariableMetadata} class is intended for storing metadata for which there
is "one right way". For instance, a variable has one correct description in
text. This philosophy excludes tasks such as creating a manual for a dataset,
which can take many forms.

See the help page \code{?vame::VariableMetadata} for more information. In
particular see the examples.

\href{https://github.com/FinnishCancerRegistry/vame/actions/workflows/R-CMD-check.yaml}{\if{html}{\figure{https://github.com/FinnishCancerRegistry/vame/actions/workflows/R-CMD-check.yaml/badge.svg}}}
}
\section{Recommended installation}{
\if{html}{\out{<div class="sourceCode r">}}\preformatted{devtools::install_github(
  "FinnishCancerRegistry/vame@release"
)
}\if{html}{\out{</div>}}
}

\section{News}{

\subsection{News for version 1.10.1}{
\subsection{vm@vame_subset}{

\code{vm@vame_subset} arg \code{enclos} default fixed. Now uses the environment
where \code{vm@vame_subset} is called.
}

}

\subsection{News for version 1.10.0}{
\subsection{vm@vame_subset}{

\code{vm@vame_subset} gained argument \code{enclos}.
}

}

\subsection{News for version 1.9.4}{
\subsection{vm@var_aggregate}{

\code{vm@var_aggregate} optimised to simply return \code{x} if
\code{from_var_nm == to_var_nm}.
}

\subsection{vm@var_aggregate}{

\code{vm@var_aggregate} now checks that \code{x} and the \code{value_space} of
\code{from_var_nm} have identical class vectors and raises an informative
error if that is not the case.
}

}

\subsection{News for version 1.9.3}{
\subsection{vm@vame_union_append}{

Fixed a bug which sometimes caused an issue with refreshing
\code{var_dt$var_set_dt_pos_set}.
}

}

\subsection{News for version 1.9.2}{
\subsection{vm@vame_union_append}{

Fixed a bug which sometimes caused an issue with \code{vm@vame_union_append}:
\code{var_dt$var_set_dt_pos_set} could be created as an \code{integer}
column instead of the intended \code{list} column.
}

}

\subsection{News for version 1.9.1}{
\subsection{vm@vame_make}{

Improved \code{callbacks} deprecation message.
}

}

\subsection{News for version 1.9.0}{
\subsection{vm@vame_make}{

\code{vm@vame_make} gains arg \code{optional_steps} to replace \code{callbacks}.
Using \code{callbacks} throws a warning now, an error starting in 1.10.0
and it will be removed in 1.11.0.
}

}

\subsection{News for version 1.8.0}{
\subsection{vm@var_set_make}{

\code{vm@var_set_make} now deletes all other columns except \code{var_nms} from output
if such exist. Previously the user could request for e.g.
\code{var_nms = "my_var_1"} only, but if the underlying \code{maker} was defined for
e.g. \code{c("my_var_1", "my_var_2")}, then both were included in output.
So now only \code{"my_var_1"} would be included.
}

}

\subsection{News for version 1.7.0}{
\subsection{vame::VariableMetadata}{

\code{vame::VariableMetadata} now raises an error if \code{var_dt$var_nm} has any
duplicates.
}

\subsection{vame::VariableMetadata}{

\code{vame::VariableMetadata} now raises an error if \code{var_set_dt$id} has any
duplicates.
}

}

\subsection{News for version 1.6.0}{
\subsection{vm@var_set_value_space_eval}{

\code{vm@var_set_value_space_eval} now can make use of a \code{labeler} of class
\code{data.table} in cases where no \code{value_space} is defined for the \code{id},
but \code{var_nms} is of length one, and that variable has such a \code{labeler}.
}

\subsection{vm@var_set_value_space_eval}{

\code{vm@var_set_value_space_eval} now also allows the evaluation result of
a \code{value_space} of type \code{expr} or \code{fun} to be a \code{value_space} object
in itself. In fact that is recommended from now on.
}

}

\subsection{News for version 1.5.0}{
\subsection{vm@vame_harmonise_dt}{

New function \code{vm@vame_harmonise_dt}.
}

\subsection{vm@var_meta_is_defined}{

\code{vm@var_meta_is_defined} now also allows \code{var_nm = NULL}. Then it returns
\code{TRUE/FALSE} depending on whether \code{meta_nm} is a column name of \code{var_dt}.
}

\subsection{vm@var_set_meta_is_defined}{

\code{vm@var_set_meta_is_defined} now also accepts \code{id = NULL}. Then
\code{vm@var_set_meta_is_defined} tests whether \code{meta_nm} is a column name of
\code{var_set_dt}.
}

\subsection{vm@var_var_set_dt_id_set_get}{

New function \code{vm@var_var_set_dt_id_set_get}.
}

\subsection{vm@var_var_set_dt_pos_set_get}{

New function \code{vm@var_var_set_dt_pos_set_get}.
}

}

\subsection{News for version 1.4.0}{
\subsection{vm@vame_union_append}{

\code{vm@vame_union_append} now adds metadata from \code{vm_2} into \code{vm} even for
pre-existing variables where that particular metadata is missing in
\code{vm}. Previously only new variables were added and pre-existing variables'
metadata were untouched.
}

}

\subsection{News for version 1.3.1}{
\subsection{vame}{

All functions that auto-infer \code{id}/\code{ids} which require multiple
metadata for the \code{id} now makes use of the preference defined in the
function. For instance, requiring an \code{id} to have either \code{sampler} or
\code{value_space} now causes the \code{id} value with \code{sampler} defined to
be preferred even if a separate one has \code{value_space}.
}

\subsection{vm@vame_value_space_sample}{

\code{vm@vame_value_space_sample} arg \code{ids} auto-inference now only finds
\code{ids} which have either \code{sampler} or \code{value_space}.
}

\subsection{vm@vame_value_space_sample_default}{

\code{vm@vame_value_space_sample_default} arg \code{ids} auto-inference now only finds
\code{ids} which have either \code{sampler} or \code{value_space}.
}

\subsection{vm@var_set_value_space_sample}{

\code{vm@var_set_value_space_sample} arg \code{id} auto-inference now only finds
one \code{id} which has either \code{sampler} or \code{value_space}.
}

}

\subsection{News for version 1.3.0}{
\subsection{vm@vame_make}{

\code{vm@vame_make} now sets the attribute \code{vame_make_meta} on its output.
}

\subsection{vm@var_set_make}{

\code{vm@var_set_make} now sets attribute \code{var_set_make_meta} on its output.
}

\subsection{vm@var_set_maker_get_dep_var_nm_sets}{

New function \code{vm@var_set_maker_get_dep_var_nm_sets}.
}

}

\subsection{News for version 1.2.0}{
\subsection{vm@vame_make}{

Rename \code{vm@vame_make} \code{callbacks} element \code{pre_loop} to \code{pre_lapply}.
}

\subsection{vm@vame_make}{

\code{vm@vame_make} gains \code{callbacks} element \code{lapply_on_entry}.
}

\subsection{vm@vame_make}{

\code{vm@vame_make} gains \code{callbacks} element \code{lapply_on_exit}.
}

\subsection{vm@vame_make}{

\code{vm@vame_make} gains \code{callbacks} element \code{lapply_pre_var_set_make}.
}

\subsection{vm@vame_make}{

Rename \code{vm@vame_make} \code{callbacks} element \code{post_var_set_make} to
\code{lapply_post_var_set_make}.
}

\subsection{vm@var_set_make}{

\code{vm@var_set_make} can now handle a \code{maker} of type \code{list} with element
\code{dep_var_nm_sets}.
}

\subsection{vm@var_set_maker_set}{

A \code{maker} of type \code{list} can now have element \code{dep_var_nm_sets} instead
of \code{dep_var_nm_set}. \code{dep_var_nm_sets} must be a \code{list} of variable name
sets --- different allowed options. If your \code{maker} only works on one
specific set of dependency variables, it is easier for you to keep using
\code{dep_var_nm_set}. The possibility of using \code{dep_var_nm_sets} was added
to enable writing a \code{maker} such as
\code{quote(switch(dep_var_nm_set, b = b + 1L, c = c - 1L))}, where the target
variable can be made using either \code{b} or \code{c}.
}

}

\subsection{News for version 1.1.1}{
\subsection{vame::self}{

Fixed \code{vame::self()} --- it failed to find the \code{VariableMetadata} object
in some cases although it is intended to work until deletion.
}

}

\subsection{News for version 1.1.0}{
\subsection{vame::self}{

\code{vame::self()} deprecated. Refer to the \code{vame::VariableMetadata} itself
using \code{vm}.
}

\subsection{vm@var_description_get}{

\code{vm@var_description_get} now makes variables \code{var_nm}, \code{descr_nm}, and \code{vm}
available for \code{describer} types \code{function} and \code{call}.
}

\subsection{vm@var_labels_get}{

\code{vm@var_labels_get} now makes variables \code{x}, \code{var_nm}, \code{label_nm}, and \code{vm}
available for \code{labeler} types \code{function} and \code{call}.
}

\subsection{vm@var_set_value_space_eval}{

\code{vm@var_set_value_space_eval} now makes variables \code{id}, \code{var_nms}, and \code{vm}
available for \code{labeler} types \code{function} and \code{call}.
}

\subsection{vm@var_set_value_space_sample}{

\code{vm@var_set_value_space_sample} object \code{x} passed to the \code{sampler} renamed
to \code{vm}. It is the \code{VariableMetadata} object itself.
}

}

\subsection{News for version 1.0.1}{
\subsection{vm@vame_make}{

\code{vm@vame_make} gains \code{callbacks} element \code{on_entry}.
}

\subsection{vm@vame_make}{

\code{vm@vame_make} gains \code{callbacks} element \code{pre_loop}.
}

}

\subsection{News for version 1.0.0}{
\subsection{vm@vame_make}{

\code{vm@vame_make} gains argument \code{callbacks}.
}

}

\subsection{News for version 0.5.8}{
\subsection{vame}{

An individual description text for a \code{describer} can now be a \code{character}
string vector (without \code{NA}) with more than one element. Formerly
length one was required.
}

\subsection{vame}{

The elements of a \code{describer} of type \code{list} can now be vectors with
more than one element. Formerly only vectors of length one were allowed.
}

}

\subsection{News for version 0.5.7}{
\subsection{vm@var_meta_set}{

\code{vm@var_meta_set} now always wraps \code{value} into a list before adding
it into \code{vm} when \code{meta_nm \%in\% c("describer", "labeler")} --- those are
known \code{list} columns.
}

\subsection{vm@var_set_meta_set}{

\code{vm@var_set_meta_set} now always wraps \code{value} into a list before adding
it into \code{vm} when \code{meta_nm \%in\% c("value_space", "maker")} --- those are
known \code{list} columns.
}

}

\subsection{News for version 0.5.6}{
\subsection{vm@vame_meta_set}{

\code{vm@vame_meta_set} now checks \code{value} for validity for "officially"
defined metadata such as \code{sampler}. Formerly this was done only by
the corresponding wrapper such as \code{vm@vame_value_space_sampler_set}.
}

\subsection{vm@var_meta_set}{

\code{vm@var_meta_set} now checks \code{value} for validity for "officially" defined
metadata such as \code{describer}. Formerly this was done only by
the corresponding wrapper such as \code{vm@var_describer_set}.
}

\subsection{vm@var_set_meta_set}{

\code{vm@var_set_meta_set} now checks \code{value} for validity for "officially"
defined metadata such as \code{value_space}. Formerly this was done only by
the corresponding wrapper such as \code{vm@var_set_value_space_set}.
}

}

\subsection{News for version 0.5.5}{
\subsection{vm@vame_copy}{

\code{vm@vame_copy} now also copies \code{vame_list}.
}

}

\subsection{News for version 0.5.4}{
\subsection{vm@vame_subset}{

Fix use of \code{substitute} in turning args \code{var_dt_expr} + \code{var_set_dt_expr}
into a quoted expression.
}

}

\subsection{News for version 0.5.3}{
\subsection{vame}{

Fixed an extra comma in a function call when
\code{ids} was \code{NULL} and \code{var_nms} was used to infer the \code{ids}
(e.g. \code{vm@var_set_make}).
}

\subsection{vm@var_set_make}{

\code{vm@var_set_make} passing \code{var_nms} fixed. It used to pass the
\code{var_nm_set} for the corresponding variable set, now it passes arg
\code{var_nms} (whether inferred or user-given) as intended.
}

\subsection{vm@var_set_maker_set}{

\code{maker} objects of type \code{function} can no longer have \code{...} in their
definition to enable proper checks on inputs when the \code{maker} is called.
}

\subsection{vm@var_set_maker_set}{

\code{vm@var_set_maker_set} now ignores arguments passed via \code{data} to a
\code{maker} of type \code{function} that do not correspond to any argument name.
}

\subsection{vm@var_set_value_space_sample}{

\code{vm@var_set_value_space_sample} arg \code{id} now \code{NULL} by default.
You can supply either \code{id} or \code{var_nms} and the other one is inferred,
if \code{NULL}.
}

}

\subsection{News for version 0.5.2}{
\subsection{vm@vame_make}{

\code{vm@vame_make} gains argument \code{var_nms}. You can now pass either \code{ids} or
\code{var_nms} or both.
}

\subsection{vm@vame_make}{

\code{vm@vame_make} automatically determines the appropriate order of \code{ids}
(whether user-supplied or inferred) in which their \code{maker}s should be
called. For instance if \code{maker} for \code{ids[1]} requires the variables
created by the \code{maker} for \code{ids[2]}, then the latter is called first.
}

\subsection{vm@var_set_make}{

\code{vm@var_set_make} gains argument \code{var_nms}. You can now pass either \code{id} or
\code{var_nms} or both.
}

\subsection{vm@var_set_make}{

\code{vm@var_set_make} now raises an informative error if \code{data} did not
contain something the \code{maker} needs.
}

}

\subsection{News for version 0.5.1}{
\subsection{vame::vame_value_space_sample_default}{

Fixed a utility function used by \code{vame::vame_value_space_sample_default}.
}

}

\subsection{News for version 0.5.0}{
\subsection{vame::VariableMetadata}{

\code{vame::VariableMetadata} now automatically sets \code{var_dt$type} to
\code{"categorical"} where the variable's \code{value_space} is of type
\code{dt} or \code{set} or when \code{var_dt$labeler} has been defined. Remember that
this only occurs when \code{vame::VariableMetadata} is called and any
additional variables you add later will not be treated automatically.
Also, if \code{var_dt$type} was already something other than \code{NA} for a
variable, the automatic determination is not attempted.
}

}

\subsection{News for version 0.4.1}{
\subsection{vm@var_dt_copy}{

\code{vm@var_dt_copy} now actually returns \code{var_dt} instead of \code{var_set_dt}.
}

\subsection{vm@var_set_dt_copy}{

\code{vm@var_set_dt_copy} now actually returns \code{var_set_dt} instead of \code{var_dt}.
}

}

\subsection{News for version 0.4.0}{
\subsection{vame::VariableMetadata}{

\code{var_dt$labeler} of class \code{data.table} specs changed: Now column
containing values for the variable in question must be named \code{x}.
Formerly this was \code{level}.
}

\subsection{vame::VariableMetadata}{

Added recommendations for constructing \code{vame::VariableMetadata} objects into
documentation.
}

\subsection{vm@vame_value_space_sample}{

\code{vm@vame_value_space_sample} gains arguments \code{ids} and \code{data}.
}

\subsection{vm@vame_value_space_sample_default}{

\code{vm@vame_value_space_sample_default} gains arguments \code{ids} and \code{data}.
}

\subsection{vm@var_aggregate}{

\code{vm@var_aggregate} now always considers it possible to aggregate to
\code{to_var_nm} if it only has one value.
}

\subsection{vm@var_describer_get}{

New function \code{vm@var_describer_get}.
}

\subsection{vm@var_describer_set}{

New function \code{vm@var_describer_set}.
}

\subsection{vm@var_description_get}{

New function \code{vm@var_description_get}.
}

\subsection{vm@var_description_get}{

\code{vm@var_description_get} arg \code{description_name} renamed to \code{descr_nm}.
}

\subsection{vm@var_labels_get}{

\code{vm@var_labels_get} arg \code{label_col_nm} renamed to \code{label_nm}.
}

\subsection{vm@var_meta_is_defined}{

\code{vm@var_meta_is_defined} internal problem fixed.
}

\subsection{vm@var_set_make}{

\code{vm@var_set_make} argument \code{data} can now also be a \code{list} object.
}

\subsection{vm@var_set_value_space_sample}{

\code{vm@var_set_value_space_sample} now has new arg \code{data}. Pass your data via
\code{data} when you have a conditional sampling method.
}

}

\subsection{News for version 0.3.0}{
\subsection{vame::self}{

New function \code{vame::self}.
}

\subsection{vm@vame_make}{

New function \code{vm@vame_make}.
}

\subsection{vm@var_set_make}{

New function \code{vm@var_set_make}.
}

\subsection{vm@var_set_maker_get}{

New function \code{vm@var_set_maker_get}.
}

\subsection{vm@var_set_maker_set}{

New function \code{vm@var_set_maker_set}.
}

}

\subsection{News for version 0.2.2}{
\subsection{vame::VariableMetadata}{

\code{vame::VariableMetadata} gains arg \code{vame_list}.
}

\subsection{vm@vame_list_copy}{

New function \code{vm@vame_list_copy}.
}

\subsection{vm@vame_meta_get}{

New function \code{vm@vame_meta_get}.
}

\subsection{vm@vame_meta_is_defined}{

New function \code{vm@vame_meta_is_defined}.
}

\subsection{vm@vame_meta_set}{

New function \code{vm@vame_meta_set}.
}

\subsection{vm@vame_value_space_sample}{

New function \code{vm@var_set_meta_is_defined}.
}

\subsection{vm@vame_value_space_sample_default}{

New function \code{vm@vame_value_space_sample_default}.
}

\subsection{vm@vame_value_space_sampler_get}{

New function \code{vm@vame_value_space_sampler_get}.
}

\subsection{vm@vame_value_space_sampler_set}{

New function \code{vm@vame_value_space_sampler_set}.
}

\subsection{vm@var_dt_copy}{

New function \code{vm@var_dt_copy}.
}

\subsection{vm@var_meta_is_defined}{

New function \code{vm@var_meta_is_defined}.
}

\subsection{vm@var_meta_set}{

\code{vm@var_meta_set} now wraps \code{value} into a list if it isn't a list
and if the target column is a list.
}

\subsection{vm@var_rename}{

Fix renaming multiple variables on one go.
}

\subsection{vm@var_set_dt_copy}{

New function \code{vm@var_set_dt_copy}.
}

\subsection{vm@var_set_meta_is_defined}{

New function \code{vm@var_set_meta_is_defined}.
}

\subsection{vm@var_set_meta_set}{

\code{vm@var_set_meta_set} now wraps \code{value} into a list if it isn't a list
and if the target column is a list.
}

\subsection{vm@var_set_value_space_sample}{

New slot function \code{var_set_value_space_sample}.
}

\subsection{vm@var_set_value_space_sampler_get}{

New slot function \code{var_set_value_space_sampler_get}.
}

\subsection{vm@var_set_value_space_sampler_set}{

New slot function \code{var_set_value_space_sampler_set}.
}

\subsection{vm@var_value_space_sample}{

New function \code{vm@var_value_space_sample}.
}

}

\subsection{News for version 0.2.1}{
\subsection{vm@var_labeler_set}{

A \code{labeler} can now also be of class \code{call}.
}

\subsection{vm@var_labels_get}{

\code{vm@var_labels_get} now can handle \code{labeler}s of class \code{call}.
Added argument \code{labeler_env} for this purpose.
}

}

\subsection{News for version 0.2.0}{
\subsection{VariableMetadata}{

\code{label_dt} was renamed to \code{labeler}.
}

\subsection{vm@vame_subset}{

Rename \code{expr} to \code{var_dt_expr}. Add arg \code{var_set_dt_expr}.
}

\subsection{vm@vame_union_append}{

Rename \code{x} to \code{vm_2}.
}

\subsection{vm@var_labeler_set}{

A \code{labeler} can now be of type \code{function} in addition to \code{data.table}.
}

\subsection{vm@var_labels_get}{

\code{vm@var_labels_get} now can handle \code{labeler}s of type \code{function}.
}

\subsection{vm@var_meta_get_all}{

\code{vm@var_meta_get_all} now always sets \code{var_dt$var_nm} as the names
of the output list or vector.
}

\subsection{vm@var_rename}{

Rename \code{old} to \code{old_var_nms} and \code{new} to \code{new_var_nms}.
}

\subsection{vm@var_set_meta_get_all}{

\code{vm@var_set_meta_get_all} now always sets \code{var_set_dt$id} as the names
of the output list or vector.
}

\subsection{vm@var_set_rename}{

Rename \code{old} to \code{old_ids} and \code{new} to \code{new_ids}.
}

\subsection{vm@var_set_var_nm_set_get}{

Rename \code{vm@var_set_get} to \code{vm@var_set_var_nm_set_get}.
}

\subsection{vm@var_set_var_nm_set_get_all}{

Rename \code{vm@var_set_list_get} to \code{vm@var_set_var_nm_set_get_all}.
}

\subsection{vm@var_set_var_nm_set_set}{

New function \code{vm@var_set_var_nm_set_set}.
}

}

\subsection{News for version 0.1.9}{
\subsection{vm@var_remove}{

\code{vm@var_remove} can now remove multiple variables in one go.
}

\subsection{vm@var_set_value_space_eval}{

\code{vame::var_set_value_space_eval} + \code{vm@var_set_value_space_eval} gain
arg \code{var_nms}. You can now evaluate the value space for only a subset of
the variables in the set.
}

}

\subsection{News for version 0.1.8}{
\subsection{vm@vame_copy}{

New slot fun \code{vm@vame_copy} + new exported fun \code{vame::vame_copy}.
}

}

\subsection{News for version 0.1.7}{
\subsection{vame::VariableMetadata}{

New \code{value_space} type: "unrestricted". Use this when a variable must
be of a certain class but can take any value. E.g.
\code{list(unrestricted = list(class_set = c("IDate", "Date")))}.
}

\subsection{vame::VariableMetadata}{

New \code{value_space} type: "regex". Use this when all values of a variable
must match a specific regex. E.g. \code{list(regex = "^[a-z]$")}.
}

\subsection{vm@var_set_value_space_eval}{

New exported fun \code{vame::var_set_value_space_eval} --- alternative for
\code{vm@var_set_value_space_eval}.
}

}

\subsection{News for version 0.1.6}{
\subsection{vm@vame_union_append}{

fix \code{vame_union_append} --- no longer attempt to remove duplicates
in rbind'd \code{var_dt} because some \code{by} columns may be of type \code{list}
which is not supported by \code{duplicated}.
}

}

\subsection{News for version 0.1.5}{
\subsection{vm@vame_union_append}{

Robustify \code{vame_union_append} --- use \verb{use.names = TRUE, fill = TRUE}
in \code{rbind} calls.
}

}

\subsection{News for version 0.1.4}{
\subsection{vm@vame_union_append}{

Fixed \code{vame_union_append} --- used to always raise an error due to
a misnamed object.
}

}

\subsection{News for version 0.1.3}{
\subsection{vm@var_aggregate}{

New slot \code{var_aggregate}.
}

\subsection{vm@var_assert}{

\code{vm@var_assert} gains arg \code{env}. This is passed
to \code{vm@var_value_space_eval}.
}

\subsection{vm@var_is_aggregateable_to}{

New slot \code{var_is_aggregateable_to}.
}

}

\subsection{News for version 0.1.2}{
\subsection{vm@vame_category_space_dt}{

Also \code{bounds} value space can be used when creating category spaces.
}

\subsection{vm@vame_category_space_dt_list}{

Also \code{bounds} value space can be used when creating category spaces.
}

\subsection{vm@var_assert}{

Added arguments \code{x_nm}, \code{call}.
}

}

\subsection{News for version 0.1.1}{
\subsection{vm@var_assert}{

Fixed \code{var_assert} handling of a value space based on \code{bounds}.
}

\subsection{vm@var_set_value_space_eval}{

New slot \code{vm@var_set_value_space_eval}.
}

\subsection{vm@var_value_space_eval}{

New slot \code{vm@var_value_space_eval}.
}

}

\subsection{News for version 0.1.0}{
\subsection{vame::VariableMetadata}{

First release.
}

}
}

\author{
\strong{Maintainer}: Joonas Miettinen \email{joonas.miettinen@cancer.fi} (\href{https://orcid.org/0000-0001-8624-6754}{ORCID})

}
