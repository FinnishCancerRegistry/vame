% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/01_package_vame.R
\docType{package}
\name{vame}
\alias{vame-package}
\alias{vame}
\title{vame: Variable Metadata}
\description{
\code{vame} makes it simpler to define and make use of metadata pertaining
to one more variables (e.g. a tabular dataset). It implements the
\code{VariableMetadata} class, which contains the metadata. The various metadata
are accessed using slot functions such as \code{vm@var_description_get}.

The \code{VariableMetadata} class is intended for storing metadata for which there
is "one right way". For instance, a variable has one correct description in
text. This philosophy excludes tasks such as creating a manual for a dataset,
which can take many forms.

See the help page \code{?vame::VariableMetadata} for more information. In
particular see the examples.

\href{https://github.com/FinnishCancerRegistry/vame/actions/workflows/R-CMD-check.yaml}{\if{html}{\figure{https://github.com/FinnishCancerRegistry/vame/actions/workflows/R-CMD-check.yaml/badge.svg}}}
}
\section{Recommended installation}{
\if{html}{\out{<div class="sourceCode r">}}\preformatted{devtools::install_github(
  "FinnishCancerRegistry/vame",
  ref = readline("enter latest tag on github: ")
)
}\if{html}{\out{</div>}}
\subsection{TODO}{
\subsection{Priority: high}{
\subsection{Type: feat}{

\code{vm@vame_category_space_dt}:

\code{vm@var_set_make} can be used in place of \code{vm@var_set_value_space_eval}
(or maybe \code{vm@var_set_value_space_eval} can call \code{vm@var_set_make})
in the case of categorical variables when
multiple columns are requested AND the necessary data is available from
other value spaces. Currently in v0.3.0.16 it is necessary to have ALL
dependent variables in one \code{value_space} to show the dependency in the
output of at least \code{vm@vame_category_space_dt}. The downside is the
potential slowdown.

Maybe there needs to be a smart system, or user-input-based system, of
knowing which variable sets depend on what other variable sets. For instance
the user can include column \code{var_set_dt$dep_id_set}.
}

}

\subsection{Priority: low}{
\subsection{Type: feat}{

\code{vm@var_set_value_space_sample}:

The issue of dependent variables
appears in both \code{sampler} and \code{maker} objects. It could be argued that
they should be required to have the same set of dependent variables. This
would mean improving the corresponding assertion functions. Alternatively,
a new column \code{var_set_dt$dep_var_nm_set} or even \code{var_set_dt$dep_id_set}
could be implemented --- but currently \code{sampler} objects can also sample
independently, so implmenting e.g. \code{var_set_dt$dep_id_set} would require
that independent samplers can still work. Currently in 0.3.0.15 using
\code{dep_var_nm_set} in \code{sampler} causes \code{data} to be asserted to contain
such variables. Maybe an independent \code{sampler} would need to be marked
in a special way so that the \code{data} assertion is not performed.
}

}

}
}

\section{News}{

\subsection{News for version 0.5.4}{
\subsection{vm@vame_subset}{

Fix use of \code{substitute} in turning args \code{var_dt_expr} + \code{var_set_dt_expr}
into a quoted expression.
}

}

\subsection{News for version 0.5.3}{
\subsection{vame}{

Fixed an extra comma in a function call when
\code{ids} was \code{NULL} and \code{var_nms} was used to infer the \code{ids}
(e.g. \code{vm@var_set_make}).
}

\subsection{vm@var_set_make}{

\code{vm@var_set_make} passing \code{var_nms} fixed. It used to pass the
\code{var_nm_set} for the corresponding variable set, now it passes arg
\code{var_nms} (whether inferred or user-given) as intended.
}

\subsection{vm@var_set_maker_set}{

\code{maker} objects of type \code{function} can no longer have \code{...} in their
definition to enable proper checks on inputs when the \code{maker} is called.
}

\subsection{vm@var_set_maker_set}{

\code{vm@var_set_maker_set} now ignores arguments passed via \code{data} to a
\code{maker} of type \code{function} that do not correspond to any argument name.
}

\subsection{vm@var_set_value_space_sample}{

\code{vm@var_set_value_space_sample} arg \code{id} now \code{NULL} by default.
You can supply either \code{id} or \code{var_nms} and the other one is inferred,
if \code{NULL}.
}

}

\subsection{News for version 0.5.2}{
\subsection{vm@vame_make}{

\code{vm@vame_make} gains argument \code{var_nms}. You can now pass either \code{ids} or
\code{var_nms} or both.
}

\subsection{vm@vame_make}{

\code{vm@vame_make} automatically determines the appropriate order of \code{ids}
(whether user-supplied or inferred) in which their \code{maker}s should be
called. For instance if \code{maker} for \code{ids[1]} requires the variables
created by the \code{maker} for \code{ids[2]}, then the latter is called first.
}

\subsection{vm@var_set_make}{

\code{vm@var_set_make} gains argument \code{var_nms}. You can now pass either \code{id} or
\code{var_nms} or both.
}

\subsection{vm@var_set_make}{

\code{vm@var_set_make} now raises an informative error if \code{data} did not
contain something the \code{maker} needs.
}

}

\subsection{News for version 0.5.1}{
\subsection{vame::vame_value_space_sample_default}{

Fixed a utility function used by \code{vame::vame_value_space_sample_default}.
}

}

\subsection{News for version 0.5.0}{
\subsection{vame::VariableMetadata}{

\code{vame::VariableMetadata} now automatically sets \code{var_dt$type} to
\code{"categorical"} where the variable's \code{value_space} is of type
\code{dt} or \code{set} or when \code{var_dt$labeler} has been defined. Remember that
this only occurs when \code{vame::VariableMetadata} is called and any
additional variables you add later will not be treated automatically.
Also, if \code{var_dt$type} was already something other than \code{NA} for a
variable, the automatic determination is not attempted.
}

}

\subsection{News for version 0.4.1}{
\subsection{vm@var_dt_copy}{

\code{vm@var_dt_copy} now actually returns \code{var_dt} instead of \code{var_set_dt}.
}

\subsection{vm@var_set_dt_copy}{

\code{vm@var_set_dt_copy} now actually returns \code{var_set_dt} instead of \code{var_dt}.
}

}

\subsection{News for version 0.4.0}{
\subsection{vame::VariableMetadata}{

\code{var_dt$labeler} of class \code{data.table} specs changed: Now column
containing values for the variable in question must be named \code{x}.
Formerly this was \code{level}.
}

\subsection{vame::VariableMetadata}{

Added recommendations for constructing \code{vame::VariableMetadata} objects into
documentation.
}

\subsection{vm@vame_value_space_sample}{

\code{vm@vame_value_space_sample} gains arguments \code{ids} and \code{data}.
}

\subsection{vm@vame_value_space_sample_default}{

\code{vm@vame_value_space_sample_default} gains arguments \code{ids} and \code{data}.
}

\subsection{vm@var_aggregate}{

\code{vm@var_aggregate} now always considers it possible to aggregate to
\code{to_var_nm} if it only has one value.
}

\subsection{vm@var_describer_get}{

New function \code{vm@var_describer_get}.
}

\subsection{vm@var_describer_set}{

New function \code{vm@var_describer_set}.
}

\subsection{vm@var_description_get}{

New function \code{vm@var_description_get}.
}

\subsection{vm@var_description_get}{

\code{vm@var_description_get} arg \code{description_name} renamed to \code{descr_nm}.
}

\subsection{vm@var_labels_get}{

\code{vm@var_labels_get} arg \code{label_col_nm} renamed to \code{label_nm}.
}

\subsection{vm@var_meta_is_defined}{

\code{vm@var_meta_is_defined} internal problem fixed.
}

\subsection{vm@var_set_make}{

\code{vm@var_set_make} argument \code{data} can now also be a \code{list} object.
}

\subsection{vm@var_set_value_space_sample}{

\code{vm@var_set_value_space_sample} now has new arg \code{data}. Pass your data via
\code{data} when you have a conditional sampling method.
}

}

\subsection{News for version 0.3.0}{
\subsection{vame::self}{

New function \code{vame::self}.
}

\subsection{vm@vame_make}{

New function \code{vm@vame_make}.
}

\subsection{vm@var_set_make}{

New function \code{vm@var_set_make}.
}

\subsection{vm@var_set_maker_get}{

New function \code{vm@var_set_maker_get}.
}

\subsection{vm@var_set_maker_set}{

New function \code{vm@var_set_maker_set}.
}

}

\subsection{News for version 0.2.2}{
\subsection{vame::VariableMetadata}{

\code{vame::VariableMetadata} gains arg \code{vame_list}.
}

\subsection{vm@vame_list_copy}{

New function \code{vm@vame_list_copy}.
}

\subsection{vm@vame_meta_get}{

New function \code{vm@vame_meta_get}.
}

\subsection{vm@vame_meta_is_defined}{

New function \code{vm@vame_meta_is_defined}.
}

\subsection{vm@vame_meta_set}{

New function \code{vm@vame_meta_set}.
}

\subsection{vm@vame_value_space_sample}{

New function \code{vm@var_set_meta_is_defined}.
}

\subsection{vm@vame_value_space_sample_default}{

New function \code{vm@vame_value_space_sample_default}.
}

\subsection{vm@vame_value_space_sampler_get}{

New function \code{vm@vame_value_space_sampler_get}.
}

\subsection{vm@vame_value_space_sampler_set}{

New function \code{vm@vame_value_space_sampler_set}.
}

\subsection{vm@var_dt_copy}{

New function \code{vm@var_dt_copy}.
}

\subsection{vm@var_meta_is_defined}{

New function \code{vm@var_meta_is_defined}.
}

\subsection{vm@var_meta_set}{

\code{vm@var_meta_set} now wraps \code{value} into a list if it isn't a list
and if the target column is a list.
}

\subsection{vm@var_rename}{

Fix renaming multiple variables on one go.
}

\subsection{vm@var_set_dt_copy}{

New function \code{vm@var_set_dt_copy}.
}

\subsection{vm@var_set_meta_is_defined}{

New function \code{vm@var_set_meta_is_defined}.
}

\subsection{vm@var_set_meta_set}{

\code{vm@var_set_meta_set} now wraps \code{value} into a list if it isn't a list
and if the target column is a list.
}

\subsection{vm@var_set_value_space_sample}{

New slot function \code{var_set_value_space_sample}.
}

\subsection{vm@var_set_value_space_sampler_get}{

New slot function \code{var_set_value_space_sampler_get}.
}

\subsection{vm@var_set_value_space_sampler_set}{

New slot function \code{var_set_value_space_sampler_set}.
}

\subsection{vm@var_value_space_sample}{

New function \code{vm@var_value_space_sample}.
}

}

\subsection{News for version 0.2.1}{
\subsection{vm@var_labeler_set}{

A \code{labeler} can now also be of class \code{call}.
}

\subsection{vm@var_labels_get}{

\code{vm@var_labels_get} now can handle \code{labeler}s of class \code{call}.
Added argument \code{labeler_env} for this purpose.
}

}

\subsection{News for version 0.2.0}{
\subsection{VariableMetadata}{

\code{label_dt} was renamed to \code{labeler}.
}

\subsection{vm@vame_subset}{

Rename \code{expr} to \code{var_dt_expr}. Add arg \code{var_set_dt_expr}.
}

\subsection{vm@vame_union_append}{

Rename \code{x} to \code{vm_2}.
}

\subsection{vm@var_labeler_set}{

A \code{labeler} can now be of type \code{function} in addition to \code{data.table}.
}

\subsection{vm@var_labels_get}{

\code{vm@var_labels_get} now can handle \code{labeler}s of type \code{function}.
}

\subsection{vm@var_meta_get_all}{

\code{vm@var_meta_get_all} now always sets \code{var_dt$var_nm} as the names
of the output list or vector.
}

\subsection{vm@var_rename}{

Rename \code{old} to \code{old_var_nms} and \code{new} to \code{new_var_nms}.
}

\subsection{vm@var_set_meta_get_all}{

\code{vm@var_set_meta_get_all} now always sets \code{var_set_dt$id} as the names
of the output list or vector.
}

\subsection{vm@var_set_rename}{

Rename \code{old} to \code{old_ids} and \code{new} to \code{new_ids}.
}

\subsection{vm@var_set_var_nm_set_get}{

Rename \code{vm@var_set_get} to \code{vm@var_set_var_nm_set_get}.
}

\subsection{vm@var_set_var_nm_set_get_all}{

Rename \code{vm@var_set_list_get} to \code{vm@var_set_var_nm_set_get_all}.
}

\subsection{vm@var_set_var_nm_set_set}{

New function \code{vm@var_set_var_nm_set_set}.
}

}

\subsection{News for version 0.1.9}{
\subsection{vm@var_remove}{

\code{vm@var_remove} can now remove multiple variables in one go.
}

\subsection{vm@var_set_value_space_eval}{

\code{vame::var_set_value_space_eval} + \code{vm@var_set_value_space_eval} gain
arg \code{var_nms}. You can now evaluate the value space for only a subset of
the variables in the set.
}

}

\subsection{News for version 0.1.8}{
\subsection{vm@vame_copy}{

New slot fun \code{vm@vame_copy} + new exported fun \code{vame::vame_copy}.
}

}

\subsection{News for version 0.1.7}{
\subsection{vame::VariableMetadata}{

New \code{value_space} type: "unrestricted". Use this when a variable must
be of a certain class but can take any value. E.g.
\code{list(unrestricted = list(class_set = c("IDate", "Date")))}.
}

\subsection{vame::VariableMetadata}{

New \code{value_space} type: "regex". Use this when all values of a variable
must match a specific regex. E.g. \code{list(regex = "^[a-z]$")}.
}

\subsection{vm@var_set_value_space_eval}{

New exported fun \code{vame::var_set_value_space_eval} --- alternative for
\code{vm@var_set_value_space_eval}.
}

}

\subsection{News for version 0.1.6}{
\subsection{vm@vame_union_append}{

fix \code{vame_union_append} --- no longer attempt to remove duplicates
in rbind'd \code{var_dt} because some \code{by} columns may be of type \code{list}
which is not supported by \code{duplicated}.
}

}

\subsection{News for version 0.1.5}{
\subsection{vm@vame_union_append}{

Robustify \code{vame_union_append} --- use \verb{use.names = TRUE, fill = TRUE}
in \code{rbind} calls.
}

}

\subsection{News for version 0.1.4}{
\subsection{vm@vame_union_append}{

Fixed \code{vame_union_append} --- used to always raise an error due to
a misnamed object.
}

}

\subsection{News for version 0.1.3}{
\subsection{vm@var_aggregate}{

New slot \code{var_aggregate}.
}

\subsection{vm@var_assert}{

\code{vm@var_assert} gains arg \code{env}. This is passed
to \code{vm@var_value_space_eval}.
}

\subsection{vm@var_is_aggregateable_to}{

New slot \code{var_is_aggregateable_to}.
}

}

\subsection{News for version 0.1.2}{
\subsection{vm@vame_category_space_dt}{

Also \code{bounds} value space can be used when creating category spaces.
}

\subsection{vm@vame_category_space_dt_list}{

Also \code{bounds} value space can be used when creating category spaces.
}

\subsection{vm@var_assert}{

Added arguments \code{x_nm}, \code{call}.
}

}

\subsection{News for version 0.1.1}{
\subsection{vm@var_assert}{

Fixed \code{var_assert} handling of a value space based on \code{bounds}.
}

\subsection{vm@var_set_value_space_eval}{

New slot \code{vm@var_set_value_space_eval}.
}

\subsection{vm@var_value_space_eval}{

New slot \code{vm@var_value_space_eval}.
}

}

\subsection{News for version 0.1.0}{
\subsection{vame::VariableMetadata}{

First release.
}

}
}

\author{
\strong{Maintainer}: Joonas Miettinen \email{joonas.miettinen@cancer.fi} (\href{https://orcid.org/0000-0001-8624-6754}{ORCID})

}
