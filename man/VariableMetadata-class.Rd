% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/09_S4.R
\docType{class}
\name{VariableMetadata-class}
\alias{VariableMetadata-class}
\alias{VariableMetadata}
\title{Variable Metadata}
\usage{
VariableMetadata(var_dt, var_set_dt)
}
\arguments{
\item{var_dt}{\verb{[data.table]}

Contains information for individual variables. Must contain at a minimum
column \code{var_nm}.}

\item{var_set_dt}{\verb{[data.table]}

Contains information for sets of variables --- e.g. a common value space.
Must contain at a minimum columns
\itemize{
\item \code{id} \code{\link{character}}: Identifies each set of variable names. E.g.
\code{"my_set"}.
\item \code{var_nm_set} \verb{[list]}: Each list element contains a character string
vector of variable names. e.g. \code{list(c("a", "b"))}.
}}
}
\description{
The \code{VariableMetadata} object.
}
\section{Slots}{

\describe{
\item{\code{var_set_list_get}}{\emph{Description}

Get every variable name set.

\emph{Usage}

\code{vm@var_set_list_get()}}

\item{\code{var_set_get}}{\emph{Description}

Get a specific variable name set.

\emph{Usage}

\code{vm@var_set_get(id)}

\emph{Arguments}

\code{id} \verb{[any]} (no default)

ID, or "name", of a variable set. The class of \code{id} is defined when you
create the \code{VariableMetadata} object and it can be pretty much anything.}

\item{\code{var_set_meta_get}}{\emph{Description}

Get metadata for a specific variable set.

\emph{Usage}

\code{vm@var_set_meta_get(id, meta_nm)}

\emph{Arguments}

\code{id} \verb{[any]} (no default)

ID, or "name", of a variable set. The class of \code{id} is defined when you
create the \code{VariableMetadata} object and it can be pretty much anything.

\code{meta_nm} \verb{[character]} (no default)

Name of a metadata column in \code{var_set_dt} or \code{var_dt} (depending on context)
of a \code{VariableMetadata} object.}

\item{\code{var_set_meta_set}}{\emph{Description}

Set metadata for a specific variable set.

\emph{Usage}

\code{vm@var_set_meta_set(id, meta_nm, value)}

\emph{Arguments}

\code{id} \verb{[any]} (no default)

ID, or "name", of a variable set. The class of \code{id} is defined when you
create the \code{VariableMetadata} object and it can be pretty much anything.

\code{meta_nm} \verb{[character]} (no default)

Name of a metadata column in \code{var_set_dt} or \code{var_dt} (depending on context)
of a \code{VariableMetadata} object.

\code{value} \verb{[any]} (no default)

In \verb{_set} functions the \code{value} to set for the specified metadata.}

\item{\code{var_set_meta_get_all}}{\emph{Description}

Get all metadata for a specific variable set.

\emph{Usage}

\code{vm@var_set_meta_get_all(meta_nm)}

\emph{Arguments}

\code{meta_nm} \verb{[character]} (no default)

Name of a metadata column in \code{var_set_dt} or \code{var_dt} (depending on context)
of a \code{VariableMetadata} object.}

\item{\code{var_set_rename}}{\emph{Description}

Rename a variable set --- change its \code{id}.

\emph{Usage}

\code{vm@var_set_rename(old, new)}

\emph{Arguments}

\code{old} \verb{[character]} (no default)

Old names.

\code{new} \verb{[character]} (no default)

New names.}

\item{\code{var_set_remove}}{\emph{Description}

Remove a variable set by \code{id}.

\emph{Usage}

\code{vm@var_set_remove(id)}

\emph{Arguments}

\code{id} \verb{[any]} (no default)

ID, or "name", of a variable set. The class of \code{id} is defined when you
create the \code{VariableMetadata} object and it can be pretty much anything.}

\item{\code{var_set_value_space_get}}{\emph{Description}

Get the value space of a specific variable set without evaluting it.

\emph{Usage}

\code{vm@var_set_value_space_get(id)}

\emph{Arguments}

\code{id} \verb{[any]} (no default)

ID, or "name", of a variable set. The class of \code{id} is defined when you
create the \code{VariableMetadata} object and it can be pretty much anything.}

\item{\code{var_set_value_space_set}}{\emph{Description}

Set the value space of a specific variable set.

\emph{Usage}

\code{vm@var_set_value_space_set(id, value_space)}

\emph{Arguments}

\code{id} \verb{[any]} (no default)

ID, or "name", of a variable set. The class of \code{id} is defined when you
create the \code{VariableMetadata} object and it can be pretty much anything.

\code{value_space} \verb{[list]} (no default)

A value space to assign for the specified variable set.}

\item{\code{var_set_value_space_eval}}{\emph{Description}

Retrieve and evaluate value space for a variable set given its \code{id}.

\emph{Usage}

\code{vm@var_set_value_space_eval(id, var_nms, env)}

\emph{Arguments}

\code{id} \verb{[any]} (no default)

ID, or "name", of a variable set. The class of \code{id} is defined when you
create the \code{VariableMetadata} object and it can be pretty much anything.

\code{var_nms} \verb{[NULL, character]} (default \code{NULL})
\itemize{
\item \code{NULL}: Get the value space for variables in the set.
\item \code{character}: Get the value spaces for only these variables.
}

\code{env} \verb{[NULL, }env\verb{ironment]} (default \code{NULL})

Environment where a value space will be evaluated, if applicable.
\itemize{
\item \code{NULL}: Use the \code{env}ironment where the function was called.
\item \code{env}ironment\verb{: Use this }env`ironment.
}}

\item{\code{var_set_value_space_dt_subset}}{\emph{Description}

Take a subset of a value space dt for a variable set and set that as the value space.

\emph{Usage}

\code{vm@var_set_value_space_dt_subset(id, expr)}

\emph{Arguments}

\code{id} \verb{[any]} (no default)

ID, or "name", of a variable set. The class of \code{id} is defined when you
create the \code{VariableMetadata} object and it can be pretty much anything.

\code{expr} \verb{[any]} (no default)

Expression to subset a \code{data.table} object. Available columns depends on
context.}

\item{\code{var_is_aggregateable_to}}{\emph{Description}

Returns \code{TRUE} if \code{from_var_nm} can be aggregated into \code{to_var_nm}.

\emph{Usage}

\code{vm@var_is_aggregateable_to(from_var_nm, to_var_nm)}

\emph{Arguments}

\code{from_var_nm} \verb{[character]} (no default)

Name of a variable. Aggregation from this to another variable.

\code{to_var_nm} \verb{[character]} (no default)

Name of a variable. Aggregation to this from another variable.}

\item{\code{var_aggregate}}{\emph{Description}

Returns correspoding level of \code{to_var_nm} for each value in \code{x}.
Get and evaluate value space for a variable.

\emph{Usage}

\code{vm@var_aggregate(x, from_var_nm, to_var_nm)}

\emph{Arguments}

\code{x} \verb{[any]} (no default)

Values of a specified variable.

\code{from_var_nm} \verb{[character]} (no default)

Name of a variable. Aggregation from this to another variable.

\code{to_var_nm} \verb{[character]} (no default)

Name of a variable. Aggregation to this from another variable.}

\item{\code{var_value_space_eval}}{\emph{Description}

\emph{Usage}

\code{vm@var_value_space_eval(var_nm, env)}

\emph{Arguments}

\code{var_nm} \verb{[character]} (no default)

Name of a variable.

\code{env} \verb{[NULL, }env\verb{ironment]} (default \code{NULL})

Environment where a value space will be evaluated, if applicable.
\itemize{
\item \code{NULL}: Use the \code{env}ironment where the function was called.
\item \code{env}ironment\verb{: Use this }env`ironment.
}}

\item{\code{var_assert}}{\emph{Description}

Assert that values in \code{x} are proper values of \code{var_nm}.

\emph{Usage}

\code{vm@var_assert(x, var_nm, x_nm, call, assertion_type, env)}

\emph{Arguments}

\code{x} \verb{[any]} (no default)

Values of a specified variable.

\code{var_nm} \verb{[character]} (no default)

Name of a variable.

\code{x_nm} \verb{[NULL, character]} (default \code{NULL})

See \link[dbc:argument_handlers]{dbc::handle_arg_x_nm}.

\code{call} \verb{[NULL, language]} (default \code{NULL})

See \link[dbc:argument_handlers]{dbc::handle_arg_call}.

\code{assertion_type} \verb{[NULL, character]} (default \code{NULL})

See \link[dbc:assertion_types]{dbc::handle_arg_assertion_type}.

\code{env} \verb{[NULL, }env\verb{ironment]} (default \code{NULL})

Environment where a value space will be evaluated, if applicable.
\itemize{
\item \code{NULL}: Use the \code{env}ironment where the function was called.
\item \code{env}ironment\verb{: Use this }env`ironment.
}}

\item{\code{var_meta_get}}{\emph{Description}

Get metadata for a variable.

\emph{Usage}

\code{vm@var_meta_get(var_nm, meta_nm)}

\emph{Arguments}

\code{var_nm} \verb{[character]} (no default)

Name of a variable.

\code{meta_nm} \verb{[character]} (no default)

Name of a metadata column in \code{var_set_dt} or \code{var_dt} (depending on context)
of a \code{VariableMetadata} object.}

\item{\code{var_meta_set}}{\emph{Description}

Set metadata for a variable.

\emph{Usage}

\code{vm@var_meta_set(var_nm, meta_nm, value)}

\emph{Arguments}

\code{var_nm} \verb{[character]} (no default)

Name of a variable.

\code{meta_nm} \verb{[character]} (no default)

Name of a metadata column in \code{var_set_dt} or \code{var_dt} (depending on context)
of a \code{VariableMetadata} object.

\code{value} \verb{[any]} (no default)

In \verb{_set} functions the \code{value} to set for the specified metadata.}

\item{\code{var_meta_get_all}}{\emph{Description}

Get metadata for all variables.

\emph{Usage}

\code{vm@var_meta_get_all(meta_nm)}

\emph{Arguments}

\code{meta_nm} \verb{[character]} (no default)

Name of a metadata column in \code{var_set_dt} or \code{var_dt} (depending on context)
of a \code{VariableMetadata} object.}

\item{\code{var_rename}}{\emph{Description}

Rename a variable.

\emph{Usage}

\code{vm@var_rename(old, new)}

\emph{Arguments}

\code{old} \verb{[character]} (no default)

Old names.

\code{new} \verb{[character]} (no default)

New names.}

\item{\code{var_remove}}{\emph{Description}

Remove a variable.

\emph{Usage}

\code{vm@var_remove(var_nm)}

\emph{Arguments}

\code{var_nm} \verb{[character]} (no default)

Name of a variable.}

\item{\code{var_labeler_get}}{\emph{Description}

Get the labeler for a variable.
Set the labeler for a variable.

\emph{Usage}

\code{vm@var_labeler_get(var_nm)}

\emph{Arguments}

\code{var_nm} \verb{[character]} (no default)

Name of a variable.}

\item{\code{var_labeler_set}}{\emph{Description}

\emph{Usage}

\code{vm@var_labeler_set(var_nm, value)}

\emph{Arguments}

\code{var_nm} \verb{[character]} (no default)

Name of a variable.

\code{value} \verb{[any]} (no default)

In \verb{_set} functions the \code{value} to set for the specified metadata.}

\item{\code{var_labels_get}}{\emph{Description}

Get label for each value in \code{x} for \code{var_nm}.

\emph{Usage}

\code{vm@var_labels_get(x, var_nm, label_col_nm)}

\emph{Arguments}

\code{x} \verb{[any]} (no default)

Values of a specified variable.

\code{var_nm} \verb{[character]} (no default)

Name of a variable.

\code{label_col_nm} \verb{[NULL, character]} (default \code{NULL})

Name of a column in the \code{labeler} that has been assigned for the variable.
Labels will be taken from this column.
\itemize{
\item \code{NULL}: Use first column name in \code{labeler} that is not \code{"level"} --- if
\code{labeler} is a \code{data.table}.
\item \code{character}: Use this column name.
}}

\item{\code{vame_copy}}{\emph{Description}

Take a deep copy of a VariableMetadata object. See \code{?data.table::copy}.

\emph{Usage}

\code{vm@vame_copy()}}

\item{\code{vame_subset}}{\emph{Description}

Subset whole \code{VariableMetadata} object.

\emph{Usage}

\code{vm@vame_subset(expr)}

\emph{Arguments}

\code{expr} \verb{[any]} (no default)

Expression to subset a \code{data.table} object. Available columns depends on
context.}

\item{\code{vame_union_append}}{\emph{Description}

Append new data into \code{VariableMetadata} object from another.
No pre-existing data are overwritten.

\emph{Usage}

\code{vm@vame_union_append(x)}

\emph{Arguments}

\code{x} \verb{[any]} (no default)

Values of a specified variable.}

\item{\code{vame_category_space_dt_list}}{\emph{Description}

Get list of category space \code{data.table} objects.

\emph{Usage}

\code{vm@vame_category_space_dt_list(var_nms, env)}

\emph{Arguments}

\code{var_nms} \verb{[NULL, character]} (default \code{NULL})
\itemize{
\item \code{NULL}: Get the value space for variables in the set.
\item \code{character}: Get the value spaces for only these variables.
}

\code{env} \verb{[NULL, }env\verb{ironment]} (default \code{NULL})

Environment where a value space will be evaluated, if applicable.
\itemize{
\item \code{NULL}: Use the \code{env}ironment where the function was called.
\item \code{env}ironment\verb{: Use this }env`ironment.
}}

\item{\code{vame_category_space_dt}}{\emph{Description}

Get a category space \code{data.table}.

\emph{Usage}

\code{vm@vame_category_space_dt(var_nms, env)}

\emph{Arguments}

\code{var_nms} \verb{[NULL, character]} (default \code{NULL})
\itemize{
\item \code{NULL}: Get the value space for variables in the set.
\item \code{character}: Get the value spaces for only these variables.
}

\code{env} \verb{[NULL, }env\verb{ironment]} (default \code{NULL})

Environment where a value space will be evaluated, if applicable.
\itemize{
\item \code{NULL}: Use the \code{env}ironment where the function was called.
\item \code{env}ironment\verb{: Use this }env`ironment.
}}
}}

\examples{

# vame::VariableMetadata ----------------------------------------------------

# basic example of different kinds of variables
value_space_d <- function() 1:3 * 100L
vm <- vame::VariableMetadata(
  var_dt = data.table::data.table(
    var_nm = c("a", "b", "c", "d", "e", "f", "g", "h"),
    type = c("categorical", "categorical",
             "categorical",
             "my_type_1", "my_type_2", "my_type_3", "my_type_4", "my_type_5")
  ),
  var_set_dt = data.table::data.table(
    id = c("ab", "c", "d", "e", "f", "g", "h"),
    var_nm_set = list(
      ab = c("a", "b"),
      c = "c", d = "d", e = "e", f = "f", g = "g", h = "h"),
    value_space = list(
      ab = list(dt = data.table::data.table(
        a = c(1L, 2L, 2L),
        b = c(11L, 21L, 22L)
      )),
      c = list(set = c("a", "b")),
      d = list(expr = quote(value_space_d())),
      e = list(bounds = list(
        lo = 0.0, hi = 10.0,
        lo_inclusive = TRUE, hi_inclusive = TRUE
      )),
      f = list(bounds = list(
        lo = as.Date("1901-01-01"), hi = as.Date("2023-12-31"),
        lo_inclusive = TRUE, hi_inclusive = TRUE
      )),
      g = list(unrestricted = list(class_set = c("IDate", "Date"))),
      h = list(regex = "^[a-z]$")
    )
  )
)
vm@var_assert(1L, var_nm = "a")
vm@var_assert(21L, var_nm = "b")
vm@var_assert("a", var_nm = "c")
vm@var_assert(100L, var_nm = "d")
vm@var_assert(c(0.0, 10.0), var_nm = "e")
vm@var_assert(as.Date("1901-01-01"), var_nm = "f")
vm@var_assert(data.table::as.IDate("1901-01-01"), var_nm = "g")
vm@var_assert(letters, var_nm = "h")
my_fun <- function(e_values) {
  vm@var_assert(e_values, var_nm = "e")
  e_values + 1
}
my_fun(0.0)

# renaming, removing variables
vm <- vame::VariableMetadata(
  var_dt = data.table::data.table(
    var_nm = c("a", "b", "c"),
    flavour = c("tasty", "rancid", "bitter")
  ),
  var_set_dt = data.table::data.table(
    id = "set_01",
    var_nm_set = list(c("a", "b")),
    value_space = list(list(dt = data.table::data.table(
      a = 1:2,
      b = 3:4
    )))
  )
)

vm@var_rename("a", "A")
stopifnot(
  identical(vm@var_meta_get("A", "flavour"), "tasty"),
  identical(names(vm@var_set_value_space_get("set_01")[["dt"]]), c("A", "b")),
  identical(vm@var_set_meta_get("set_01", "var_nm_set"), c("A", "b"))
)

vm@var_set_rename("set_01", "Ab")
stopifnot(
  identical(vm@var_set_meta_get_all("id"), "Ab")
)

vm@var_remove("b")
stopifnot(
  identical(names(vm@var_set_value_space_get("Ab")[["dt"]]), "A"),
  identical(vm@var_set_meta_get("Ab", "var_nm_set"), "A")
)

vm@var_set_remove("Ab")
stopifnot(
  identical(length(vm@var_set_meta_get_all("var_nm_set")), 0L)
)

# retrieving category space data.tables
dt_01 <- data.table::CJ(a = 1:3, b = 3:1, c = 1:3)
dt_02 <- data.table::CJ(d = 1:2, e = 2:1)
vm <- vame::VariableMetadata(
  var_dt = data.table::data.table(
    var_nm = c("a", "b", "c", "d", "e", "f"),
    type = "categorical"
  ),
  var_set_dt = data.table::data.table(
    id = c("abc", "de", "f"),
    var_nm_set = list(
      abc = c("a", "b", "c"),
      de = c("d", "e"),
      f = "f"
     ),
    value_space = list(
      abc = list(dt = dt_01),
      de = list(expr = quote({
        dt_02[
          i = !duplicated(dt_02, by = var_nms),
          j = .SD,
          .SDcols = var_nms
        ]
      })),
      f = list(bounds = list(
        lo = 0L, hi = 10L,
        lo_inclusive = TRUE, hi_inclusive = TRUE
      ))
    )
  )
)

stopifnot(
  all.equal(
    vm@vame_category_space_dt(c("a", "b")),
    dt_01[
      i = !duplicated(dt_01, by = c("a", "b")),
      j = .SD,
      .SDcols = c("a", "b")
    ],
    check.attributes = FALSE
  ),
  all.equal(
    vm@vame_category_space_dt(c("d", "e")),
    dt_02,
    check.attributes = FALSE
  ),
  all.equal(
    vm@vame_category_space_dt(c("a", "f")),
    data.table::CJ(a = 1:3, f = 0:10),
    check.attributes = FALSE
  )
)

# getting category space data.tables --- here a variable appears in
# two different value spaces. this can be handy for defining joint value
# spaces and also conversions & aggregations.
dt_01 <- data.table::CJ(a = 1:3, b = 3:1, c = 1:3)
dt_02 <- data.table::CJ(a = 0:1, e = 2:1)
dt_03 <- data.table::data.table(a = 0:3, a_2 = c(1L,1L, 2L,2L))
vm <- vame::VariableMetadata(
  var_dt = data.table::data.table(
    var_nm = c("a", "b", "c", "e", "a_2"),
    type = "categorical"
  ),
  var_set_dt = data.table::data.table(
    id = c("set_01", "set_02", "set_03"),
    var_nm_set = list(c("a", "b", "c"), c("a", "e"), c("a", "a_2")),
    value_space = list(
      list(dt = dt_01),
      list(dt = dt_02),
      list(dt = dt_03)
    )
  )
)

obs <- vm@vame_category_space_dt(c("a", "b", "e"))
exp <- data.table::data.table(
  a = c(0L, 0L, 1L, 1L, 1L, 1L, 1L, 1L, 2L, 2L, 2L, 3L, 3L, 3L),
  b = c(NA, NA, 1L, 1L, 2L, 2L, 3L, 3L, 1L, 2L, 3L, 1L, 2L, 3L),
  e = c(1L, 2L, 1L, 2L, 1L, 2L, 1L, 2L, NA, NA, NA, NA, NA, NA)
)
data.table::setkeyv(obs, names(obs))
data.table::setkeyv(exp, names(exp))
stopifnot(
  all.equal(obs, exp, check.attributes = FALSE)
)

stopifnot(
  vm@var_is_aggregateable_to("a", "a_2"),
  identical(vm@var_aggregate(0:1, "a", "a_2"), c(1L,1L))
)

# getting labels for variable levels
dt_01 <- data.table::CJ(a = 1:3, b = 3:1, c = 4:5)
vm <- vame::VariableMetadata(
  var_dt = data.table::data.table(
    var_nm = c("a", "b", "c"),
    type = "categorical",
    labeler = list(
      a = data.table::data.table(
        level = 1:3,
        en = paste0("a_level_", 1:3)
      ),
      b = function(x, label_col_nm) {
        dt <- data.table::data.table(
          level = 1:3,
          en = paste0("b_level_", 1:3)
        )
        dt[[label_col_nm]][match(x, dt[["level"]])]
      },
      c = NULL
    )
  ),
  var_set_dt = data.table::data.table(
    id = c("set_01"),
    var_nm_set = list(c("a", "b", "c")),
    value_space = list(
      list(dt = dt_01)
    )
  )
)

obs <- vm@var_labels_get(x = 1:4, var_nm = "a", label_col_nm = "en")
exp <- c(paste0("a_level_", 1:3), NA)
stopifnot(
  identical(obs, exp)
)

obs <- tryCatch(
  vm@var_labels_get(
    x = 1:4,
    var_nm = "a",
    label_col_nm = "this does not exist"
  ),
  error = function(e) e[["message"]]
)
exp <- paste0(
  "label_col_nm = \"this does not exist\"",
  " not one of the defined label columns: \"en\""
)
stopifnot(
  grepl(exp, obs)
)

obs <- tryCatch(
  vm@var_labels_get(
    x = 1:4,
    var_nm = "c",
    label_col_nm = "en"
  ),
  error = function(e) e[["message"]]
)
exp <- "Variable \"c\" has no labeler defined"
stopifnot(
  grepl(exp, obs)
)

# adding data to a pre-existing VariableMetadata object
vm_1 <- vame::VariableMetadata(
  var_dt = data.table::data.table(
    var_nm = c("a", "b"),
    type = "categorical",
    labeler = list(
      a = data.table::data.table(level = 1:2, label = c("a_1", "a_2")),
      b = NULL
    )
  ),
  var_set_dt = data.table::data.table(
    id = "ab",
    var_nm_set = list(ab = c("a", "b")),
    value_space = list(ab = list(dt = data.table::CJ(a = 1:2, b = 3:4)))
  )
)
# note that vm_2 var_dt does not have columns "type", "labeler" --- those
# will be NA / NULL for "c" and "d".
vm_2 <- vame::VariableMetadata(
  var_dt = data.table::data.table(var_nm = c("c", "d")),
  var_set_dt = data.table::data.table(
    id = "cd",
    var_nm_set = list(cd = c("c", "d")),
    value_space = list(cd = list(dt = data.table::CJ(c = 5:6, d = 7:8)))
  )
)
vm_1@vame_union_append(vm_2)
stopifnot(
  c("ab", "cd") \%in\% vm_1@var_set_meta_get_all("id")
)

# taking a copy of a VariableMetadata object
vm_3 <- vm_2@vame_copy()
vm_2@var_rename("d", "dd")
stopifnot(
  "d" \%in\% vm_3@var_meta_get_all("var_nm"),
  !"d" \%in\% vm_2@var_meta_get_all("var_nm"),
  "dd" \%in\% vm_2@var_meta_get_all("var_nm")
)
}
