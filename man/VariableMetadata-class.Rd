% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/10_S4.R
\docType{class}
\name{VariableMetadata-class}
\alias{VariableMetadata-class}
\alias{VariableMetadata}
\title{Variable Metadata}
\usage{
VariableMetadata(var_dt, var_set_dt)
}
\arguments{
\item{var_dt}{\verb{[data.table]}

Contains information for individual variables. Must contain at a minimum
column \code{var_nm}.}

\item{var_set_dt}{\verb{[data.table]}

Contains information for sets of variables --- e.g. a common value space.
Must contain at a minimum columns
\itemize{
\item \code{id} \code{\link{character}}: Identifies each set of variable names. E.g.
\code{"my_set"}.
\item \code{var_nm_set} \verb{[list]}: Each list element contains a character string
vector of variable names. e.g. \code{list(c("a", "b"))}.
}}
}
\description{
Create and make use of a \code{VariableMetadata} object. It contains
\itemize{
\item \code{var_dt}: A \code{data.table} containing metadata for variables,
\item \code{var_set_dt}: Metadata for variable sets,
\item A number of functions in S4 slots for making use of the metadata via e.g.
\code{vm@var_assert} where \code{vm} is the \code{VariableMetadata} object.
}

A \code{VariableMetadata} object is created via calling the
\code{vame::VariableMetadata} function.
See section \strong{Features} for what you can do with \code{VariableMetadata} objects.
}
\section{Slots}{

\describe{
\item{\code{var_set_meta_is_defined}}{\emph{Description}

Returns \code{TRUE} if \code{var_set_dt[[meta_nm]]} exists.

\emph{Usage}

\code{vm@var_set_meta_is_defined(id, meta_nm)}

\emph{Arguments}

\code{id} \verb{[any]} (no default)

ID, or "name", of a variable set. The class of \code{id} is defined when you
create the \code{VariableMetadata} object and it can be pretty much anything.

\code{meta_nm} \verb{[character]} (no default)

Name of a metadata column in \code{var_set_dt} or \code{var_dt} (depending on context)
of a \code{VariableMetadata} object.}

\item{\code{var_set_meta_get}}{\emph{Description}

Get metadata for a specific variable set.

\emph{Usage}

\code{vm@var_set_meta_get(id, meta_nm)}

\emph{Arguments}

\code{id} \verb{[any]} (no default)

ID, or "name", of a variable set. The class of \code{id} is defined when you
create the \code{VariableMetadata} object and it can be pretty much anything.

\code{meta_nm} \verb{[character]} (no default)

Name of a metadata column in \code{var_set_dt} or \code{var_dt} (depending on context)
of a \code{VariableMetadata} object.}

\item{\code{var_set_meta_set}}{\emph{Description}

Set metadata for a specific variable set.

\emph{Usage}

\code{vm@var_set_meta_set(id, meta_nm, value)}

\emph{Arguments}

\code{id} \verb{[any]} (no default)

ID, or "name", of a variable set. The class of \code{id} is defined when you
create the \code{VariableMetadata} object and it can be pretty much anything.

\code{meta_nm} \verb{[character]} (no default)

Name of a metadata column in \code{var_set_dt} or \code{var_dt} (depending on context)
of a \code{VariableMetadata} object.

\code{value} \verb{[any]} (no default)

In \verb{_set} functions the \code{value} to set for the specified metadata.}

\item{\code{var_set_meta_get_all}}{\emph{Description}

Get all metadata for a specific variable set.

\emph{Usage}

\code{vm@var_set_meta_get_all(meta_nm)}

\emph{Arguments}

\code{meta_nm} \verb{[character]} (no default)

Name of a metadata column in \code{var_set_dt} or \code{var_dt} (depending on context)
of a \code{VariableMetadata} object.}

\item{\code{var_set_var_nm_set_get_all}}{\emph{Description}

Get every variable name set.

\emph{Usage}

\code{vm@var_set_var_nm_set_get_all()}}

\item{\code{var_set_var_nm_set_get}}{\emph{Description}

Get a specific variable name set.

\emph{Usage}

\code{vm@var_set_var_nm_set_get(id)}

\emph{Arguments}

\code{id} \verb{[any]} (no default)

ID, or "name", of a variable set. The class of \code{id} is defined when you
create the \code{VariableMetadata} object and it can be pretty much anything.}

\item{\code{var_set_var_nm_set_set}}{\emph{Description}

Set a new value for a specific variable name set.

\emph{Usage}

\code{vm@var_set_var_nm_set_set(id, value)}

\emph{Arguments}

\code{id} \verb{[any]} (no default)

ID, or "name", of a variable set. The class of \code{id} is defined when you
create the \code{VariableMetadata} object and it can be pretty much anything.

\code{value} \verb{[any]} (no default)

In \verb{_set} functions the \code{value} to set for the specified metadata.}

\item{\code{var_set_rename}}{\emph{Description}

Rename variable sets --- change \code{var_set_dt$id} values.

\emph{Usage}

\code{vm@var_set_rename(old_ids, new_ids)}

\emph{Arguments}

\code{old_ids} \verb{[any]} (no default)

Old variable set IDs.

\code{new_ids} \verb{[any]} (no default)

New variable set IDs.}

\item{\code{var_set_remove}}{\emph{Description}

Remove a variable set by \code{id}.

\emph{Usage}

\code{vm@var_set_remove(id)}

\emph{Arguments}

\code{id} \verb{[any]} (no default)

ID, or "name", of a variable set. The class of \code{id} is defined when you
create the \code{VariableMetadata} object and it can be pretty much anything.}

\item{\code{var_set_value_space_eval}}{\emph{Description}

Retrieve and evaluate value space for a variable set given its \code{id}.

\emph{Usage}

\code{vm@var_set_value_space_eval(id, var_nms, env)}

\emph{Arguments}

\code{id} \verb{[any]} (no default)

ID, or "name", of a variable set. The class of \code{id} is defined when you
create the \code{VariableMetadata} object and it can be pretty much anything.

\code{var_nms} \verb{[NULL, character]} (default \code{NULL})
\itemize{
\item \code{NULL}: Get the value space for all variables in the set.
\item \code{character}: Get the value spaces for only these variables.
}

\code{env} \verb{[NULL, }env\verb{ironment]} (default \code{NULL})

Environment where a value space will be evaluated, if applicable.
\itemize{
\item \code{NULL}: Use the \code{env}ironment where the function was called.
\item \code{env}ironment\verb{: Use this }env`ironment.
}}

\item{\code{var_set_value_space_get}}{\emph{Description}

Get the value space of a specific variable set without evaluting it.

\emph{Usage}

\code{vm@var_set_value_space_get(id)}

\emph{Arguments}

\code{id} \verb{[any]} (no default)

ID, or "name", of a variable set. The class of \code{id} is defined when you
create the \code{VariableMetadata} object and it can be pretty much anything.}

\item{\code{var_set_value_space_set}}{\emph{Description}

Set the value space of a specific variable set.

\emph{Usage}

\code{vm@var_set_value_space_set(id, value_space)}

\emph{Arguments}

\code{id} \verb{[any]} (no default)

ID, or "name", of a variable set. The class of \code{id} is defined when you
create the \code{VariableMetadata} object and it can be pretty much anything.

\code{value_space} \verb{[list]} (no default)

A value space to assign for the specified variable set.}

\item{\code{var_set_value_space_dt_subset}}{\emph{Description}

Take a subset of a value space dt for a variable set and set that as the value space.

\emph{Usage}

\code{vm@var_set_value_space_dt_subset(id, expr)}

\emph{Arguments}

\code{id} \verb{[any]} (no default)

ID, or "name", of a variable set. The class of \code{id} is defined when you
create the \code{VariableMetadata} object and it can be pretty much anything.

\code{expr} \verb{[any]} (no default)

Expression to subset a \code{data.table} object. Available columns depends on
context.}

\item{\code{var_set_value_space_sampler_get}}{\emph{Description}

Retrieve value space sampler for given \code{id} from \code{var_set_dt$sampler}.

\emph{Usage}

\code{vm@var_set_value_space_sampler_get(id)}

\emph{Arguments}

\code{id} \verb{[any]} (no default)

ID, or "name", of a variable set. The class of \code{id} is defined when you
create the \code{VariableMetadata} object and it can be pretty much anything.}

\item{\code{var_set_value_space_sampler_set}}{\emph{Description}

Assign value space sampler for given \code{id} in \code{var_set_dt$sampler}.

\emph{Usage}

\code{vm@var_set_value_space_sampler_set(id, value)}

\emph{Arguments}

\code{id} \verb{[any]} (no default)

ID, or "name", of a variable set. The class of \code{id} is defined when you
create the \code{VariableMetadata} object and it can be pretty much anything.

\code{value} \verb{[any]} (no default)

In \verb{_set} functions the \code{value} to set for the specified metadata.}

\item{\code{var_set_value_space_sample}}{\emph{Description}

Returns \code{n} samples from the value space of \code{id}.

Random sampling is performed as follows:
\itemize{
\item \code{vm@var_set_value_space_eval} is called for the appropriate value space
\item The appropriate sampler is retrieved --- this is either the corresponding
sampler stored in \code{var_set_dt$sampler}, or no sampler exists there,
one of the defaults depending on the type of the value space:
\itemize{
\item \code{dt}: Sample uniformly rows from \code{data.table} with replacement.
\item \code{set}: Sample uniformly from set with replacement.
\item \code{expr} & \code{fun}: Handling depends on the type of output: A vector
output is handled as a \code{set} and a \code{data.table} output as a \code{dt}.
\item \code{unrestricted}: If \code{class_set = "character"}, sample random strings
of length 16 using character pool \code{c(letters, LETTERS, 0:9)}. If
\code{class_set} is anything else, raise an error because no sampler is
defined for the general case.
\item \code{regex}: Raise error because no sampler defined.
\item \code{bounds}: Sample uniformly between \code{lo} and \code{hi} --- with
replacement for integer-valued bounds.
}
\item The sampler is called or evaluated, which results in the random samples,
and these are returned.
}

\emph{Usage}

\code{vm@var_set_value_space_sample(id, var_nms, env, n)}

\emph{Arguments}

\code{id} \verb{[any]} (no default)

ID, or "name", of a variable set. The class of \code{id} is defined when you
create the \code{VariableMetadata} object and it can be pretty much anything.

\code{var_nms} \verb{[NULL, character]} (default \code{NULL})
\itemize{
\item \code{NULL}: Get the value space for all variables in the set.
\item \code{character}: Get the value spaces for only these variables.
}

\code{env} \verb{[NULL, }env\verb{ironment]} (default \code{NULL})

Environment where a value space will be evaluated, if applicable.
\itemize{
\item \code{NULL}: Use the \code{env}ironment where the function was called.
\item \code{env}ironment\verb{: Use this }env`ironment.
}

\code{n} \verb{[integer]} (default \code{1L})

Number of random samples to take.}

\item{\code{var_is_aggregateable_to}}{\emph{Description}

Returns \code{TRUE} if \code{from_var_nm} can be aggregated into \code{to_var_nm}.

\emph{Usage}

\code{vm@var_is_aggregateable_to(from_var_nm, to_var_nm)}

\emph{Arguments}

\code{from_var_nm} \verb{[character]} (no default)

Name of a variable. Aggregation from this to another variable.

\code{to_var_nm} \verb{[character]} (no default)

Name of a variable. Aggregation to this from another variable.}

\item{\code{var_aggregate}}{\emph{Description}

Returns correspoding level of \code{to_var_nm} for each value in \code{x}.
Get and evaluate value space for a variable.

\emph{Usage}

\code{vm@var_aggregate(x, from_var_nm, to_var_nm)}

\emph{Arguments}

\code{x} \verb{[any]} (no default)

Values of a specified variable.

\code{from_var_nm} \verb{[character]} (no default)

Name of a variable. Aggregation from this to another variable.

\code{to_var_nm} \verb{[character]} (no default)

Name of a variable. Aggregation to this from another variable.}

\item{\code{var_value_space_eval}}{\emph{Description}

\emph{Usage}

\code{vm@var_value_space_eval(var_nm, env)}

\emph{Arguments}

\code{var_nm} \verb{[character]} (no default)

Name of a variable.

\code{env} \verb{[NULL, }env\verb{ironment]} (default \code{NULL})

Environment where a value space will be evaluated, if applicable.
\itemize{
\item \code{NULL}: Use the \code{env}ironment where the function was called.
\item \code{env}ironment\verb{: Use this }env`ironment.
}}

\item{\code{var_assert}}{\emph{Description}

Assert that values in \code{x} are proper values of \code{var_nm}.

\emph{Usage}

\code{vm@var_assert(x, var_nm, x_nm, call, assertion_type, env)}

\emph{Arguments}

\code{x} \verb{[any]} (no default)

Values of a specified variable.

\code{var_nm} \verb{[character]} (no default)

Name of a variable.

\code{x_nm} \verb{[NULL, character]} (default \code{NULL})

See \link[dbc:argument_handlers]{dbc::handle_arg_x_nm}.

\code{call} \verb{[NULL, language]} (default \code{NULL})

See \link[dbc:argument_handlers]{dbc::handle_arg_call}.

\code{assertion_type} \verb{[NULL, character]} (default \code{NULL})

See \link[dbc:assertion_types]{dbc::handle_arg_assertion_type}.

\code{env} \verb{[NULL, }env\verb{ironment]} (default \code{NULL})

Environment where a value space will be evaluated, if applicable.
\itemize{
\item \code{NULL}: Use the \code{env}ironment where the function was called.
\item \code{env}ironment\verb{: Use this }env`ironment.
}}

\item{\code{var_meta_is_defined}}{\emph{Description}

Returns \code{TRUE} if \code{var_dt[[meta_nm]]} exists.

\emph{Usage}

\code{vm@var_meta_is_defined(var_nm, meta_nm)}

\emph{Arguments}

\code{var_nm} \verb{[character]} (no default)

Name of a variable.

\code{meta_nm} \verb{[character]} (no default)

Name of a metadata column in \code{var_set_dt} or \code{var_dt} (depending on context)
of a \code{VariableMetadata} object.}

\item{\code{var_meta_get}}{\emph{Description}

Get metadata for a variable.

\emph{Usage}

\code{vm@var_meta_get(var_nm, meta_nm)}

\emph{Arguments}

\code{var_nm} \verb{[character]} (no default)

Name of a variable.

\code{meta_nm} \verb{[character]} (no default)

Name of a metadata column in \code{var_set_dt} or \code{var_dt} (depending on context)
of a \code{VariableMetadata} object.}

\item{\code{var_meta_set}}{\emph{Description}

Set metadata for a variable.

\emph{Usage}

\code{vm@var_meta_set(var_nm, meta_nm, value)}

\emph{Arguments}

\code{var_nm} \verb{[character]} (no default)

Name of a variable.

\code{meta_nm} \verb{[character]} (no default)

Name of a metadata column in \code{var_set_dt} or \code{var_dt} (depending on context)
of a \code{VariableMetadata} object.

\code{value} \verb{[any]} (no default)

In \verb{_set} functions the \code{value} to set for the specified metadata.}

\item{\code{var_meta_get_all}}{\emph{Description}

Get metadata for all variables.

\emph{Usage}

\code{vm@var_meta_get_all(meta_nm)}

\emph{Arguments}

\code{meta_nm} \verb{[character]} (no default)

Name of a metadata column in \code{var_set_dt} or \code{var_dt} (depending on context)
of a \code{VariableMetadata} object.}

\item{\code{var_rename}}{\emph{Description}

Rename variables. The name is changed in the following places:
\itemize{
\item \code{var_dt$var_nm}
\item \code{var_set_dt$value_space}, if the \code{value_space} object is of type \code{dt}.
If the \code{value_space} is of type \code{expr} or \code{fun}, \code{vm@var_rename} emits
a warning because it does not attempt to alter R expressions or
functions --- you will have to do that youself.
\item \code{var_set_dt$var_nm_set}
}

\emph{Usage}

\code{vm@var_rename(old_var_nms, new_var_nms)}

\emph{Arguments}

\code{old_var_nms} \verb{[character]} (no default)

Variable names to change.

\code{new_var_nms} \verb{[character]} (no default)

Variable names to change to.}

\item{\code{var_remove}}{\emph{Description}

Remove a variable.

\emph{Usage}

\code{vm@var_remove(var_nm)}

\emph{Arguments}

\code{var_nm} \verb{[character]} (no default)

Name of a variable.}

\item{\code{var_labeler_get}}{\emph{Description}

Get the labeler for a variable.
Set the labeler for a variable.

\emph{Usage}

\code{vm@var_labeler_get(var_nm)}

\emph{Arguments}

\code{var_nm} \verb{[character]} (no default)

Name of a variable.}

\item{\code{var_labeler_set}}{\emph{Description}

\emph{Usage}

\code{vm@var_labeler_set(var_nm, value)}

\emph{Arguments}

\code{var_nm} \verb{[character]} (no default)

Name of a variable.

\code{value} \verb{[any]} (no default)

In \verb{_set} functions the \code{value} to set for the specified metadata.}

\item{\code{var_labels_get}}{\emph{Description}

Get label for each value in \code{x} for \code{var_nm}.

\emph{Usage}

\code{vm@var_labels_get(x, var_nm, label_col_nm, labeler_env)}

\emph{Arguments}

\code{x} \verb{[any]} (no default)

Values of a specified variable.

\code{var_nm} \verb{[character]} (no default)

Name of a variable.

\code{label_col_nm} \verb{[NULL, character]} (default \code{NULL})

Name of a column in the \code{labeler} that has been assigned for the variable.
Labels will be taken from this column.
\itemize{
\item \code{NULL}: Use first column name in \code{labeler} that is not \code{"level"} --- if
\code{labeler} is a \code{data.table}.
\item \code{character}: Use this column name.
}

\code{labeler_env} \verb{[NULL, environment]} (default \code{NULL})

Environment where \code{labeler} of class \code{call} is evaluated.
\itemize{
\item \code{NULL}: Use the environment where this function is called.
\item \code{environment}: Use this environment.
}}

\item{\code{var_value_space_sample}}{\emph{Description}

Calls \code{vm@var_set_value_space_sample} with \code{var_nms = var_nm}.
Output is always a vector.

\emph{Usage}

\code{vm@var_value_space_sample(var_nm, env, n)}

\emph{Arguments}

\code{var_nm} \verb{[character]} (no default)

Name of a variable.

\code{env} \verb{[NULL, }env\verb{ironment]} (default \code{NULL})

Environment where a value space will be evaluated, if applicable.
\itemize{
\item \code{NULL}: Use the \code{env}ironment where the function was called.
\item \code{env}ironment\verb{: Use this }env`ironment.
}

\code{n} \verb{[integer]} (default \code{1L})

Number of random samples to take.}

\item{\code{vame_copy}}{\emph{Description}

Take a deep copy of a VariableMetadata object. See \code{?data.table::copy}.

\emph{Usage}

\code{vm@vame_copy()}}

\item{\code{vame_subset}}{\emph{Description}

Subset whole \code{VariableMetadata} object. Subset either \code{var_dt} or
\code{var_set_dt} (or both) and keep only metadata for variables that appear in
both \code{var_dt} and \code{var_set_dt}.

\emph{Usage}

\code{vm@vame_subset(var_dt_expr, var_set_dt_expr)}

\emph{Arguments}

\code{var_dt_expr} \verb{[NULL, logical, integer]} (default \code{NULL})

An R expression that should evaluate into \code{NULL}, \code{logical}, or \code{integer}.
The latter two are used to subset \code{var_dt}. \code{NULL} implies no subset.

\code{var_set_dt_expr} \verb{[NULL, logical, integer]} (default \code{NULL})

An R expression that should evaluate into \code{NULL}, \code{logical}, or \code{integer}.
The latter two are used to subset \code{var_set_dt_expr}. \code{NULL} implies no
subset.}

\item{\code{vame_union_append}}{\emph{Description}

Append new data into \code{VariableMetadata} object from another.
No pre-existing data are overwritten.

\emph{Usage}

\code{vm@vame_union_append(vm_2)}

\emph{Arguments}

\code{vm_2} \verb{[VariableMetadata]} (no default)

\code{VariableMetadata} object whose metadata will be appended to the current
\code{VariableMetadata} object.}

\item{\code{vame_category_space_dt_list}}{\emph{Description}

Get list of category space \code{data.table} objects.

\emph{Usage}

\code{vm@vame_category_space_dt_list(var_nms, env)}

\emph{Arguments}

\code{var_nms} \verb{[NULL, character]} (default \code{NULL})
\itemize{
\item \code{NULL}: Get the value space for all variables in the set.
\item \code{character}: Get the value spaces for only these variables.
}

\code{env} \verb{[NULL, }env\verb{ironment]} (default \code{NULL})

Environment where a value space will be evaluated, if applicable.
\itemize{
\item \code{NULL}: Use the \code{env}ironment where the function was called.
\item \code{env}ironment\verb{: Use this }env`ironment.
}}

\item{\code{vame_category_space_dt}}{\emph{Description}

Get a category space \code{data.table}.

\emph{Usage}

\code{vm@vame_category_space_dt(var_nms, env)}

\emph{Arguments}

\code{var_nms} \verb{[NULL, character]} (default \code{NULL})
\itemize{
\item \code{NULL}: Get the value space for all variables in the set.
\item \code{character}: Get the value spaces for only these variables.
}

\code{env} \verb{[NULL, }env\verb{ironment]} (default \code{NULL})

Environment where a value space will be evaluated, if applicable.
\itemize{
\item \code{NULL}: Use the \code{env}ironment where the function was called.
\item \code{env}ironment\verb{: Use this }env`ironment.
}}
}}

\section{Features}{

\strong{Value spaces}

The value spaces feature allows you to define what values (combinations of)
variables can have. This information can then be retrieved from one single
place (the \code{VariableMetadata} object) for use elsewhere, e.g. for computing
something by strata. See also the category spaces and assertions features.

The value spaces feature becomes available when \code{var_set_dt} contains column
\code{value_space}. You can include it when \code{VariableMetadata} is constructed
or you can use \code{vm@var_set_value_space_set} later.

\code{var_set_dt$value_space} must be a list column.
A \code{value_space} for a variable set must be named list of length one or
\code{NULL}. Therefore \code{var_set_dt$value_space} is a list, in turn containing
lists of length one or \code{NULL} values.
The following element names are allowed and determine the type of the
\code{value_space}: c("dt", "set", "expr", "fun", "unrestricted", "regex", "bounds").

The \code{value_space} element must be \code{NULL} or one of the following:
\itemize{
\item \code{"dt"}: A \code{data.table}. The column names must be the same as those
in the variable set. This can be used to define the (joint) value
space of one or more variables.
E.g. \code{list(dt = data.table::CJ(a = 1:2, b = 3:4))}.
\item \code{"set"}: A vector of any kinds of values. Only allowed for a variable
set containing exactly one variable.
E.g. \code{list(set = 1:2)}.
\item \code{"expr"}: An unevaluated R expression.
This can be used to define the (joint) value
space of one or more variables. What to do with the result of the
expression is deduced from the type of the result --- e.g. a
\code{data.table} result will be handled in the same manner as if the
\code{value_space} had been of type \code{dt}. This can be useful for making use
of functions to define the value space:
E.g. \code{list(expr = quote(my_fun()))}.
\item \code{"fun"}: A function.
The idea is the same as \code{expr}, but assigning a function as the
value space is less safe: The function's enclosing environment may
not be what was intended if a \code{VariableMetadata} object is read from
disk.
E.g. \code{list(fun = my_fun)}.
\item \code{"unrestricted"}: A list with named element \code{class_set}.
Sometimes a variable has no restrictions besides its class.
String variables can often have any value.
E.g. \code{list(unrestricted = list(class_set = "character"))}.
\item \code{"regex"}: A character string regular expression.
Some string variables are known in advance to always match a specific
regular expression.
E.g. \code{list(regex = "^C[0-9.]+$")}.
\item \code{"bounds"}: A list defining the upper and lower bounds.
You can define upper and lower limits for one variable with this
approach.
E.g. \code{list(bounds = list(lo = 0.0, hi = 1.0, lo_inclusive = FALSE, hi_inclusive = TRUE))}
}

The following functions are related to this feature:
\itemize{
\item \code{vm@var_set_value_space_eval}
\item \code{vm@var_set_value_space_get}
\item \code{vm@var_set_value_space_set}
\item \code{vm@var_set_value_space_dt_subset}
\item \code{vm@var_value_space_eval}
}

\strong{Random sampling}

The random sampling feature is available when the value spaces feature
is available.

Random sampling is performed as follows:
\itemize{
\item \code{vm@var_set_value_space_eval} is called for the appropriate value space
\item The appropriate sampler is retrieved --- this is either the corresponding
sampler stored in \code{var_set_dt$sampler}, or no sampler exists there,
one of the defaults depending on the type of the value space:
\itemize{
\item \code{dt}: Sample uniformly rows from \code{data.table} with replacement.
\item \code{set}: Sample uniformly from set with replacement.
\item \code{expr} & \code{fun}: Handling depends on the type of output: A vector
output is handled as a \code{set} and a \code{data.table} output as a \code{dt}.
\item \code{unrestricted}: If \code{class_set = "character"}, sample random strings
of length 16 using character pool \code{c(letters, LETTERS, 0:9)}. If
\code{class_set} is anything else, raise an error because no sampler is
defined for the general case.
\item \code{regex}: Raise error because no sampler defined.
\item \code{bounds}: Sample uniformly between \code{lo} and \code{hi} --- with
replacement for integer-valued bounds.
}
\item The sampler is called or evaluated, which results in the random samples,
and these are returned.
}

The following functions are related to this feature:
\itemize{
\item \code{vm@var_set_value_space_sampler_get}
\item \code{vm@var_set_value_space_sampler_set}
\item \code{vm@var_set_value_space_sample}
\item \code{vm@var_value_space_sample}
}

\strong{Assertions}

The assertions feature allows you to check that variables look like what
you expect. This feature relies on the value spaces feature --- see that
for more information.

The following functions are related to this feature:
\itemize{
\item \code{vm@var_assert}
}

\strong{Labeling}

The labeling feature becomes available if
the \code{var_dt} of a \code{VariableMetadata} object has a \code{labeler} column value
for a variable. You can include \code{labeler} in \code{var_dt} when the
\code{VariableMetadata} object is constructed or use \code{vm@var_labeler_set} later.

\code{var_dt$labeler} must be a list column.
A \code{labeler} for a variable can be one of these:
\itemize{
\item A function with arguments named \code{x} and \code{label_col_nm}.
\item A \code{data.table} with column \code{level} and label columns --- you decide
their names. For labels in different languages it is recommended to use
ISO language codes as column names, e.g. "en".
\item An R expression object of class \code{call}.
The expression must contain the variables \code{x} and \code{label_col_nm}.
}

The following functions are related to this feature:
\itemize{
\item \code{vm@var_labeler_get}
\item \code{vm@var_labeler_set}
\item \code{vm@var_labels_get}
}

\strong{Category spaces}

The category spaces feature becomes available when the value spaces feature
is available and when
the \code{var_dt} of a \code{VariableMetadata} object has a \code{type} column, with
value \code{"categorical"} for at least one variable.
This features differs from the value spaces feature by being more specific
and being able to produce one (large) \code{data.table} of allowed variable
value combinations.

\code{var_dt$type} must be a character string vector. Missing values are
allowed.

This feature relies on the value spaces feature. See the documentation
for that feature for more information.

The following functions are part of this feature:
\itemize{
\item \code{vm@var_is_aggregateable_to}
\item \code{vm@var_aggregate}
\item \code{vm@vame_category_space_dt_list}
\item \code{vm@vame_category_space_dt}
}
}

\section{News for version 0.2.2}{


New function \code{vm@var_meta_is_defined}.`

\code{vm@var_meta_set} now wraps \code{value} into a list if it isn't a list
and if the target column is a list.

Fix renaming multiple variables on one go.

New function \code{vm@var_set_meta_is_defined}.`

\code{vm@var_set_meta_set} now wraps \code{value} into a list if it isn't a list
and if the target column is a list.

New slot function \code{var_set_value_space_sample}.

New slot function \code{var_set_value_space_sampler_get}.

New slot function \code{var_set_value_space_sampler_set}.

New function \code{vm@var_value_space_sample}.`
}

\section{News for version 0.2.1}{


A \code{labeler} can now also be of class \code{call}.

\code{vm@var_labels_get} now can handle \code{labeler}s of class \code{call}.
Added argument \code{labeler_env} for this purpose.
}

\section{News for version 0.2.0}{


Rename \code{expr} to \code{var_dt_expr}. Add arg \code{var_set_dt_expr}.

Rename \code{x} to \code{vm_2}.

A \code{labeler} can now be of type \code{function} in addition to \code{data.table}.

\code{vm@var_labels_get} now can handle \code{labeler}s of type \code{function}.

\code{vm@var_meta_get_all} now always sets \code{var_dt$var_nm} as the names
of the output list or vector.

Rename \code{old} to \code{old_var_nms} and \code{new} to \code{new_var_nms}.

\code{vm@var_set_meta_get_all} now always sets \code{var_set_dt$id} as the names
of the output list or vector.

Rename \code{old} to \code{old_ids} and \code{new} to \code{new_ids}.

Rename \code{vm@var_set_get} to \code{vm@var_set_var_nm_set_get}.

Rename \code{vm@var_set_list_get} to \code{vm@var_set_var_nm_set_get_all}.

New function \code{vm@var_set_var_nm_set_set}.
}

\section{News for version 0.1.9}{


\code{vm@var_remove} can now remove multiple variables in one go.

\code{vame::var_set_value_space_eval} + \code{vm@var_set_value_space_eval} gain
arg \code{var_nms}. You can now evaluate the value space for only a subset of
the variables in the set.
}

\section{News for version 0.1.8}{


New slot fun \code{vm@vame_copy} + new exported fun \code{vame::vame_copy}.
}

\section{News for version 0.1.7}{


New \code{value_space} type: "unrestricted". Use this when a variable must
be of a certain class but can take any value. E.g.
\code{list(unrestricted = list(class_set = c("IDate", "Date")))}.

New \code{value_space} type: "regex". Use this when all values of a variable
must match a specific regex. E.g. \code{list(regex = "^[a-z]$")}.

New exported fun \code{vame::var_set_value_space_eval} --- alternative for
\code{vm@var_set_value_space_eval}.
}

\section{News for version 0.1.6}{


fix \code{vame_union_append} --- no longer attempt to remove duplicates
in rbind'd \code{var_dt} because some \code{by} columns may be of type \code{list}
which is not supported by \code{duplicated}.
}

\section{News for version 0.1.5}{


Robustify \code{vame_union_append} --- use \verb{use.names = TRUE, fill = TRUE}
in \code{rbind} calls.
}

\section{News for version 0.1.4}{


Fixed \code{vame_union_append} --- used to always raise an error due to
a misnamed object.
}

\section{News for version 0.1.3}{


New slot \code{var_aggregate}.

\code{vm@var_assert} gains arg \code{env}. This is passed
to \code{vm@var_value_space_eval}.

New slot \code{var_is_aggregateable_to}.
}

\section{News for version 0.1.2}{


Also \code{bounds} value space can be used when creating category spaces.

Also \code{bounds} value space can be used when creating category spaces.

Added arguments \code{x_nm}, \code{call}.
}

\section{News for version 0.1.1}{


Fixed \code{var_assert} handling of a value space based on \code{bounds}.

New slot \code{vm@var_set_value_space_eval}.

New slot \code{vm@var_value_space_eval}.
}

\section{News for version 0.1.0}{


First release.
}

\examples{
# vame::VariableMetadata ----------------------------------------------------

# basic example of different kinds of variables
value_space_d <- function() 1:3 * 100L
vm <- vame::VariableMetadata(
  var_dt = data.table::data.table(
    var_nm = c("a", "b", "c", "d", "e", "f", "g", "h"),
    type = c("categorical", "categorical",
             "categorical",
             "my_type_1", "my_type_2", "my_type_3", "my_type_4", "my_type_5")
  ),
  var_set_dt = data.table::data.table(
    id = c("ab", "c", "d", "e", "f", "g", "h"),
    var_nm_set = list(
      ab = c("a", "b"),
      c = "c", d = "d", e = "e", f = "f", g = "g", h = "h"),
    value_space = list(
      ab = list(dt = data.table::data.table(
        a = c(1L, 2L, 2L),
        b = c(11L, 21L, 22L)
      )),
      c = list(set = c("a", "b")),
      d = list(expr = quote(value_space_d())),
      e = list(bounds = list(
        lo = 0.0, hi = 10.0,
        lo_inclusive = TRUE, hi_inclusive = TRUE
      )),
      f = list(bounds = list(
        lo = as.Date("1901-01-01"), hi = as.Date("2023-12-31"),
        lo_inclusive = TRUE, hi_inclusive = TRUE
      )),
      g = list(unrestricted = list(class_set = c("IDate", "Date"))),
      h = list(regex = "^[a-z]$")
    )
  )
)
vm@var_assert(1L, var_nm = "a")
vm@var_assert(21L, var_nm = "b")
vm@var_assert("a", var_nm = "c")
vm@var_assert(100L, var_nm = "d")
vm@var_assert(c(0.0, 10.0), var_nm = "e")
vm@var_assert(as.Date("1901-01-01"), var_nm = "f")
vm@var_assert(data.table::as.IDate("1901-01-01"), var_nm = "g")
vm@var_assert(letters, var_nm = "h")
my_fun <- function(e_values) {
  vm@var_assert(e_values, var_nm = "e")
  e_values + 1
}
my_fun(0.0)

# assignment after creating a VariableMetadata object
vm@var_meta_set(var_nm = "f", meta_nm = "type", value = "my_date")
stopifnot(
  vm@var_meta_get(var_nm = "f", meta_nm = "type") == "my_date"
)
vm@var_set_value_space_set(id = "c", value_space = list(set = c("x", "z")))
stopifnot(
  identical(vm@var_set_value_space_get(id = "c"), list(set = c("x", "z")))
)

# renaming, removing variables
vm <- vame::VariableMetadata(
  var_dt = data.table::data.table(
    var_nm = c("a", "b", "c"),
    flavour = c("tasty", "rancid", "bitter")
  ),
  var_set_dt = data.table::data.table(
    id = "set_01",
    var_nm_set = list(c("a", "b")),
    value_space = list(list(dt = data.table::data.table(
      a = 1:2,
      b = 3:4
    )))
  )
)

vm@var_rename("a", "A")
stopifnot(
  identical(vm@var_meta_get("A", "flavour"), "tasty"),
  identical(names(vm@var_set_value_space_get("set_01")[["dt"]]), c("A", "b")),
  identical(vm@var_set_meta_get("set_01", "var_nm_set"), c("A", "b"))
)

vm@var_set_rename("set_01", "Ab")
stopifnot(
  identical(vm@var_set_meta_get_all("id"), c("Ab" = "Ab"))
)

vm@var_remove("b")
stopifnot(
  identical(names(vm@var_set_value_space_get("Ab")[["dt"]]), "A"),
  identical(vm@var_set_meta_get("Ab", "var_nm_set"), "A")
)

vm@var_set_remove("Ab")
stopifnot(
  identical(length(vm@var_set_meta_get_all("var_nm_set")), 0L)
)

# retrieving category space data.tables
dt_01 <- data.table::CJ(a = 1:3, b = 3:1, c = 1:3)
dt_02 <- data.table::CJ(d = 1:2, e = 2:1)
vm <- vame::VariableMetadata(
  var_dt = data.table::data.table(
    var_nm = c("a", "b", "c", "d", "e", "f"),
    type = "categorical"
  ),
  var_set_dt = data.table::data.table(
    id = c("abc", "de", "f"),
    var_nm_set = list(
      abc = c("a", "b", "c"),
      de = c("d", "e"),
      f = "f"
     ),
    value_space = list(
      abc = list(dt = dt_01),
      de = list(expr = quote({
        dt_02[
          i = !duplicated(dt_02, by = var_nms),
          j = .SD,
          .SDcols = var_nms
        ]
      })),
      f = list(bounds = list(
        lo = 0L, hi = 10L,
        lo_inclusive = TRUE, hi_inclusive = TRUE
      ))
    )
  )
)

stopifnot(
  all.equal(
    vm@vame_category_space_dt(c("a", "b")),
    dt_01[
      i = !duplicated(dt_01, by = c("a", "b")),
      j = .SD,
      .SDcols = c("a", "b")
    ],
    check.attributes = FALSE
  ),
  all.equal(
    vm@vame_category_space_dt(c("d", "e")),
    dt_02,
    check.attributes = FALSE
  ),
  all.equal(
    vm@vame_category_space_dt(c("a", "f")),
    data.table::CJ(a = 1:3, f = 0:10),
    check.attributes = FALSE
  )
)

# getting category space data.tables --- here a variable appears in
# two different value spaces. this can be handy for defining joint value
# spaces and also conversions & aggregations.
dt_01 <- data.table::CJ(a = 1:3, b = 3:1, c = 1:3)
dt_02 <- data.table::CJ(a = 0:1, e = 2:1)
dt_03 <- data.table::data.table(a = 0:3, a_2 = c(1L,1L, 2L,2L))
vm <- vame::VariableMetadata(
  var_dt = data.table::data.table(
    var_nm = c("a", "b", "c", "e", "a_2"),
    type = "categorical"
  ),
  var_set_dt = data.table::data.table(
    id = c("set_01", "set_02", "set_03"),
    var_nm_set = list(c("a", "b", "c"), c("a", "e"), c("a", "a_2")),
    value_space = list(
      list(dt = dt_01),
      list(dt = dt_02),
      list(dt = dt_03)
    )
  )
)

obs <- vm@vame_category_space_dt(c("a", "b", "e"))
exp <- data.table::data.table(
  a = c(0L, 0L, 1L, 1L, 1L, 1L, 1L, 1L, 2L, 2L, 2L, 3L, 3L, 3L),
  b = c(NA, NA, 1L, 1L, 2L, 2L, 3L, 3L, 1L, 2L, 3L, 1L, 2L, 3L),
  e = c(1L, 2L, 1L, 2L, 1L, 2L, 1L, 2L, NA, NA, NA, NA, NA, NA)
)
data.table::setkeyv(obs, names(obs))
data.table::setkeyv(exp, names(exp))
stopifnot(
  all.equal(obs, exp, check.attributes = FALSE)
)

stopifnot(
  vm@var_is_aggregateable_to("a", "a_2"),
  identical(vm@var_aggregate(0:1, "a", "a_2"), c(1L,1L))
)

# getting labels for variable levels
dt_01 <- data.table::CJ(a = 1:3, b = 3:1, c = 4:5)
vm <- vame::VariableMetadata(
  var_dt = data.table::data.table(
    var_nm = c("a", "b", "c"),
    type = "categorical",
    labeler = list(
      a = data.table::data.table(
        level = 1:3,
        en = paste0("a_level_", 1:3)
      ),
      b = quote({
        dt <- data.table::data.table(
          level = 1:3,
          en = paste0("b_level_", 1:3)
        )
        dt[[label_col_nm]][match(x, dt[["level"]])]
      }),
      c = NULL
    )
  ),
  var_set_dt = data.table::data.table(
    id = c("set_01"),
    var_nm_set = list(c("a", "b", "c")),
    value_space = list(
      list(dt = dt_01)
    )
  )
)

obs <- vm@var_labels_get(x = 1:4, var_nm = "a", label_col_nm = "en")
exp <- c(paste0("a_level_", 1:3), NA)
stopifnot(
  identical(obs, exp)
)

obs <- tryCatch(
  vm@var_labels_get(
    x = 1:4,
    var_nm = "a",
    label_col_nm = "this does not exist"
  ),
  error = function(e) e[["message"]]
)
exp <- paste0(
  "label_col_nm = \"this does not exist\"",
  " not one of the defined label columns: \"en\""
)
stopifnot(
  grepl(exp, obs)
)

obs <- tryCatch(
  vm@var_labels_get(
    x = 1:4,
    var_nm = "c",
    label_col_nm = "en"
  ),
  error = function(e) e[["message"]]
)
exp <- "Variable \"c\" has no labeler defined"
stopifnot(
  grepl(exp, obs)
)

# adding data to a pre-existing VariableMetadata object
vm_1 <- vame::VariableMetadata(
  var_dt = data.table::data.table(
    var_nm = c("a", "b"),
    type = "categorical",
    labeler = list(
      a = data.table::data.table(level = 1:2, label = c("a_1", "a_2")),
      b = NULL
    )
  ),
  var_set_dt = data.table::data.table(
    id = "ab",
    var_nm_set = list(ab = c("a", "b")),
    value_space = list(ab = list(dt = data.table::CJ(a = 1:2, b = 3:4)))
  )
)
# note that vm_2 var_dt does not have columns "type", "labeler" --- those
# will be NA / NULL for "c" and "d".
vm_2 <- vame::VariableMetadata(
  var_dt = data.table::data.table(var_nm = c("c", "d")),
  var_set_dt = data.table::data.table(
    id = "cd",
    var_nm_set = list(cd = c("c", "d")),
    value_space = list(cd = list(dt = data.table::CJ(c = 5:6, d = 7:8)))
  )
)
vm_1@vame_union_append(vm_2)
stopifnot(
  c("ab", "cd") \%in\% vm_1@var_set_meta_get_all("id")
)

# taking a copy of a VariableMetadata object
vm_3 <- vm_2@vame_copy()
vm_2@var_rename("d", "dd")
stopifnot(
  "d" \%in\% vm_3@var_meta_get_all("var_nm"),
  !"d" \%in\% vm_2@var_meta_get_all("var_nm"),
  "dd" \%in\% vm_2@var_meta_get_all("var_nm")
)

# random sampling
vm <- vame::VariableMetadata(
  var_dt = data.table::data.table(
    var_nm = c("a", "d", "b", "c"),
    type = c("categorical", "categorical", "categorical", "my_type")
  ),
  var_set_dt = data.table::data.table(
    id = c("ad", "b", "c"),
    var_nm_set = list(ad = c("a", "d"), b = "b", c = "c"),
    value_space = list(
      ad = list(dt = data.table::CJ(a = 1:2, d = 3:4)),
      b = list(set = 3:4),
      c = list(bounds = list(
        lo = 0.0,
        hi = 2.0,
        lo_inclusive = TRUE,
        hi_inclusive = TRUE
      ))
    ),
    sampler = list(
      ad = NULL,
      b = quote({
        p <- c(0.25, 0.75)
        sample(x[["set"]], size = n, replace = TRUE, p = p)
      }),
      c = NULL
    )
  )
)
vm@var_set_value_space_sampler_set(
  id = "c",
  value = quote({
    pool <- runif(min = x[["bounds"]][["lo"]], max = x[["bounds"]][["hi"]],
                  n = n * 100)
    p <- dnorm(x = pool, mean = 1.0)
    sample(pool, size = n, replace = FALSE, prob = p)
  })
)

ad_sample <- vm@var_set_value_space_sample(id = "ad", n = 4L)
a_sample <- vm@var_set_value_space_sample(id = "ad", var_nms = "a", n = 4L)
b_sample <- vm@var_set_value_space_sample(id = "b", n = 4L)
c_sample <- vm@var_set_value_space_sample(id = "c", n = 4L)
stopifnot(
  inherits(ad_sample, "data.table"),
  nrow(ad_sample) == 4,
  inherits(a_sample, "data.table"),
  nrow(a_sample) == 4,
  is.integer(b_sample),
  length(b_sample) == 4,
  is.double(c_sample),
  length(c_sample) == 4
)

a_sample <- vm@var_value_space_sample(var_nm = "a", n = 4L)
stopifnot(
  is.integer(a_sample),
  length(a_sample) == 4
)

}
