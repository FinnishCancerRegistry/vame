% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/10_S4.R
\docType{class}
\name{VariableMetadata-class}
\alias{VariableMetadata-class}
\alias{VariableMetadata}
\title{Variable Metadata}
\usage{
VariableMetadata(var_dt, var_set_dt, vame_list = NULL)
}
\arguments{
\item{var_dt}{\verb{[data.table]}

Contains information for individual variables. Must contain at a minimum
column \code{var_nm}.

See \strong{Details} and \strong{Features} for more information.}

\item{var_set_dt}{\verb{[data.table]}

Contains information for sets of variables --- e.g. a common value space.
Must contain at a minimum columns
\itemize{
\item \code{id} \verb{[integer, character]}: Identifies each set of variable names. E.g.
\code{c("my_set_01", "my_set_02")} or \code{1:2}.
\item \code{var_nm_set} \verb{[list]}: Each list element contains a character string
vector of variable names. e.g. \code{list(c("a", "b"))}.
}

See \strong{Details} and \strong{Features} for more information.}

\item{vame_list}{\verb{[NULL, list]} (default \code{NULL})

A list of metadata concerning the whole \code{VariableMetadata} object.
Its elements can be anything you want.
E.g. \code{vame_list = list(dataset_version = "1.0.0")}.}
}
\description{
Create and make use of a \code{VariableMetadata} object. It contains
\itemize{
\item \code{var_dt}: A hidden \code{data.table} containing metadata for variables,
\item \code{var_set_dt}: Hidden metadata for variable sets,
\item \code{vame_list}: A hidden list of metadata for the \code{VariableMetadata} object
itself,
\item A number of functions in S4 slots for making use of the hidden metadata
via e.g. \code{vm@var_assert} where \code{vm} is the \code{VariableMetadata} object.
}

A \code{VariableMetadata} object is created via calling the
\code{vame::VariableMetadata} function.
See section \strong{Features} for what you can do with \code{VariableMetadata}
objects.
}
\details{
\code{var_dt}:

\code{var_dt} is recommended to contain at least some sort of description for
each variable. See the describing feature.
\code{var_set_dt}:

It is recommended that \code{var_set_dt} contains as small variable sets as
possible. This includes even hierarchical variables such as area variables.
The guideline should be to have separate variable sets unless
variables in a set MUST be defined together. A \code{var_set_dt}
that contains only, or almost only, variable sets with one variable in
each is a good \code{var_set_dt}. This has the following benefits:
\itemize{
\item It is a clear rule.
\item It promotes writing smaller wholes of code, e.g. smaller functions.
\item No chance of regret when you realise that you defined something too large.
The opposite kind of regret is more rare. So the total probability of
regret is minimised.
If there really comes a case where formerly separate definitions belong
together (e.g. combining two \code{value_space}s), that is safer than
splitting: Imagine you have used \code{vm@var_set_value_space_eval} in your
code. If the variable set is split, your code may break. If it enlarges,
it less likely breaks.
}

The downside is that your \code{vame::VariableMetadata} object is more complex,
but we hide the complexity anyway by making the data only accessible with
the slot functions.

Variables that depend on each other can be visualised as a DAG where an
arrow points from a parent variable to its child, i.e. a variable that is
created using its parent. For instance, in \code{exit_date -> exit_year},
\code{exit_year} is defined using \code{exit_date}. It can be helpful to think of
a the \code{var_set_dt} as an implementation of such a graph --- and we want the
graph to show all the dependencies as arrows, not to hide dependencies
inside nodes.
}
\section{Slots}{

\describe{
\item{\code{var_set_dt_copy}}{\emph{Description}

Returns a deep copy of \code{var_set_dt_copy}.

\emph{Usage}

\code{vm@var_set_dt_copy()}}

\item{\code{var_set_meta_is_defined}}{\emph{Description}

Returns \code{TRUE} if \code{var_set_dt[[meta_nm]]} has a value for a particular
\code{id}. Unless \code{id = NULL}, then \code{vm@var_set_meta_is_defined}
checks whether that column exists at all in \code{var_set_dt}.

\emph{Usage}

\code{vm@var_set_meta_is_defined(id, meta_nm)}

\emph{Arguments}

id \verb{[any]} (no default)

ID, or "name", of a variable set. The class of \code{id} is defined when you
create the \code{VariableMetadata} object and it can be pretty much anything.

meta_nm \verb{[character]} (no default)

Name of a metadata column in \code{var_set_dt} or \code{var_dt} (depending on context)
of a \code{VariableMetadata} object.}

\item{\code{var_set_meta_get}}{\emph{Description}

Get metadata for a specific variable set.

\emph{Usage}

\code{vm@var_set_meta_get(id, meta_nm)}

\emph{Arguments}

id \verb{[any]} (no default)

ID, or "name", of a variable set. The class of \code{id} is defined when you
create the \code{VariableMetadata} object and it can be pretty much anything.

meta_nm \verb{[character]} (no default)

Name of a metadata column in \code{var_set_dt} or \code{var_dt} (depending on context)
of a \code{VariableMetadata} object.}

\item{\code{var_set_meta_set}}{\emph{Description}

Set metadata for a specific variable set.
\code{value} is wrapped inside a \code{list} if \code{var_set_dt[[meta_nm]]} is a \code{list}
or if \code{meta_nm \%in\% c("value_space", "maker")}. This is necessary for
correct assignment into a \code{list}-valued column.

\emph{Usage}

\code{vm@var_set_meta_set(id, meta_nm, value)}

\emph{Arguments}

id \verb{[any]} (no default)

ID, or "name", of a variable set. The class of \code{id} is defined when you
create the \code{VariableMetadata} object and it can be pretty much anything.

meta_nm \verb{[character]} (no default)

Name of a metadata column in \code{var_set_dt} or \code{var_dt} (depending on context)
of a \code{VariableMetadata} object.

value \verb{[any]} (no default)

In \verb{_set} functions the value to set for the specified metadata.

\emph{Examples}

\if{html}{\out{<div class="sourceCode">}}\preformatted{vm <- vame::VariableMetadata(
  var_dt = data.table::data.table(
    var_nm = "a"
  ),
  var_set_dt = data.table::data.table(
    id = "A",
    var_nm_set = list("a")
  )
)
a_value_space <- list(set = 1:3)
vm@var_set_meta_set(
  id = "A",
  meta_nm = "value_space",
  value = a_value_space
)
stopifnot(
  identical(vm@var_set_value_space_get(id = "A"), a_value_space)
)
}\if{html}{\out{</div>}}}

\item{\code{var_set_meta_get_all}}{\emph{Description}

Get all metadata for a specific variable set.

\emph{Usage}

\code{vm@var_set_meta_get_all(meta_nm)}

\emph{Arguments}

meta_nm \verb{[character]} (no default)

Name of a metadata column in \code{var_set_dt} or \code{var_dt} (depending on context)
of a \code{VariableMetadata} object.}

\item{\code{var_set_var_nm_set_get_all}}{\emph{Description}

Get every variable name set.

\emph{Usage}

\code{vm@var_set_var_nm_set_get_all()}}

\item{\code{var_set_var_nm_set_get}}{\emph{Description}

Get a specific variable name set.

\emph{Usage}

\code{vm@var_set_var_nm_set_get(id)}

\emph{Arguments}

id \verb{[any]} (no default)

ID, or "name", of a variable set. The class of \code{id} is defined when you
create the \code{VariableMetadata} object and it can be pretty much anything.}

\item{\code{var_set_var_nm_set_set}}{\emph{Description}

Set a new value for a specific variable name set.

\emph{Usage}

\code{vm@var_set_var_nm_set_set(id, value)}

\emph{Arguments}

id \verb{[any]} (no default)

ID, or "name", of a variable set. The class of \code{id} is defined when you
create the \code{VariableMetadata} object and it can be pretty much anything.

value \verb{[any]} (no default)

In \verb{_set} functions the value to set for the specified metadata.}

\item{\code{var_set_rename}}{\emph{Description}

Rename variable sets --- change \code{var_set_dt$id} values.

\emph{Usage}

\code{vm@var_set_rename(old_ids, new_ids)}

\emph{Arguments}

old_ids \verb{[any]} (no default)

Old variable set IDs.

new_ids \verb{[any]} (no default)

New variable set IDs.}

\item{\code{var_set_remove}}{\emph{Description}

Remove a variable set by \code{id}.

\emph{Usage}

\code{vm@var_set_remove(id)}

\emph{Arguments}

id \verb{[any]} (no default)

ID, or "name", of a variable set. The class of \code{id} is defined when you
create the \code{VariableMetadata} object and it can be pretty much anything.}

\item{\code{var_set_maker_get}}{\emph{Description}

Get specific \code{var_set_dt$maker}.

\emph{Usage}

\code{vm@var_set_maker_get(id)}

\emph{Arguments}

id \verb{[any]} (no default)

ID, or "name", of a variable set. The class of \code{id} is defined when you
create the \code{VariableMetadata} object and it can be pretty much anything.}

\item{\code{var_set_maker_set}}{\emph{Description}

Assign specific \code{var_set_dt$maker}.

\emph{Usage}

\code{vm@var_set_maker_set(id, value)}

\emph{Arguments}

id \verb{[any]} (no default)

ID, or "name", of a variable set. The class of \code{id} is defined when you
create the \code{VariableMetadata} object and it can be pretty much anything.

value \verb{[any]} (no default)

In \verb{_set} functions the value to set for the specified metadata.}

\item{\code{var_set_make}}{\emph{Description}

Call specific \code{var_set_dt$maker}.
\code{vm@var_set_make} performs the following steps:
\itemize{
\item Figures out \code{id} if missing but \code{var_nms} given and vice versa.
\item \code{data} is turned into a list of variables, \code{arg_list}.
\itemize{
\item If \code{data} is a \code{data.frame} object, it is turned into a \code{list} via
\code{as.list(data)} before use.
\item If \code{data} is a \code{list} object and contains \code{data$df}, the columns
of \code{data$df} are appended into \code{data} as list elements and
\code{data$df} is removed before use.
\item If \code{data} is \code{NULL} object, it is kept as-is.
}
\item Arg \code{var_nms} is added to \code{arg_list$var_nms}. We also add \code{arg_list$vm},
the \code{VariableMetadata} object itself, and \code{dep_var_nm_set}, the set of
dependency variables names.
\item If \code{maker} is a function, it is called with the objects from the above
list which have a corresponding argument.
\item If \code{maker} is a \code{list}, an evaluation env is created with \code{env} as its
parent. This evaluation environment is populated by the objects in the
list detailed above.
If \code{maker[["maker"]] == "aggregate"}, we use an internally defined
expression that uses \code{vm@var_aggregate}.
Else \code{maker[["maker"]]} must be an R expression. In both cases the
expression is evaluated in the evaluation environment.
\item Delete columns other than \code{var_nms} if found. E.g. if user supplied
\code{var_nms = "my_var_1"} but the \code{maker} produced a \code{data.table} with
columns \code{my_var_1} and \code{my_var_2}, remote the latter. If user supplied
\code{var_nms = NULL} then nothing is deleted.
\item The \code{data.table} resulting from the \code{maker} call is returned after
setting the \code{var_set_make_meta} attribute as a list containing the
elements \code{id}, \code{var_nms}, and \code{dep_var_nm_set}.
}

\emph{Usage}

\code{vm@var_set_make(data, id, var_nms, env)}

\emph{Arguments}

data \verb{[data.frame, data.table, list, NULL]}
\itemize{
\item \code{data.frame}/\code{data.table}: Columns contain necessary data.
\itemize{
\item If \code{data} is a \code{data.frame} object, it is turned into a \code{list} via
\code{as.list(data)} before use.
}
\item \code{list}: Individual elements and/or \code{data$df} can contain the necessary
variables.
\itemize{
\item If \code{data} is a \code{list} object and contains \code{data$df}, the columns
of \code{data$df} are appended into \code{data} as list elements and
\code{data$df} is removed before use.
}
\item \code{NULL}: No data is passed.
\itemize{
\item If \code{data} is \code{NULL} object, it is kept as-is.
}
}

id \verb{[any]} (no default)

ID, or "name", of a variable set. The class of \code{id} is defined when you
create the \code{VariableMetadata} object and it can be pretty much anything.

var_nms \verb{[NULL, character]} (default \code{NULL})
\itemize{
\item \code{NULL}: Behaviour varies. If the function has the argument \code{ids} or \code{id},
uses all variable names in those variable sets.
\item \code{character}: Use these variable names.
}

env \verb{[NULL, environment]} (default \code{NULL})

Environment where a value space will be evaluated, if applicable.
\itemize{
\item \code{NULL}: Use the environment where the function was called.
\item \code{environment}: Use this environment.
}}

\item{\code{var_set_maker_get_dep_var_nm_sets}}{\emph{Description}

\emph{Usage}

\code{vm@var_set_maker_get_dep_var_nm_sets(id)}

\emph{Arguments}

id \verb{[any]} (no default)

ID, or "name", of a variable set. The class of \code{id} is defined when you
create the \code{VariableMetadata} object and it can be pretty much anything.

\emph{Examples}

\if{html}{\out{<div class="sourceCode">}}\preformatted{vm <- vame::VariableMetadata(
  var_dt = data.table::data.table(
    var_nm = c("a", "b")
  ),
  var_set_dt = data.table::data.table(
    id = c("a_set", "b_set"),
    var_nm_set = list(a_set = "a", b_set = "b"),
    maker = list(
      a_set = list(
        dep_var_nm_sets = list(
          "b",
          "c"
        ),
        maker = quote(\{
          if (identical(dep_var_nm_set, "b")) \{
            out <- b + 1L
          \} else if (identical(dep_var_nm_set, "c")) \{
            out <- c - 1L
          \}
          return(data.table::data.table(a = out)[])
        \})
      ),
      b_set = list(
        dep_var_nm_set = "b_dep",
        maker = quote(\{data.table::data.table(b = b_dep + 1L)\})
      )
    )
  )
)
stopifnot(
  identical(
    vm@var_set_maker_get_dep_var_nm_sets(id = "a_set"),
    vm@var_set_maker_get(id = "a_set")[["dep_var_nm_sets"]]
  ),
  identical(
    vm@var_set_maker_get_dep_var_nm_sets(id = "b_set"),
    list(vm@var_set_maker_get(id = "b_set")[["dep_var_nm_set"]])
  )
)
}\if{html}{\out{</div>}}}

\item{\code{vame_make}}{\emph{Description}

Call multiple \code{var_set_dt$maker}s in sequence. Performs these steps:
\itemize{
\item Calls \code{optional_steps[["on_entry"]](env = main_env)} if defined.
\code{main_env} is the local environment of the main function.
\item Calls \code{on.exit(optional_steps[["on_exit"]](env = main_env))}
if that is defined.
\item Infers \code{ids} to use if user gave \code{var_nms} but not \code{ids} and vice versa.
\item Determines order in which the \code{maker}s of \code{ids} should be called.
For instance if \code{maker} for \code{ids[1]} requires the variables
created by the \code{maker} for \code{ids[2]}, then the latter is called first.
\item Calls \code{optional_steps[["pre_lapply"]](env = main_env)} if defined.
\item For each \code{ids} element:
\itemize{
\item Calls \code{optional_steps[["lapply_on_entry"]](env = lapply_fun_env)} if
defined. \code{lapply_fun_env} is the local environment of the anonymous
function that \code{lapply} calls.
\item Calls \code{on.exit(optional_steps[["lapply_on_exit"]](env = lapply_fun_env))}
if defined.
\item Calls \code{optional_steps[["lapply_pre_var_set_make"]](env = lapply_fun_env)}
if that is defined.
\item Calls \code{vm@var_set_make}.
\item Calls \code{optional_steps[["lapply_post_var_set_make"]](env = lapply_fun_env)}
if that is defined.
\item Adds the created columns into \code{data[["df"]]}. The same object is used
in subsequent calls to \code{vm@var_set_make}.
}
\item Returns a \code{data.table} containing the columns created by the \code{maker}s,
i.e. \code{data[["df"]]} without the original columns.
The \code{vame_make_meta} attribute is set as a \code{data.table} containing the
columns \code{id}, \code{var_nms}, and \code{dep_var_nm_set} in the order of execution.
}

\emph{Usage}

\code{vm@vame_make(data, ids, var_nms, env, optional_steps, callbacks)}

\emph{Arguments}

data \verb{[data.frame, data.table, list]} (no default)
\itemize{
\item \code{data.frame}/\code{data.table}: Columns contain necessary data.
\item \code{list}: Element \code{data$df} can be a \code{data.frame}/
\code{data.table} whose columns contain necessary data.
Alternatively the list elements can contain necessary data directly,
or a combination of the two.
}

ids \verb{[NULL, vector]} (default \code{NULL})
\itemize{
\item \code{NULL}: Behaviour varies. An error is raised if this cannot be inferred.
If the function has the argument \code{var_nms}, that will be used
to infer \code{ids}.
\item \code{vector}: One or more values that can be found in \code{var_set_dt$id}.
}

var_nms \verb{[NULL, character]} (default \code{NULL})
\itemize{
\item \code{NULL}: Behaviour varies. If the function has the argument \code{ids} or \code{id},
uses all variable names in those variable sets.
\item \code{character}: Use these variable names.
}

env \verb{[NULL, environment]} (default \code{NULL})

Environment where a value space will be evaluated, if applicable.
\itemize{
\item \code{NULL}: Use the environment where the function was called.
\item \code{environment}: Use this environment.
}

optional_steps \verb{[NULL, list]} (default \code{NULL})
\itemize{
\item \code{NULL}: Function is called normally.
\item \code{list}: These functions are called during the run. See \strong{Description} /
\strong{Details}.
}

callbacks \verb{[NULL, list]} (default \code{NULL})
\itemize{
\item \code{NULL}: Function is called normally.
\item \code{list}: These functions are called during the run. See \strong{Description} /
\strong{Details}.
}}

\item{\code{var_set_value_space_eval}}{\emph{Description}

Retrieve and evaluate value space for a variable set given its \code{id}.
\itemize{
\item The variables \code{id}, \code{var_nms}, and \code{vm} are made available to
\code{value_space} objects of type \code{function} and \code{call}.
\code{vm} is the \code{vame::VariableMetadata} object itself.
\item If \code{id} (whether inferred or supplied) has no \code{value_space} defined
an error is usually raised. However, if \code{var_nms} is of length one,
and that variable has a \code{labeler} of class \code{data.table}, then
in effect \code{list(dt = labeler)} is returned (minus the label columns
themselves, and after renaming \code{labeler$x} to \code{labeler[[var_nms]]}).
\item A \code{value_space} of type \code{expr} is evaluated in a temporary evaluation
environment whose parent is set to \code{env}. The evaluation environment
is populated by the variables listed above.
\item A \code{value_space} of type \code{function} is called with the subset of the
variables listed above which are named arguments of the \code{function}.
E.g. you are allowed to have only the argument \code{var_nms} if you want.
\item The evaluation result a \code{value_space} of type \code{fun} or \code{expr} is inspected
and attempted to make into a proper \code{value_space} object.
It is recommended that the evaluation result is directly a proper
\code{value_space} object, e.g. \code{list(set = 1:3)}, but the following is also
supported based on the class of the evaluation result (here \code{tmp}):
\itemize{
\item \code{data.table} -> \code{list(dt = tmp)}
\item \code{vector} and not \code{list} -> \code{list(set = tmp)}
\item \code{list} with element named \code{lo} -> \code{list(bounds = tmp)}
\item Otherwise an error is raised.
}
\item If the \code{value_space} did not need evaluation, it is simply collected
without modification,
except a \code{value_space} of type \code{data.table} (or if evaluation produced
a \code{data.table}) is subset into the requested variables only if
the \code{data.table} contains more than the requested variables.
}

\emph{Usage}

\code{vm@var_set_value_space_eval(id, var_nms, env)}

\emph{Arguments}

id \verb{[any]} (no default)

ID, or "name", of a variable set. The class of \code{id} is defined when you
create the \code{VariableMetadata} object and it can be pretty much anything.

var_nms \verb{[NULL, character]} (default \code{NULL})
\itemize{
\item \code{NULL}: Behaviour varies. If the function has the argument \code{ids} or \code{id},
uses all variable names in those variable sets.
\item \code{character}: Use these variable names.
}

env \verb{[NULL, environment]} (default \code{NULL})

Environment where a value space will be evaluated, if applicable.
\itemize{
\item \code{NULL}: Use the environment where the function was called.
\item \code{environment}: Use this environment.
}

\emph{Examples}

\if{html}{\out{<div class="sourceCode">}}\preformatted{# vm@var_set_value_space_eval
vm <- vame::VariableMetadata(
  var_dt = data.table::data.table(
    var_nm = c("a", "b", "c")
  ),
  var_set_dt = data.table::data.table(
    id = c("a_set", "b_set", "c_set"),
    var_nm_set = list("a", "b", "c"),
    value_space = list(
      list(expr = quote(list(set = 1:3))),
      list(expr = quote(1:3)),
      list(set = 1:3)
    )
  )
)
stopifnot(
  identical(
    vm@var_set_value_space_eval(id = "a_set"),
    vm@var_set_value_space_eval(id = "b_set")
  ),
  identical(
    vm@var_set_value_space_eval(id = "a_set"),
    vm@var_set_value_space_eval(id = "c_set")
  )
)

# Since v1.6.0, a `labeler` of calss `data.table` can also be used.
vm <- vame::VariableMetadata(
  var_dt = data.table::data.table(
    var_nm = "a",
    labeler = list(data.table::data.table(x = 1:3, my_label = letters[1:3]))
  ),
  var_set_dt = data.table::data.table(
    id = "a_set",
    var_nm_set = list("a")
  )
)
stopifnot(all.equal(
  vm@var_set_value_space_eval(id = "a_set"),
  list(dt = data.table::data.table(a = 1:3)),
  check.attributes = FALSE
))
}\if{html}{\out{</div>}}}

\item{\code{var_set_value_space_get}}{\emph{Description}

Get the value space of a specific variable set without evaluting it.

\emph{Usage}

\code{vm@var_set_value_space_get(id)}

\emph{Arguments}

id \verb{[any]} (no default)

ID, or "name", of a variable set. The class of \code{id} is defined when you
create the \code{VariableMetadata} object and it can be pretty much anything.}

\item{\code{var_set_value_space_set}}{\emph{Description}

Set the value space of a specific variable set.

\emph{Usage}

\code{vm@var_set_value_space_set(id, value_space)}

\emph{Arguments}

id \verb{[any]} (no default)

ID, or "name", of a variable set. The class of \code{id} is defined when you
create the \code{VariableMetadata} object and it can be pretty much anything.

value_space \verb{[list]} (no default)

A value space to assign for the specified variable set.}

\item{\code{var_set_value_space_dt_subset}}{\emph{Description}

Take a subset of a value space dt for a variable set and set that as the value space.

\emph{Usage}

\code{vm@var_set_value_space_dt_subset(id, expr)}

\emph{Arguments}

id \verb{[any]} (no default)

ID, or "name", of a variable set. The class of \code{id} is defined when you
create the \code{VariableMetadata} object and it can be pretty much anything.

expr \verb{[any]} (no default)

Expression to subset a \code{data.table} object. Available columns depends on
context.}

\item{\code{var_set_value_space_sampler_get}}{\emph{Description}

Retrieve value space sampler for given \code{id} from \code{var_set_dt$sampler}.

\emph{Usage}

\code{vm@var_set_value_space_sampler_get(id)}

\emph{Arguments}

id \verb{[any]} (no default)

ID, or "name", of a variable set. The class of \code{id} is defined when you
create the \code{VariableMetadata} object and it can be pretty much anything.}

\item{\code{var_set_value_space_sampler_set}}{\emph{Description}

Assign value space sampler for given \code{id} in \code{var_set_dt$sampler}.

The \code{sampler} can be \code{NULL}, a \code{list}, a \code{function} or a \code{call} object.
A \code{NULL} \code{sampler}
object is considered to mean that one has not been defined.
A \code{sampler} of type \code{function} must have arguments \code{x}, \code{vs}, and
\code{n}. \code{x} is the \code{vame::VariableMetadata} object itself,
\code{vs} is the pre-evaluated \code{value_space} for the variable set,
and \code{n} the number of samples.
A \code{sampler} of type \code{list} must have elements \code{sampler$dep_var_nm_set} and
\code{sampler$sampler}. \code{sampler$dep_var_nm_set} must be a character string
vector: use this to list names of variables needed for conditional
sampling. E.g. sampling \code{y} conditional on \code{x} means you should have
\code{dep_var_nm_set = "x"}. \code{sampler$sampler} must be a \code{function} or a
\code{call} object.
A \code{sampler} of type \code{call} must contain (mention) variable \code{n} ---
see \code{?all.vars}.

See the documentation for \code{var_set_value_space_sample} to understand how
the \code{sampler} object is used.

\emph{Usage}

\code{vm@var_set_value_space_sampler_set(id, value)}

\emph{Arguments}

id \verb{[any]} (no default)

ID, or "name", of a variable set. The class of \code{id} is defined when you
create the \code{VariableMetadata} object and it can be pretty much anything.

value \verb{[any]} (no default)

In \verb{_set} functions the value to set for the specified metadata.}

\item{\code{var_set_value_space_sample}}{\emph{Description}

Take \code{n} random samples from the value space of \code{id}.

Random sampling is performed as follows:
\itemize{
\item Object \code{vs} is created by calling \code{vm@var_set_value_space_eval},
if \code{value_space} is defined for the \code{id}. Else \code{vs} will be \code{NULL}.
\item The appropriate \code{sampler} is retrieved --- this is either the
corresponding
sampler stored in \code{var_set_dt$sampler}, or if no sampler exists there,
one of the defaults depending on the type of the value space:
\itemize{
\item \code{dt}: Sample uniformly rows from \code{data.table} with replacement.
\item \code{set}: Sample uniformly from set with replacement.
\item \code{expr} & \code{fun}: Handling depends on the type of output: A vector
output is handled as a \code{set} and a \code{data.table} output as a \code{dt}.
\item \code{unrestricted}: If \code{class_set = "character"}, sample random strings
of length 16 using character pool \code{c(letters, LETTERS, 0:9)}. If
\code{class_set} is anything else, raise an error because no sampler is
defined for the general case.
\item \code{regex}: Raise error because no sampler defined.
\item \code{bounds}: Sample uniformly between \code{lo} and \code{hi} --- with
replacement from \code{lo:hi} if \code{storage.mode(lo) == "integer"}.
}
\item The following variables are collected for use by the \code{sampler}:
\itemize{
\item \code{n}: The argument
\item \code{vm}: The \code{VariableMetadata} object itself
\item \code{vs}: The evaluated \code{value_space} object (\code{NULL} if none found)
\item \code{data}: The argument after handling --- useful for conditional sampling
\item \code{id}: The argument after handling
\item \code{var_nms}: The argument after handling
\item \code{dep_var_nm_set}: only added if \code{sampler} is a \code{list} object and has
\code{sampler[["dep_var_nm_set"]]} --- this is useful for conditional
sampling
}
\item If \code{sampler} is a function, it is called with those objects in the
above variable list which are also named arguments of the function.
\item If \code{sampler} is an expression, it is evaluated in a temporary evaluation
environment which has been populated with the variables of the above
list.
\item The output of sampling is always a \code{data.table} with \code{n} rows.
}

\emph{Usage}

\code{vm@var_set_value_space_sample(id, var_nms, n, data, env)}

\emph{Arguments}

id \verb{[any]} (no default)

ID, or "name", of a variable set. The class of \code{id} is defined when you
create the \code{VariableMetadata} object and it can be pretty much anything.

var_nms \verb{[NULL, character]} (default \code{NULL})
\itemize{
\item \code{NULL}: Behaviour varies. If the function has the argument \code{ids} or \code{id},
uses all variable names in those variable sets.
\item \code{character}: Use these variable names.
}

n \verb{[integer]} (default \code{1L})

Number of random samples to take.

data \verb{[NULL, data.frame, data.table, list]} (default \code{NULL})
\itemize{
\item \code{NULL}: No data is used.
\item \code{data.frame}/\code{data.table}: These variables are used as-is.
\item \code{list}: Must by fully named. \code{list} elements are used as variables
as-is, except the optional element \code{data$df} ---
a \code{data.frame}/\code{data.table} --- is first turned into a \code{list},
and \code{data} (without \code{data$df}) and \code{data$df} are combined into one longer
\code{list}. This allows you to easily pass a \code{data.frame}/\code{data.table} and
necessary accompanying variables for settings etc.
E.g.
\code{data = list(df = data.frame(my_col_1 = 1, my_col_2 = 2), my_custom_setting = "something")}.
Of course you can also pass
\code{data = list(my_col_1 = 1, my_col_2 = 2, my_custom_setting = "something")}
directly if that is more convenient.
}

env \verb{[NULL, environment]} (default \code{NULL})

Environment where a value space will be evaluated, if applicable.
\itemize{
\item \code{NULL}: Use the environment where the function was called.
\item \code{environment}: Use this environment.
}}

\item{\code{var_is_aggregateable_to}}{\emph{Description}

Returns \code{TRUE} if \code{from_var_nm} can be aggregated into \code{to_var_nm}.

\emph{Usage}

\code{vm@var_is_aggregateable_to(from_var_nm, to_var_nm)}

\emph{Arguments}

from_var_nm \verb{[character]} (no default)

Name of a variable. Aggregation from this to another variable.

to_var_nm \verb{[character]} (no default)

Name of a variable. Aggregation to this from another variable.}

\item{\code{var_aggregate}}{\emph{Description}

Returns correspoding level of \code{to_var_nm} for each value in \code{x}.

\emph{Usage}

\code{vm@var_aggregate(x, from_var_nm, to_var_nm)}

\emph{Arguments}

x \verb{[any]} (no default)

Values of a specified variable.

from_var_nm \verb{[character]} (no default)

Name of a variable. Aggregation from this to another variable.

to_var_nm \verb{[character]} (no default)

Name of a variable. Aggregation to this from another variable.}

\item{\code{var_value_space_eval}}{\emph{Description}

Get and evaluate value space for a variable.
This gets tricky when a variable has been defined in more than one
\code{var_set_dt$value_space}. If there is a single \code{var_set_dt$value_space}
for only the variable of interest, that is used. Otherwise:
\itemize{
\item Every value space for the variable is evaluated via
\code{vm@var_set_value_space_eval}. If the exact same value space has been
produced multiple times, duplicates are removed.
\item If we now have only one value space, all is well and that is returned.
\item If the \code{var_dt$type == "categorical"} for this variable, the union of
all separate value spaces is formed and that will be returned.
\item In other cases an error is raised because there does not seem to be
any way to decide which value space to use.
}

\emph{Usage}

\code{vm@var_value_space_eval(var_nm, env)}

\emph{Arguments}

var_nm \verb{[character]} (no default)

Name of a variable.

env \verb{[NULL, environment]} (default \code{NULL})

Environment where a value space will be evaluated, if applicable.
\itemize{
\item \code{NULL}: Use the environment where the function was called.
\item \code{environment}: Use this environment.
}}

\item{\code{var_assert}}{\emph{Description}

Assert that values in \code{x} are proper values of \code{var_nm}.

\emph{Usage}

\code{vm@var_assert(x, var_nm, x_nm, call, assertion_type, env)}

\emph{Arguments}

x \verb{[any]} (no default)

Values of a specified variable.

var_nm \verb{[character]} (no default)

Name of a variable.

x_nm \verb{[NULL, character]} (default \code{NULL})

See \link[dbc:argument_handlers]{dbc::handle_arg_x_nm}.

call \verb{[NULL, language]} (default \code{NULL})

See \link[dbc:argument_handlers]{dbc::handle_arg_call}.

assertion_type \verb{[NULL, character]} (default \code{NULL})

See \link[dbc:assertion_types]{dbc::handle_arg_assertion_type}.

env \verb{[NULL, environment]} (default \code{NULL})

Environment where a value space will be evaluated, if applicable.
\itemize{
\item \code{NULL}: Use the environment where the function was called.
\item \code{environment}: Use this environment.
}}

\item{\code{var_dt_copy}}{\emph{Description}

Returns a deep copy of \code{var_dt}.

\emph{Usage}

\code{vm@var_dt_copy()}}

\item{\code{var_meta_is_defined}}{\emph{Description}

Returns \code{TRUE} if \code{var_dt[[meta_nm]]} exists for a particular \code{var_nm}.
Unless \code{var_nm = NULL}, then \code{vm@var_meta_is_defined} checks whether that
column exists in \code{var_dt} at all.

\emph{Usage}

\code{vm@var_meta_is_defined(var_nm, meta_nm)}

\emph{Arguments}

var_nm \verb{[character]} (no default)

Name of a variable.

meta_nm \verb{[character]} (no default)

Name of a metadata column in \code{var_set_dt} or \code{var_dt} (depending on context)
of a \code{VariableMetadata} object.}

\item{\code{var_meta_get}}{\emph{Description}

Get metadata for a variable.

\emph{Usage}

\code{vm@var_meta_get(var_nm, meta_nm)}

\emph{Arguments}

var_nm \verb{[character]} (no default)

Name of a variable.

meta_nm \verb{[character]} (no default)

Name of a metadata column in \code{var_set_dt} or \code{var_dt} (depending on context)
of a \code{VariableMetadata} object.}

\item{\code{var_meta_set}}{\emph{Description}

Set metadata for a variable.
\code{value} is wrapped inside a \code{list} if \code{var_dt[[meta_nm]]} is a \code{list}
or if \code{meta_nm \%in\% c("describer", "labeler")}. This is necessary for
correct assignment into a \code{list}-valued column.

\emph{Usage}

\code{vm@var_meta_set(var_nm, meta_nm, value)}

\emph{Arguments}

var_nm \verb{[character]} (no default)

Name of a variable.

meta_nm \verb{[character]} (no default)

Name of a metadata column in \code{var_set_dt} or \code{var_dt} (depending on context)
of a \code{VariableMetadata} object.

value \verb{[any]} (no default)

In \verb{_set} functions the value to set for the specified metadata.

\emph{Examples}

\if{html}{\out{<div class="sourceCode">}}\preformatted{# vm@var_meta_set
vm <- vame::VariableMetadata(
  var_dt = data.table::data.table(
    var_nm = "a"
  ),
  var_set_dt = data.table::data.table(
    id = "A",
    var_nm_set = list("a")
  )
)
a_type <- "this is type for a"
vm@var_meta_set(
  var_nm = "a",
  meta_nm = "type",
  value = a_type
)
a_describer <- list(descr = "this is description for a")
vm@var_meta_set(
  var_nm = "a",
  meta_nm = "describer",
  value = a_describer
)
stopifnot(
  identical(
    vm@var_meta_get(var_nm = "a", meta_nm = "type"),
    a_type
  ),
  identical(
    vm@var_meta_get(var_nm = "a", meta_nm = "describer"),
    a_describer
  )
)
}\if{html}{\out{</div>}}}

\item{\code{var_meta_get_all}}{\emph{Description}

Get metadata for all variables.

\emph{Usage}

\code{vm@var_meta_get_all(meta_nm)}

\emph{Arguments}

meta_nm \verb{[character]} (no default)

Name of a metadata column in \code{var_set_dt} or \code{var_dt} (depending on context)
of a \code{VariableMetadata} object.}

\item{\code{var_rename}}{\emph{Description}

Rename variables. The name is changed in the following places:
\itemize{
\item \code{var_dt$var_nm}
\item \code{var_set_dt$value_space}, if the \code{value_space} object is of type \code{dt}.
If the \code{value_space} is of type \code{expr} or \code{fun}, \code{vm@var_rename} emits
a warning because it does not attempt to alter R expressions or
functions --- you will have to do that youself.
\item \code{var_set_dt$var_nm_set}
}

\emph{Usage}

\code{vm@var_rename(old_var_nms, new_var_nms)}

\emph{Arguments}

old_var_nms \verb{[character]} (no default)

Variable names to change.

new_var_nms \verb{[character]} (no default)

Variable names to change to.}

\item{\code{var_remove}}{\emph{Description}

Remove a variable.

\emph{Usage}

\code{vm@var_remove(var_nm)}

\emph{Arguments}

var_nm \verb{[character]} (no default)

Name of a variable.}

\item{\code{var_labeler_get}}{\emph{Description}

Get the labeler for a variable.
Set the labeler for a variable.

\emph{Usage}

\code{vm@var_labeler_get(var_nm)}

\emph{Arguments}

var_nm \verb{[character]} (no default)

Name of a variable.}

\item{\code{var_labeler_set}}{\emph{Description}

\emph{Usage}

\code{vm@var_labeler_set(var_nm, value)}

\emph{Arguments}

var_nm \verb{[character]} (no default)

Name of a variable.

value \verb{[any]} (no default)

In \verb{_set} functions the value to set for the specified metadata.}

\item{\code{var_labels_get}}{\emph{Description}

Get label for each value in \code{x} for \code{var_nm}.
\itemize{
\item A \code{labeler} of type \code{function} or \code{call} has  variables
\code{x}, \code{label_nm}, \code{var_nm}, and \code{vm} available. \code{vm} is the
\code{vame::VariableMetadata} object itself.
\item A \code{labeler} of type \code{function} is called with a subset of the
the variables listed above which are arguments of the function.
I.e. your function is allowed to use only some of the variables
as input arguments such as \code{x} and \code{label_nm} only if you want.
\item A \code{labeler} of type \code{call} is evaluated in a temporary evaluation
environment that contains the variables listed above. The parent of this
evaluation environment is set to \code{labeler_env}.
\item If \code{labeler} is a \code{data.table}, we get a label for each \code{x} using a
left join on the \code{data.table}.
}

\emph{Usage}

\code{vm@var_labels_get(x, var_nm, label_nm, labeler_env)}

\emph{Arguments}

x \verb{[any]} (no default)

Values of a specified variable.

var_nm \verb{[character]} (no default)

Name of a variable.

label_nm \verb{[NULL, character]} (default \code{NULL})

Name of a column in the \code{labeler} that has been assigned for the variable.
Labels will be taken from this column.
\itemize{
\item \code{NULL}: Use first column name in \code{labeler} that is not \code{"x"} --- if
\code{labeler} is a \code{data.table}.
\item \code{character}: Use this column name.
}

labeler_env \verb{[NULL, environment]} (default \code{NULL})

Environment where \code{labeler} of class \code{call} is evaluated.
\itemize{
\item \code{NULL}: Use the environment where this function is called.
\item \code{environment}: Use this environment.
}}

\item{\code{var_describer_get}}{\emph{Description}

Get the describer for a variable.
Set the describer for a variable.

\emph{Usage}

\code{vm@var_describer_get(var_nm)}

\emph{Arguments}

var_nm \verb{[character]} (no default)

Name of a variable.}

\item{\code{var_describer_set}}{\emph{Description}

\emph{Usage}

\code{vm@var_describer_set(var_nm, value)}

\emph{Arguments}

var_nm \verb{[character]} (no default)

Name of a variable.

value \verb{[any]} (no default)

In \verb{_set} functions the value to set for the specified metadata.}

\item{\code{var_description_get}}{\emph{Description}

Get description for \code{var_nm}.
\itemize{
\item A \code{describer} of type \code{function} or \code{call} has  variables
\code{var_nm}, \code{descr_nm}, and \code{vm} available. \code{vm} is the
\code{vame::VariableMetadata} object itself.
\item A \code{describer} of type \code{function} is called with a subset of the
the variables listed above which are arguments of the function.
I.e. your function is allowed to use only some of the variables
as input arguments such as \code{descr_nm} only if you want.
\item A \code{describer} of type \code{call} is evaluated in a temporary evaluation
environment that has \code{describer_env} as its parent. The evaluation
environment is populated by the variables listed above.
\item If \code{describer} is a \code{list}, we simply take the appropriate element from
the list.
}

\emph{Usage}

\code{vm@var_description_get(var_nm, descr_nm, describer_env)}

\emph{Arguments}

var_nm \verb{[character]} (no default)

Name of a variable.

descr_nm \verb{[NULL, character]} (default \code{NULL})

Name of a description in the \code{describer} that has been assigned for the
variable.
\itemize{
\item \code{NULL}: If \code{describer} is a \code{list}, use first element.
Else raises an error.
\item \code{character}: Use this description name.
}

describer_env \verb{[NULL, environment]} (default \code{NULL})

Parent environment of evaluation environment where \code{describer} of class
\code{call} is evaluated.
\itemize{
\item \code{NULL}: Use the environment where this function is called.
\item \code{environment}: Use this environment.
}}

\item{\code{var_value_space_sample}}{\emph{Description}

Wrapper for \code{vm@var_set_value_space_sample} for when you want a random
sample for only one variable.

\emph{Usage}

\code{vm@var_value_space_sample(var_nm, env, n)}

\emph{Arguments}

var_nm \verb{[character]} (no default)

Name of a variable.

env \verb{[NULL, environment]} (default \code{NULL})

Environment where a value space will be evaluated, if applicable.
\itemize{
\item \code{NULL}: Use the environment where the function was called.
\item \code{environment}: Use this environment.
}

n \verb{[integer]} (default \code{1L})

Number of random samples to take.}

\item{\code{var_var_set_dt_pos_set_get}}{\emph{Description}

Retrieve positions (indices) of where \code{var_nm} is part of
\code{var_set_dt$var_nm_set}.

\emph{Usage}

\code{vm@var_var_set_dt_pos_set_get(var_nm)}

\emph{Arguments}

var_nm \verb{[character]} (no default)

Name of a variable.}

\item{\code{var_var_set_dt_id_set_get}}{\emph{Description}

Retrieve \code{var_set_dt$id} values of where \code{var_nm} is part of
\code{var_set_dt$var_nm_set}.

\emph{Usage}

\code{vm@var_var_set_dt_id_set_get(var_nm)}

\emph{Arguments}

var_nm \verb{[character]} (no default)

Name of a variable.}

\item{\code{vame_harmonise_dt}}{\emph{Description}

Recode (via \code{maker} calls) and rename columns. Requires
\code{var_dt$is_harmonised} to be defined. The \code{maker}s of those variables
which have \code{is_harmonised == TRUE} determine which variables harmonise
into the harmonised forms. See \strong{Examples}.

\emph{Usage}

\code{vm@vame_harmonise_dt(dt, var_nms, inplace)}

\emph{Arguments}

dt \verb{[data.table]}

\code{data.table} object to harmonise.

var_nms \verb{[NULL, character]} (default \code{NULL})
\itemize{
\item \code{NULL}: Try to harmonise all columns of \code{dt}.
\item \code{character}: Harmonise these only and raise an error this fails.
A named vector, e.g. \code{c(old = "new")}, forces a specific replacement
of old with new regardless of \code{var_dt$is_harmonised}. Mandatory in
(rare) instances where one variable can be harmonised into multiple
variables that have \code{var_dt$is_harmonised} value \code{TRUE}.
}

inplace \verb{[logical]} (default \code{FALSE})

If \code{FALSE}, a copy of \code{dt} is taken. If \code{FALSE}, \code{dt} is modified in-place
without taking a copy.

\emph{Examples}

\if{html}{\out{<div class="sourceCode">}}\preformatted{# vm@vame_harmonise_dt
vm <- vame::VariableMetadata(
  var_dt = data.table::data.table(
    var_nm = c("a1", "a2", "official|A"),
    is_harmonised = c(FALSE, FALSE, TRUE)
  ),
  var_set_dt = data.table::data.table(
    id = c("a1", "a2", "official|A"),
    var_nm_set = list("a1", "a2", "official|A"),
    maker = list(
      NULL,
      NULL,
      list(
        dep_var_nm_sets = list("a1", "a2"),
        maker = quote(\{
          switch(
            intersect(c("a1", "a2"), ls())[1],
            a1 = data.table::data.table("official|A" = a1 + 1L),
            a2 = data.table::data.table("official|A" = a2 + 2L)
          )
        \})
      )
    )
  )
)

my_dt_1 <- data.table::data.table(
  a1 = 1:2,
  some_var = runif(2)
)
my_dt_1 <- vm@vame_harmonise_dt(dt = my_dt_1)
my_dt_2 <- data.table::data.table(
  a2 = 1:2,
  some_var = runif(2)
)
my_dt_2 <- vm@vame_harmonise_dt(dt = my_dt_2)
my_dt_3 <- data.table::data.table(
  a1 = 1:2,
  some_var = runif(2)
)
vm@vame_harmonise_dt(dt = my_dt_3, inplace = TRUE)

stopifnot(
  !"a1" \%in\% names(my_dt_1),
  identical(names(my_dt_1), c("official|A", "some_var")),
  my_dt_1[["official|A"]] == 2:3,

  !"a2" \%in\% names(my_dt_2),
  identical(names(my_dt_2), c("official|A", "some_var")),
  my_dt_2[["official|A"]] == 3:4,

  !"a1" \%in\% names(my_dt_3),
  identical(names(my_dt_3), c("official|A", "some_var")),
  my_dt_3[["official|A"]] == 2:3
)

# multiple harmonisation candidates
vm <- vame::VariableMetadata(
  var_dt = data.table::data.table(
    var_nm = c("a", "official|A1", "official|A2"),
    is_harmonised = c(FALSE, TRUE, TRUE)
  ),
  var_set_dt = data.table::data.table(
    id = c("a", "official|A1", "official|A2"),
    var_nm_set = list("a", "official|A1", "official|A2"),
    maker = list(
      NULL,
      list(
        dep_var_nm_set = "a",
        maker = quote(\{
          data.table::data.table("official|A1" = a + 1L)
        \})
      ),
      list(
        dep_var_nm_set = "a",
        maker = quote(\{
          data.table::data.table("official|A2" = a + 2L)
        \})
      )
    )
  )
)

my_dt_1 <- data.table::data.table(
  a = 1:2,
  some_var = runif(2)
)
# Error because of multiple harmonisation candidates --- cannot automatically
# know which one to use.
my_dt_1 <- tryCatch(
  vm@vame_harmonise_dt(dt = my_dt_1),
  error = function(e) e
)
stopifnot(
  inherits(my_dt_1, "error")
)
my_dt_1 <- data.table::data.table(
  a = 1:2,
  some_var = runif(2)
)
my_dt_2 <- data.table::copy(my_dt_1)
my_dt_1 <- vm@vame_harmonise_dt(dt = my_dt_1, var_nms = c("a" = "official|A1"))
my_dt_2 <- vm@vame_harmonise_dt(dt = my_dt_2, var_nms = c("a" = "official|A2"))

stopifnot(
  !"a" \%in\% names(my_dt_1),
  identical(names(my_dt_1), c("official|A1", "some_var")),
  my_dt_1[["official|A1"]] == 2:3,

  !"a" \%in\% names(my_dt_2),
  identical(names(my_dt_2), c("official|A2", "some_var")),
  my_dt_2[["official|A2"]] == 3:4
)
}\if{html}{\out{</div>}}}

\item{\code{vame_copy}}{\emph{Description}

Take a deep copy of a VariableMetadata object. See \code{?data.table::copy}.

\emph{Usage}

\code{vm@vame_copy()}

\emph{Examples}

\if{html}{\out{<div class="sourceCode">}}\preformatted{vm@vame_copy
vm_1 <- vame::VariableMetadata(
  var_dt = data.table::data.table(var_nm = "a"),
  var_set_dt = data.table::data.table(id = "a", var_nm_set = list("a")),
  vame_list = list(hello = "there")
)
vm_2 <- vm_1@vame_copy()
stopifnot(
  all.equal(vm_1@var_dt_copy(), vm_2@var_dt_copy()),
  all.equal(vm_1@var_set_dt_copy(), vm_2@var_set_dt_copy())
)
vm_2@var_rename("a", "b")
stopifnot(
  identical(unname(vm_1@var_meta_get_all(meta_nm = "var_nm")), "a"),
  identical(unname(vm_2@var_meta_get_all(meta_nm = "var_nm")), "b"),
  identical(vm_1@vame_list_copy(), vm_2@vame_list_copy())
)
}\if{html}{\out{</div>}}}

\item{\code{vame_subset}}{\emph{Description}

Subset whole \code{VariableMetadata} object. Subset either \code{var_dt} or
\code{var_set_dt} (or both) and keep only metadata for variables that appear in
both \code{var_dt} and \code{var_set_dt}.

\emph{Usage}

\code{vm@vame_subset(var_dt_expr, var_set_dt_expr)}

\emph{Arguments}

var_dt_expr \verb{[NULL, logical, integer]} (default \code{NULL})

An R expression that should evaluate into \code{NULL}, \code{logical}, or \code{integer}.
The latter two are used to subset \code{var_dt}. \code{NULL} implies no subset.

var_set_dt_expr \verb{[NULL, logical, integer]} (default \code{NULL})

An R expression that should evaluate into \code{NULL}, \code{logical}, or \code{integer}.
The latter two are used to subset \code{var_set_dt_expr}. \code{NULL} implies no
subset.

\emph{Examples}

\if{html}{\out{<div class="sourceCode">}}\preformatted{# vm@vame_subset
vm <- vame::VariableMetadata(
var_dt = data.table::data.table(
    var_nm = c("a", "b", "c"),
    flavour = c("tasty", "rancid", "bitter")
  ),
  var_set_dt = data.table::data.table(
    id = "set_01",
    var_nm_set = list(c("a", "b")),
    value_space = list(list(dt = data.table::data.table(
      a = 1:2,
      b = 3:4
    )))
  )
)
vm@vame_subset(var_dt_expr = var_nm == "a")
stopifnot(
  identical(unname(vm@var_meta_get_all(meta_nm = "var_nm")), "a"),
  identical(names(vm@var_set_value_space_eval("set_01")[["dt"]]), "a")
)
}\if{html}{\out{</div>}}}

\item{\code{vame_union_append}}{\emph{Description}

Append new data into \code{VariableMetadata} object from another.
No pre-existing data are overwritten. Performs the following steps:
\itemize{
\item Combine \code{var_dt} and \code{var_set_dt} from \code{vm} and \code{vm_2} with \code{rbind},
adding only new rows from \code{vm_2} metadata where \code{var_dt$var_nm} or
\code{var_set_dt$id} does not exist in \code{vm}.
\item Loop through all metadata in the \code{var_dt} of \code{vm_2} and add with
\code{vm@var_meta_set} those metadata that are not defined
(\code{vm@var_meta_set}).
\item Perform the same loop with \code{var_set_dt} metadata.
This results in \code{vm} containing new rows in its metadata tables from
\code{vm_2} and possibly new metadata even for pre-existing rows.
The function always returns \code{NULL} invisibly and the modifications are
made into \code{vm} in-place.
}

\emph{Usage}

\code{vm@vame_union_append(vm_2)}

\emph{Arguments}

vm_2 \verb{[VariableMetadata]} (no default)

\code{VariableMetadata} object whose metadata will be appended to the current
\code{VariableMetadata} object.

\emph{Examples}

\if{html}{\out{<div class="sourceCode">}}\preformatted{vm_1 <- vame::VariableMetadata(
  var_dt = data.table::data.table(
    var_nm = c("a", "b"),
    my_meta = c("vm_1_a", "vm_1_b")
  ),
  var_set_dt = data.table::data.table(
    id = "ab",
    var_nm_set = list(c("a", "b"))
  )
)
vm_2 <- vame::VariableMetadata(
  var_dt = data.table::data.table(
    var_nm = c("b", "c"),
    my_meta = c("vm_2_b", "vm_2_c")
  ),
  var_set_dt = data.table::data.table(
    id = "bc",
    var_nm_set = list(c("b", "c"))
  )
)
vm_1@vame_union_append(vm_2)
stopifnot(
  vm_1@var_meta_get(var_nm = "b", meta_nm = "my_meta") == "vm_1_b",
  vm_1@var_meta_get(var_nm = "c", meta_nm = "my_meta") == "vm_2_c"
)
}\if{html}{\out{</div>}}}

\item{\code{vame_meta_is_defined}}{\emph{Description}

Returns \code{TRUE} if \code{vame_list} has non-\code{NULL} element named \code{meta_nm}.

\emph{Usage}

\code{vm@vame_meta_is_defined(meta_nm)}

\emph{Arguments}

meta_nm \verb{[character]} (no default)

Name of a metadata column in \code{var_set_dt} or \code{var_dt} (depending on context)
of a \code{VariableMetadata} object.}

\item{\code{vame_meta_get}}{\emph{Description}

Retrieve an element of \code{vame_list}.

\emph{Usage}

\code{vm@vame_meta_get(meta_nm)}

\emph{Arguments}

meta_nm \verb{[character]} (no default)

Name of a metadata column in \code{var_set_dt} or \code{var_dt} (depending on context)
of a \code{VariableMetadata} object.}

\item{\code{vame_meta_set}}{\emph{Description}

Assign an element of \code{vame_meta_set}.

\emph{Usage}

\code{vm@vame_meta_set(meta_nm, value)}

\emph{Arguments}

meta_nm \verb{[character]} (no default)

Name of a metadata column in \code{var_set_dt} or \code{var_dt} (depending on context)
of a \code{VariableMetadata} object.

value \verb{[any]} (no default)

In \verb{_set} functions the value to set for the specified metadata.}

\item{\code{vame_value_space_sampler_get}}{\emph{Description}

Retrieve \code{meta_list$sampler}.

\emph{Usage}

\code{vm@vame_value_space_sampler_get()}}

\item{\code{vame_value_space_sampler_set}}{\emph{Description}

Assign \code{meta_list$sampler}.

The \code{sampler} can be \code{NULL}, a \code{list}, a \code{function} or a \code{call} object.
A \code{NULL} \code{sampler}
object is considered to mean that one has not been defined.
A \code{sampler} of type \code{function} must have arguments \code{x}, \code{vs}, and
\code{n}. \code{x} is the \code{vame::VariableMetadata} object itself,
\code{vs} is the pre-evaluated \code{value_space} for the variable set,
and \code{n} the number of samples.
A \code{sampler} of type \code{list} must have elements \code{sampler$dep_var_nm_set} and
\code{sampler$sampler}. \code{sampler$dep_var_nm_set} must be a character string
vector: use this to list names of variables needed for conditional
sampling. E.g. sampling \code{y} conditional on \code{x} means you should have
\code{dep_var_nm_set = "x"}. \code{sampler$sampler} must be a \code{function} or a
\code{call} object.
A \code{sampler} of type \code{call} must contain (mention) variable \code{n} ---
see \code{?all.vars}.

See the documentation for \code{vame_value_space_sample} to understand how
the \code{sampler} object is used.

\emph{Usage}

\code{vm@vame_value_space_sampler_set(value)}

\emph{Arguments}

value \verb{[any]} (no default)

In \verb{_set} functions the value to set for the specified metadata.}

\item{\code{vame_value_space_sample}}{\emph{Description}

\code{vm@var_value_space_sample} always returns a vector of length \code{n}.
If \code{vame_list$sampler} has not been set, \code{vm@vame_value_space_sample}
calls \code{vm@vame_value_space_sample_default}.
Take \code{n} random samples of the value spaces of \code{ids}.

If \code{vame_list$sampler} is a function, it is called via
\code{vame_list$sampler(x = vm, ids = ids, n = n, data = data, var_nms = var_nms)},
where \code{vm} is the pertinent \code{VariableMetadata} object itself.
If \code{vame_list$sampler} is a \code{call} object, it is evaluated in a new
environment whose parent is \code{env}. This new environment contains the
same objects that would be passed as arguments when calling
\code{vame_list$sampler} as a \code{function}.
\code{vm@vame_value_space_sample} always returns a \code{data.table} with \code{n} rows.
If \code{var_nms} was supplied, only those columns are in the output in the
given order.
Else all columns for each variable set identified by \code{ids} are present.

\emph{Usage}

\code{vm@vame_value_space_sample(ids, n, data, var_nms, env)}

\emph{Arguments}

ids \verb{[NULL, vector]} (default \code{NULL})
\itemize{
\item \code{NULL}: Behaviour varies. An error is raised if this cannot be inferred.
If the function has the argument \code{var_nms}, that will be used
to infer \code{ids}.
\item \code{vector}: One or more values that can be found in \code{var_set_dt$id}.
}

n \verb{[integer]} (default \code{1L})

Number of random samples to take.

data \verb{[NULL, data.frame, data.table, list]} (default \code{NULL})
\itemize{
\item \code{NULL}: No data is used.
\item \code{data.frame}/\code{data.table}: These variables are used as-is.
\item \code{list}: Must by fully named. \code{list} elements are used as variables
as-is, except the optional element \code{data$df} ---
a \code{data.frame}/\code{data.table} --- is first turned into a \code{list},
and \code{data} (without \code{data$df}) and \code{data$df} are combined into one longer
\code{list}. This allows you to easily pass a \code{data.frame}/\code{data.table} and
necessary accompanying variables for settings etc.
E.g.
\code{data = list(df = data.frame(my_col_1 = 1, my_col_2 = 2), my_custom_setting = "something")}.
Of course you can also pass
\code{data = list(my_col_1 = 1, my_col_2 = 2, my_custom_setting = "something")}
directly if that is more convenient.
}

var_nms \verb{[NULL, character]} (default \code{NULL})
\itemize{
\item \code{NULL}: Behaviour varies. If the function has the argument \code{ids} or \code{id},
uses all variable names in those variable sets.
\item \code{character}: Use these variable names.
}

env \verb{[NULL, environment]} (default \code{NULL})

Environment where a value space will be evaluated, if applicable.
\itemize{
\item \code{NULL}: Use the environment where the function was called.
\item \code{environment}: Use this environment.
}}

\item{\code{vame_value_space_sample_default}}{\emph{Description}

\code{vm@vame_value_space_sample_default}
calls \code{vm@var_set_value_space_sample} for every pertinent variable set
and combines the results into one large \code{data.table}.
\code{vm@vame_value_space_sample_default} always returns a \code{data.table} with \code{n}
rows.

\emph{Usage}

\code{vm@vame_value_space_sample_default(ids, env, var_nms, data, n)}

\emph{Arguments}

ids \verb{[NULL, vector]} (default \code{NULL})
\itemize{
\item \code{NULL}: Behaviour varies. An error is raised if this cannot be inferred.
If the function has the argument \code{var_nms}, that will be used
to infer \code{ids}.
\item \code{vector}: One or more values that can be found in \code{var_set_dt$id}.
}

env \verb{[NULL, environment]} (default \code{NULL})

Environment where a value space will be evaluated, if applicable.
\itemize{
\item \code{NULL}: Use the environment where the function was called.
\item \code{environment}: Use this environment.
}

var_nms \verb{[NULL, character]} (default \code{NULL})
\itemize{
\item \code{NULL}: Behaviour varies. If the function has the argument \code{ids} or \code{id},
uses all variable names in those variable sets.
\item \code{character}: Use these variable names.
}

data \verb{[NULL, data.frame, data.table, list]} (default \code{NULL})
\itemize{
\item \code{NULL}: No data is used.
\item \code{data.frame}/\code{data.table}: These variables are used as-is.
\item \code{list}: Must by fully named. \code{list} elements are used as variables
as-is, except the optional element \code{data$df} ---
a \code{data.frame}/\code{data.table} --- is first turned into a \code{list},
and \code{data} (without \code{data$df}) and \code{data$df} are combined into one longer
\code{list}. This allows you to easily pass a \code{data.frame}/\code{data.table} and
necessary accompanying variables for settings etc.
E.g.
\code{data = list(df = data.frame(my_col_1 = 1, my_col_2 = 2), my_custom_setting = "something")}.
Of course you can also pass
\code{data = list(my_col_1 = 1, my_col_2 = 2, my_custom_setting = "something")}
directly if that is more convenient.
}

n \verb{[integer]} (default \code{1L})

Number of random samples to take.}

\item{\code{vame_list_copy}}{\emph{Description}

Get a deep copy of \code{meta_list}.

\emph{Usage}

\code{vm@vame_list_copy()}}

\item{\code{vame_category_space_dt_list}}{\emph{Description}

Get list of category space \code{data.table} objects.

\emph{Usage}

\code{vm@vame_category_space_dt_list(var_nms, env)}

\emph{Arguments}

var_nms \verb{[NULL, character]} (default \code{NULL})
\itemize{
\item \code{NULL}: Behaviour varies. If the function has the argument \code{ids} or \code{id},
uses all variable names in those variable sets.
\item \code{character}: Use these variable names.
}

env \verb{[NULL, environment]} (default \code{NULL})

Environment where a value space will be evaluated, if applicable.
\itemize{
\item \code{NULL}: Use the environment where the function was called.
\item \code{environment}: Use this environment.
}}

\item{\code{vame_category_space_dt}}{\emph{Description}

Get a category space \code{data.table}.

\emph{Usage}

\code{vm@vame_category_space_dt(var_nms, env)}

\emph{Arguments}

var_nms \verb{[NULL, character]} (default \code{NULL})
\itemize{
\item \code{NULL}: Behaviour varies. If the function has the argument \code{ids} or \code{id},
uses all variable names in those variable sets.
\item \code{character}: Use these variable names.
}

env \verb{[NULL, environment]} (default \code{NULL})

Environment where a value space will be evaluated, if applicable.
\itemize{
\item \code{NULL}: Use the environment where the function was called.
\item \code{environment}: Use this environment.
}}
}}

\section{Features}{

\strong{Make}

The make feature allows for making variable sets based on other variable
sets. For instance, a year column might be "made" based on a data column,
say \code{start_year} from \code{start_date}. This feature becomes available
when one or more \code{var_set_dt$maker} objects have been defined:

The \code{maker} can be \code{NULL}, a \code{function}, or a \code{list}. A \code{NULL} \code{maker}
object is considered to mean that one has not been defined.
A \code{maker} of type \code{function} must have as arguments the invididual
required variables. Using \code{...} is not allowed to enable proper checks
on inputs when the \code{maker} is called.
A \code{maker} of type \code{list} must have element named \code{maker} and either
\code{dep_var_nm_set} of class \code{character} or \code{dep_var_nm_sets} of class \code{list},
e.g.
\code{list(maker = quote(make(x, y)), dep_var_nm_set = c("x", "y"))}
or
\code{list(maker = quote(switch(dep_var_nm_set, b = b + 1L, c = c - 1L)), dep_var_nm_sets = list("b", "c"))}
Element \code{maker} must be either a \code{call} object or simply the string
\code{"var_aggregate"}, in which case \code{dep_var_nm_set} must be of length one.
Using \code{"var_aggregate"} is a shorthand that causes calling
\code{vm@var_aggregate}. E.g.
\code{list(maker = "var_aggregate", dep_var_nm_set = "b")}.
The recommended approach to writing a \code{maker} for a variable set is to
write a function and store a call to it as the \code{maker}. See the example
for the \code{make} feature:

\if{html}{\out{<div class="sourceCode">}}\preformatted{# Example of make feature
make_dg_y <- function(
  dg_date
) \{
  out <- data.table::data.table(dg_y = data.table::year(dg_date))
  return(out[])
\}
# We do not store `my_fun` here directly because if a `VariableMetadata`
# object is written to disk, the entire enclosing env of `my_fun` is
# included. This can get very messy when it is read back into R.
# It is strongly recommended to store quoted expressions instead
# and store any functions you write somewhere else, ideally in an R package.
my_vame <- vame::VariableMetadata(
  var_dt = data.table::data.table(
    var_nm = c("dg_y", "dg_date", "area_01", "area_02", "area_03"),
    type = c("year", "date", "categorical", "categorical", "categorical")
  ),
  var_set_dt = data.table::data.table(
    id = c("dg_y", "dg_date", "area", "area_01", "area_02"),
    var_nm_set = list(
      dg_y = "dg_y",
      dg_date = "dg_date",
      area = c("area_01", "area_02", "area_03"),
      area_01 = "area_01",
      area_02 = "area_02"
    ),
    maker = list(
      dg_y = list(
        maker = quote(make_dg_y(dg_date = dg_date)),
        dep_var_nm_set = "dg_date"
      ),
      dg_date = NULL,
      area = NULL,
      area_01 = list(
        maker = quote(\{
          # This is an example of re-using data from the `VariableMetadata`
          # object itself.
          dt <- data.table::setDT(list(
            x = vm@var_aggregate(
              get(dep_var_nm_set),
              from_var_nm = dep_var_nm_set,
              to_var_nm = var_nms
            )
          ))
          data.table::setnames(dt, "x", var_nms)
          dt[]
        \}),
        dep_var_nm_set = "area_02"
      ),
      # This example uses the shorthand var_aggregate approach.
      area_02 = list(maker = "var_aggregate", dep_var_nm_set = "area_03")
    ),
    value_space = list(
      dg_y = list(set = 1953:2024),
      dg_date = list(bounds = list(
        lo = as.Date("1953-01-01"),
        hi = as.Date("2024-12-31"),
        lo_inclusive = TRUE,
        hi_inclusive = TRUE
      )),
      area = list(dt = data.table::data.table(
        area_01 = c(1L,1L,1L,2L,2L,2L),
        area_02 = c(11L,12L,12L,21L,21L,22L),
        area_03 = c(111L,121L,122L,211L,212L,221L)
      )),
      area_01 = NULL,
      area_02 = NULL
    )
  )
)
obs <- my_vame@var_set_make(
  id = "dg_y",
  data = data.table::data.table(dg_date = as.Date("2001-01-01"))
)
exp <- data.table::data.table(dg_y = 2001L)
stopifnot(identical(obs[["dg_y"]], exp[["dg_y"]]))

obs <- my_vame@var_set_make(
  id = "area_01",
  data = data.table::data.table(area_02 = c(11L, 21L))
)
exp <- data.table::data.table(area_01 = c(1L,2L))
stopifnot(identical(obs[["area_01"]], exp[["area_01"]]))

obs <- my_vame@var_set_make(
  id = "area_02",
  data = data.table::data.table(area_03 = c(111L, 211L))
)
exp <- data.table::data.table(area_02 = c(11L,21L))
stopifnot(identical(obs[["area_02"]], exp[["area_02"]]))

obs <- my_vame@vame_make(
  ids = c("dg_y", "area_02", "area_01"),
  data = data.table::data.table(
    dg_date = as.Date("2001-01-01"),
    area_03 = c(111L,121L,122L,211L,212L,221L)
  )
)
exp <- data.table::data.table(
  dg_y = 2001L,
  area_02 = my_vame@var_aggregate(
    c(111L,121L,122L,211L,212L,221L),
    from_var_nm = "area_03",
    to_var_nm = "area_02"
  )
)
exp[
  j = "area_01" := my_vame@var_aggregate(
    exp[["area_02"]],
    from_var_nm = "area_02",
    to_var_nm = "area_01"
  )
]
stopifnot(
  identical(obs[["dg_y"]], exp[["dg_y"]]),
  identical(obs[["area_01"]], exp[["area_01"]]),
  identical(obs[["area_02"]], exp[["area_02"]])
)

obs_2 <- my_vame@vame_make(
  var_nms = c("dg_y", "area_02", "area_01"),
  data = data.table::data.table(
    dg_date = as.Date("2001-01-01"),
    area_03 = c(111L,121L,122L,211L,212L,221L)
  )
)
obs_3 <- my_vame@vame_make(
  var_nms = c("dg_y", "area_02", "area_01"),
  data = list(df = data.table::data.table(
    dg_date = as.Date("2001-01-01"),
    area_03 = c(111L,121L,122L,211L,212L,221L)
  ))
)
stopifnot(
  all.equal(obs, obs_2),
  all.equal(obs, obs_3)
)

# Example with a `maker` which works on multiple different input variable sets
vm <- vame::VariableMetadata(
  var_dt = data.table::data.table(
    var_nm = "a"
  ),
  var_set_dt = data.table::data.table(
    id = "a_set",
    var_nm_set = list(a_set = "a"),
    maker = list(
      a_set = list(
        dep_var_nm_sets = list(
          "b",
          "c"
        ),
        maker = quote(\{
          if (identical(dep_var_nm_set, "b")) \{
            out <- b + 1L
          \} else if (identical(dep_var_nm_set, "c")) \{
            out <- c - 1L
          \}
          return(data.table::data.table(a = out)[])
        \})
      )
    )
  )
)
obs_b_1 <- vm@var_set_make(var_nms = "a", data = list(b = 0L))
obs_c <- vm@var_set_make(var_nms = "a", data = list(c = 2L))
obs_b_2 <- vm@vame_make(var_nms = "a", data = data.frame(b = 0L))
stopifnot(
  all.equal(obs_b_1, obs_b_2, check.attributes = FALSE),
  all.equal(obs_b_1, obs_c, check.attributes = FALSE),
  identical(
    attr(obs_b_1, "var_set_make_meta"),
    list(id = "a_set", var_nms = "a", dep_var_nm_set = "b")
  ),
  all.equal(
    attr(obs_b_2, "vame_make_meta"),
    data.table::data.table(
      id = "a_set",
      var_nms = list("a"),
      dep_var_nm_set = list("b")
    ),
    check.attributes = FALSE
  )
)

# Example where the same `maker` produces multiple columns
vm <- vame::VariableMetadata(
  var_dt = data.table::data.table(
    var_nm = c("a", "b")
  ),
  var_set_dt = data.table::data.table(
    id = "ab_set",
    var_nm_set = list(ab_set = c("a", "b")),
    maker = list(
      a_set = list(
        dep_var_nm_set = "c",
        maker = quote(\{
          dt <- data.table::data.table(
            a = c + 1L,
            b = c - 1L
          )
          return(dt[])
        \})
      )
    )
  )
)
dt <- data.table::data.table(c = 1:5)
obs_ab <- vm@var_set_make(id = "ab_set", data = dt)
obs_a <- vm@var_set_make(id = "ab_set", var_nms = "a", data = dt)
obs_b <- vm@var_set_make(id = "ab_set", var_nms = "b", data = dt)
stopifnot(
  identical(names(obs_ab), c("a", "b")),
  identical(names(obs_a), "a"),
  identical(names(obs_b), "b")
)
}\if{html}{\out{</div>}}

The following functions are related to this feature:
\itemize{
\item \code{vm@var_set_maker_get}
\item \code{vm@var_set_maker_set}
\item \code{vm@var_set_make}
\item \code{vm@vame_make}
\item \code{vm@vame_harmonise_dt}
}

\strong{Value spaces}

The value spaces feature allows you to define what values (combinations of)
variables can have. This information can then be retrieved from one single
place (the \code{VariableMetadata} object) for use elsewhere, e.g. for computing
something by strata. See also the category spaces and assertions features.

The value spaces feature becomes available when \code{var_set_dt} contains column
\code{value_space}. You can include it when \code{VariableMetadata} is constructed
or you can use \code{vm@var_set_value_space_set} later.

\code{var_set_dt$value_space} must be a list column.
A \code{value_space} for a variable set must be named list of length one or
\code{NULL}. Therefore \code{var_set_dt$value_space} is a list, in turn containing
lists of length one or \code{NULL} values.
The following element names are allowed and determine the type of the
\code{value_space}: c("dt", "set", "expr", "fun", "unrestricted", "regex", "bounds").

The \code{value_space} element must be \code{NULL} or one of the following:
\itemize{
\item \code{"dt"}: A \code{data.table}. The column names must be the same as those
in the variable set. This can be used to define the (joint) value
space of one or more variables.
E.g. \code{list(dt = data.table::CJ(a = 1:2, b = 3:4))}.
\item \code{"set"}: A vector of any kinds of values. Only allowed for a variable
set containing exactly one variable.
E.g. \code{list(set = 1:2)}.
\item \code{"expr"}: An unevaluated R expression.
This can be used to define the (joint) value
space of one or more variables. What to do with the result of the
expression is deduced from the type of the result --- e.g. a
\code{data.table} result will be handled in the same manner as if the
\code{value_space} had been of type \code{dt}. This can be useful for making use
of functions to define the value space:
E.g. \code{list(expr = quote(my_fun()))}.
\item \code{"fun"}: A function.
The idea is the same as \code{expr}, but assigning a function as the
value space is less safe: The function's enclosing environment may
not be what was intended if a \code{VariableMetadata} object is read from
disk.
E.g. \code{list(fun = my_fun)}.
\item \code{"unrestricted"}: A list with named element \code{class_set}.
Sometimes a variable has no restrictions besides its class.
String variables can often have any value.
E.g. \code{list(unrestricted = list(class_set = "character"))}.
\item \code{"regex"}: A character string regular expression.
Some string variables are known in advance to always match a specific
regular expression.
E.g. \code{list(regex = "^C[0-9.]+$")}.
\item \code{"bounds"}: A list defining the upper and lower bounds.
You can define upper and lower limits for one variable with this
approach.
E.g. \code{list(bounds = list(lo = 0.0, hi = 1.0, lo_inclusive = FALSE, hi_inclusive = TRUE))}
}

The following functions are related to this feature:
\itemize{
\item \code{vm@var_set_value_space_eval}
\item \code{vm@var_set_value_space_get}
\item \code{vm@var_set_value_space_set}
\item \code{vm@var_set_value_space_dt_subset}
\item \code{vm@var_value_space_eval}
}

\strong{Random sampling}

The random sampling feature is available when the value spaces feature
is available.

Random sampling is performed as follows:
\itemize{
\item Object \code{vs} is created by calling \code{vm@var_set_value_space_eval},
if \code{value_space} is defined for the \code{id}. Else \code{vs} will be \code{NULL}.
\item The appropriate \code{sampler} is retrieved --- this is either the
corresponding
sampler stored in \code{var_set_dt$sampler}, or if no sampler exists there,
one of the defaults depending on the type of the value space:
\itemize{
\item \code{dt}: Sample uniformly rows from \code{data.table} with replacement.
\item \code{set}: Sample uniformly from set with replacement.
\item \code{expr} & \code{fun}: Handling depends on the type of output: A vector
output is handled as a \code{set} and a \code{data.table} output as a \code{dt}.
\item \code{unrestricted}: If \code{class_set = "character"}, sample random strings
of length 16 using character pool \code{c(letters, LETTERS, 0:9)}. If
\code{class_set} is anything else, raise an error because no sampler is
defined for the general case.
\item \code{regex}: Raise error because no sampler defined.
\item \code{bounds}: Sample uniformly between \code{lo} and \code{hi} --- with
replacement from \code{lo:hi} if \code{storage.mode(lo) == "integer"}.
}
\item The following variables are collected for use by the \code{sampler}:
\itemize{
\item \code{n}: The argument
\item \code{vm}: The \code{VariableMetadata} object itself
\item \code{vs}: The evaluated \code{value_space} object (\code{NULL} if none found)
\item \code{data}: The argument after handling --- useful for conditional sampling
\item \code{id}: The argument after handling
\item \code{var_nms}: The argument after handling
\item \code{dep_var_nm_set}: only added if \code{sampler} is a \code{list} object and has
\code{sampler[["dep_var_nm_set"]]} --- this is useful for conditional
sampling
}
\item If \code{sampler} is a function, it is called with those objects in the
above variable list which are also named arguments of the function.
\item If \code{sampler} is an expression, it is evaluated in a temporary evaluation
environment which has been populated with the variables of the above
list.
\item The output of sampling is always a \code{data.table} with \code{n} rows.
}

The following functions are related to this feature:
\itemize{
\item \code{vm@var_set_value_space_sampler_get}
\item \code{vm@var_set_value_space_sampler_set}
\item \code{vm@var_set_value_space_sample}
\item \code{vm@var_value_space_sample}
\item \code{vm@vame_value_space_sampler_get}
\item \code{vm@vame_value_space_sampler_set}
\item \code{vm@vame_value_space_sample}
\item \code{vm@vame_value_space_sample_default}
}

\strong{Assertions}

The assertions feature allows you to check that variables look like what
you expect. This feature relies on the value spaces feature --- see that
for more information.

The following functions are related to this feature:
\itemize{
\item \code{vm@var_assert}
}

\strong{Labeling}

The labeling feature becomes available if
the \code{var_dt} of a \code{VariableMetadata} object has a \code{labeler} column value
for a variable. You can include \code{labeler} in \code{var_dt} when the
\code{VariableMetadata} object is constructed or use \code{vm@var_labeler_set} later.

\code{var_dt$labeler} must be a list column.
A \code{labeler} for a variable can be one of these:
\itemize{
\item A function with arguments named \code{x} and \code{label_nm}.
\item A \code{data.table} with column \code{x} and label columns --- you decide
their names. For labels in different languages it is recommended to use
ISO language codes as column names, e.g. "en".
\item An R expression object of class \code{call}.
The expression must contain the variables \code{x} and \code{label_nm}.
}

The following functions are related to this feature:
\itemize{
\item \code{vm@var_labeler_get}
\item \code{vm@var_labeler_set}
\item \code{vm@var_labels_get}
}

\strong{Describing}

The describing feature becomes available if
the \code{var_dt} of a \code{VariableMetadata} object has a \code{describer} column value
for a variable. You can include \code{describer} in \code{var_dt} when the
\code{VariableMetadata} object is constructed or use \code{vm@var_describer_set}
later.

The \code{describer} can be \code{NULL}, a \code{list}, a \code{function}, or a \code{call} object.
A \code{NULL} \code{describer} object is considered to mean that one has not been
defined.
A \code{describer} of type \code{list} must be named. Each element must be
a \code{character} string vector of length > 0. \code{NA} values are not allowed.
A \code{describer} of type \code{function} must have argument \code{descr_nm}.
A \code{describer} of type \code{call} must contain (mention) variable
\code{descr_nm}.

The following functions are related to this feature:
\itemize{
\item \code{vm@var_describer_get}
\item \code{vm@var_describer_set}
\item \code{vm@var_description_get}
}

\strong{Category spaces}

The category spaces feature becomes available when the value spaces feature
is available and when
the \code{var_dt} of a \code{VariableMetadata} object has a \code{type} column, with
value \code{"categorical"} for at least one variable.
This features differs from the value spaces feature by being more specific
and being able to produce one (large) \code{data.table} of allowed variable
value combinations.

\code{var_dt$type} must be a character string vector. Missing values are
allowed.

This feature relies on the value spaces feature. See the documentation
for that feature for more information.

The following functions are part of this feature:
\itemize{
\item \code{vm@var_is_aggregateable_to}
\item \code{vm@var_aggregate}
\item \code{vm@vame_category_space_dt_list}
\item \code{vm@vame_category_space_dt}
}
}

\section{News for version 1.9.0}{


\code{vm@vame_make} gains arg \code{optional_steps} to replace \code{callbacks}.
Using \code{callbacks} throws a warning now, an error starting in 1.10.0
and it will be removed in 1.11.0.
}

\section{News for version 1.8.0}{


\code{vm@var_set_make} now deletes all other columns except \code{var_nms} from output
if such exist. Previously the user could request for e.g.
\code{var_nms = "my_var_1"} only, but if the underlying \code{maker} was defined for
e.g. \code{c("my_var_1", "my_var_2")}, then both were included in output.
So now only \code{"my_var_1"} would be included.
}

\section{News for version 1.7.0}{


\code{vame::VariableMetadata} now raises an error if \code{var_dt$var_nm} has any
duplicates.

\code{vame::VariableMetadata} now raises an error if \code{var_set_dt$id} has any
duplicates.
}

\section{News for version 1.6.0}{


\code{vm@var_set_value_space_eval} now can make use of a \code{labeler} of class
\code{data.table} in cases where no \code{value_space} is defined for the \code{id},
but \code{var_nms} is of length one, and that variable has such a \code{labeler}.

\code{vm@var_set_value_space_eval} now also allows the evaluation result of
a \code{value_space} of type \code{expr} or \code{fun} to be a \code{value_space} object
in itself. In fact that is recommended from now on.
}

\section{News for version 1.5.0}{


New function \code{vm@vame_harmonise_dt}.

\code{vm@var_meta_is_defined} now also allows \code{var_nm = NULL}. Then it returns
\code{TRUE/FALSE} depending on whether \code{meta_nm} is a column name of \code{var_dt}.

\code{vm@var_set_meta_is_defined} now also accepts \code{id = NULL}. Then
\code{vm@var_set_meta_is_defined} tests whether \code{meta_nm} is a column name of
\code{var_set_dt}.

New function \code{vm@var_var_set_dt_id_set_get}.

New function \code{vm@var_var_set_dt_pos_set_get}.
}

\section{News for version 1.4.0}{


\code{vm@vame_union_append} now adds metadata from \code{vm_2} into \code{vm} even for
pre-existing variables where that particular metadata is missing in
\code{vm}. Previously only new variables were added and pre-existing variables'
metadata were untouched.
}

\section{News for version 1.3.1}{


\code{vm@vame_value_space_sample} arg \code{ids} auto-inference now only finds
\code{ids} which have either \code{sampler} or \code{value_space}.

\code{vm@vame_value_space_sample_default} arg \code{ids} auto-inference now only finds
\code{ids} which have either \code{sampler} or \code{value_space}.

\code{vm@var_set_value_space_sample} arg \code{id} auto-inference now only finds
one \code{id} which has either \code{sampler} or \code{value_space}.
}

\section{News for version 1.3.0}{


\code{vm@vame_make} now sets the attribute \code{vame_make_meta} on its output.

\code{vm@var_set_make} now sets attribute \code{var_set_make_meta} on its output.

New function \code{vm@var_set_maker_get_dep_var_nm_sets}.
}

\section{News for version 1.2.0}{


Rename \code{vm@vame_make} \code{callbacks} element \code{pre_loop} to \code{pre_lapply}.

\code{vm@vame_make} gains \code{callbacks} element \code{lapply_on_entry}.

\code{vm@vame_make} gains \code{callbacks} element \code{lapply_on_exit}.

\code{vm@vame_make} gains \code{callbacks} element \code{lapply_pre_var_set_make}.

Rename \code{vm@vame_make} \code{callbacks} element \code{post_var_set_make} to
\code{lapply_post_var_set_make}.

\code{vm@var_set_make} can now handle a \code{maker} of type \code{list} with element
\code{dep_var_nm_sets}.

A \code{maker} of type \code{list} can now have element \code{dep_var_nm_sets} instead
of \code{dep_var_nm_set}. \code{dep_var_nm_sets} must be a \code{list} of variable name
sets --- different allowed options. If your \code{maker} only works on one
specific set of dependency variables, it is easier for you to keep using
\code{dep_var_nm_set}. The possibility of using \code{dep_var_nm_sets} was added
to enable writing a \code{maker} such as
\code{quote(switch(dep_var_nm_set, b = b + 1L, c = c - 1L))}, where the target
variable can be made using either \code{b} or \code{c}.
}

\section{News for version 1.1.0}{


\code{vm@var_description_get} now makes variables \code{var_nm}, \code{descr_nm}, and \code{vm}
available for \code{describer} types \code{function} and \code{call}.

\code{vm@var_labels_get} now makes variables \code{x}, \code{var_nm}, \code{label_nm}, and \code{vm}
available for \code{labeler} types \code{function} and \code{call}.

\code{vm@var_set_value_space_eval} now makes variables \code{id}, \code{var_nms}, and \code{vm}
available for \code{labeler} types \code{function} and \code{call}.

\code{vm@var_set_value_space_sample} object \code{x} passed to the \code{sampler} renamed
to \code{vm}. It is the \code{VariableMetadata} object itself.
}

\section{News for version 1.0.1}{


\code{vm@vame_make} gains \code{callbacks} element \code{on_entry}.

\code{vm@vame_make} gains \code{callbacks} element \code{pre_loop}.
}

\section{News for version 1.0.0}{


\code{vm@vame_make} gains argument \code{callbacks}.
}

\section{News for version 0.5.7}{


\code{vm@var_meta_set} now always wraps \code{value} into a list before adding
it into \code{vm} when \code{meta_nm \%in\% c("describer", "labeler")} --- those are
known \code{list} columns.

\code{vm@var_set_meta_set} now always wraps \code{value} into a list before adding
it into \code{vm} when \code{meta_nm \%in\% c("value_space", "maker")} --- those are
known \code{list} columns.
}

\section{News for version 0.5.6}{


\code{vm@vame_meta_set} now checks \code{value} for validity for "officially"
defined metadata such as \code{sampler}. Formerly this was done only by
the corresponding wrapper such as \code{vm@vame_value_space_sampler_set}.

\code{vm@var_meta_set} now checks \code{value} for validity for "officially" defined
metadata such as \code{describer}. Formerly this was done only by
the corresponding wrapper such as \code{vm@var_describer_set}.

\code{vm@var_set_meta_set} now checks \code{value} for validity for "officially"
defined metadata such as \code{value_space}. Formerly this was done only by
the corresponding wrapper such as \code{vm@var_set_value_space_set}.
}

\section{News for version 0.5.5}{


\code{vm@vame_copy} now also copies \code{vame_list}.
}

\section{News for version 0.5.4}{


Fix use of \code{substitute} in turning args \code{var_dt_expr} + \code{var_set_dt_expr}
into a quoted expression.
}

\section{News for version 0.5.3}{


\code{vm@var_set_make} passing \code{var_nms} fixed. It used to pass the
\code{var_nm_set} for the corresponding variable set, now it passes arg
\code{var_nms} (whether inferred or user-given) as intended.

\code{maker} objects of type \code{function} can no longer have \code{...} in their
definition to enable proper checks on inputs when the \code{maker} is called.

\code{vm@var_set_maker_set} now ignores arguments passed via \code{data} to a
\code{maker} of type \code{function} that do not correspond to any argument name.

\code{vm@var_set_value_space_sample} arg \code{id} now \code{NULL} by default.
You can supply either \code{id} or \code{var_nms} and the other one is inferred,
if \code{NULL}.
}

\section{News for version 0.5.2}{


\code{vm@vame_make} gains argument \code{var_nms}. You can now pass either \code{ids} or
\code{var_nms} or both.

\code{vm@vame_make} automatically determines the appropriate order of \code{ids}
(whether user-supplied or inferred) in which their \code{maker}s should be
called. For instance if \code{maker} for \code{ids[1]} requires the variables
created by the \code{maker} for \code{ids[2]}, then the latter is called first.

\code{vm@var_set_make} gains argument \code{var_nms}. You can now pass either \code{id} or
\code{var_nms} or both.

\code{vm@var_set_make} now raises an informative error if \code{data} did not
contain something the \code{maker} needs.
}

\section{News for version 0.5.0}{


\code{vame::VariableMetadata} now automatically sets \code{var_dt$type} to
\code{"categorical"} where the variable's \code{value_space} is of type
\code{dt} or \code{set} or when \code{var_dt$labeler} has been defined. Remember that
this only occurs when \code{vame::VariableMetadata} is called and any
additional variables you add later will not be treated automatically.
Also, if \code{var_dt$type} was already something other than \code{NA} for a
variable, the automatic determination is not attempted.
}

\section{News for version 0.4.1}{


\code{vm@var_dt_copy} now actually returns \code{var_dt} instead of \code{var_set_dt}.

\code{vm@var_set_dt_copy} now actually returns \code{var_set_dt} instead of \code{var_dt}.
}

\section{News for version 0.4.0}{


\code{var_dt$labeler} of class \code{data.table} specs changed: Now column
containing values for the variable in question must be named \code{x}.
Formerly this was \code{level}.

Added recommendations for constructing \code{vame::VariableMetadata} objects into
documentation.

\code{vm@vame_value_space_sample} gains arguments \code{ids} and \code{data}.

\code{vm@vame_value_space_sample_default} gains arguments \code{ids} and \code{data}.

\code{vm@var_aggregate} now always considers it possible to aggregate to
\code{to_var_nm} if it only has one value.

New function \code{vm@var_describer_get}.

New function \code{vm@var_describer_set}.

New function \code{vm@var_description_get}.

\code{vm@var_description_get} arg \code{description_name} renamed to \code{descr_nm}.

\code{vm@var_labels_get} arg \code{label_col_nm} renamed to \code{label_nm}.

\code{vm@var_meta_is_defined} internal problem fixed.

\code{vm@var_set_make} argument \code{data} can now also be a \code{list} object.

\code{vm@var_set_value_space_sample} now has new arg \code{data}. Pass your data via
\code{data} when you have a conditional sampling method.
}

\section{News for version 0.3.0}{


New function \code{vm@vame_make}.

New function \code{vm@var_set_make}.

New function \code{vm@var_set_maker_get}.

New function \code{vm@var_set_maker_set}.
}

\section{News for version 0.2.2}{


\code{vame::VariableMetadata} gains arg \code{vame_list}.

New function \code{vm@vame_list_copy}.

New function \code{vm@vame_meta_get}.

New function \code{vm@vame_meta_is_defined}.

New function \code{vm@vame_meta_set}.

New function \code{vm@var_set_meta_is_defined}.

New function \code{vm@vame_value_space_sample_default}.

New function \code{vm@vame_value_space_sampler_get}.

New function \code{vm@vame_value_space_sampler_set}.

New function \code{vm@var_dt_copy}.

New function \code{vm@var_meta_is_defined}.

\code{vm@var_meta_set} now wraps \code{value} into a list if it isn't a list
and if the target column is a list.

Fix renaming multiple variables on one go.

New function \code{vm@var_set_dt_copy}.

New function \code{vm@var_set_meta_is_defined}.

\code{vm@var_set_meta_set} now wraps \code{value} into a list if it isn't a list
and if the target column is a list.

New slot function \code{var_set_value_space_sample}.

New slot function \code{var_set_value_space_sampler_get}.

New slot function \code{var_set_value_space_sampler_set}.

New function \code{vm@var_value_space_sample}.
}

\section{News for version 0.2.1}{


A \code{labeler} can now also be of class \code{call}.

\code{vm@var_labels_get} now can handle \code{labeler}s of class \code{call}.
Added argument \code{labeler_env} for this purpose.
}

\section{News for version 0.2.0}{


Rename \code{expr} to \code{var_dt_expr}. Add arg \code{var_set_dt_expr}.

Rename \code{x} to \code{vm_2}.

A \code{labeler} can now be of type \code{function} in addition to \code{data.table}.

\code{vm@var_labels_get} now can handle \code{labeler}s of type \code{function}.

\code{vm@var_meta_get_all} now always sets \code{var_dt$var_nm} as the names
of the output list or vector.

Rename \code{old} to \code{old_var_nms} and \code{new} to \code{new_var_nms}.

\code{vm@var_set_meta_get_all} now always sets \code{var_set_dt$id} as the names
of the output list or vector.

Rename \code{old} to \code{old_ids} and \code{new} to \code{new_ids}.

Rename \code{vm@var_set_get} to \code{vm@var_set_var_nm_set_get}.

Rename \code{vm@var_set_list_get} to \code{vm@var_set_var_nm_set_get_all}.

New function \code{vm@var_set_var_nm_set_set}.
}

\section{News for version 0.1.9}{


\code{vm@var_remove} can now remove multiple variables in one go.

\code{vame::var_set_value_space_eval} + \code{vm@var_set_value_space_eval} gain
arg \code{var_nms}. You can now evaluate the value space for only a subset of
the variables in the set.
}

\section{News for version 0.1.8}{


New slot fun \code{vm@vame_copy} + new exported fun \code{vame::vame_copy}.
}

\section{News for version 0.1.7}{


New \code{value_space} type: "unrestricted". Use this when a variable must
be of a certain class but can take any value. E.g.
\code{list(unrestricted = list(class_set = c("IDate", "Date")))}.

New \code{value_space} type: "regex". Use this when all values of a variable
must match a specific regex. E.g. \code{list(regex = "^[a-z]$")}.

New exported fun \code{vame::var_set_value_space_eval} --- alternative for
\code{vm@var_set_value_space_eval}.
}

\section{News for version 0.1.6}{


fix \code{vame_union_append} --- no longer attempt to remove duplicates
in rbind'd \code{var_dt} because some \code{by} columns may be of type \code{list}
which is not supported by \code{duplicated}.
}

\section{News for version 0.1.5}{


Robustify \code{vame_union_append} --- use \verb{use.names = TRUE, fill = TRUE}
in \code{rbind} calls.
}

\section{News for version 0.1.4}{


Fixed \code{vame_union_append} --- used to always raise an error due to
a misnamed object.
}

\section{News for version 0.1.3}{


New slot \code{var_aggregate}.

\code{vm@var_assert} gains arg \code{env}. This is passed
to \code{vm@var_value_space_eval}.

New slot \code{var_is_aggregateable_to}.
}

\section{News for version 0.1.2}{


Also \code{bounds} value space can be used when creating category spaces.

Also \code{bounds} value space can be used when creating category spaces.

Added arguments \code{x_nm}, \code{call}.
}

\section{News for version 0.1.1}{


Fixed \code{var_assert} handling of a value space based on \code{bounds}.

New slot \code{vm@var_set_value_space_eval}.

New slot \code{vm@var_value_space_eval}.
}

\section{News for version 0.1.0}{


First release.
}

\examples{
# vame::VariableMetadata ----------------------------------------------------

# basic example of different kinds of variables
value_space_d <- function() 1:3 * 100L
vm <- vame::VariableMetadata(
  var_dt = data.table::data.table(
    var_nm = c("a", "b", "c", "d", "e", "f", "g", "h"),
    type = c("categorical", "categorical",
             "categorical",
             "my_type_1", "my_type_2", "my_type_3", "my_type_4", "my_type_5")
  ),
  var_set_dt = data.table::data.table(
    id = c("ab", "c", "d", "e", "f", "g", "h"),
    var_nm_set = list(
      ab = c("a", "b"),
      c = "c", d = "d", e = "e", f = "f", g = "g", h = "h"),
    value_space = list(
      ab = list(dt = data.table::data.table(
        a = c(1L, 2L, 2L),
        b = c(11L, 21L, 22L)
      )),
      c = list(set = c("a", "b")),
      d = list(expr = quote(value_space_d())),
      e = list(bounds = list(
        lo = 0.0, hi = 10.0,
        lo_inclusive = TRUE, hi_inclusive = TRUE
      )),
      f = list(bounds = list(
        lo = as.Date("1901-01-01"), hi = as.Date("2023-12-31"),
        lo_inclusive = TRUE, hi_inclusive = TRUE
      )),
      g = list(unrestricted = list(class_set = c("IDate", "Date"))),
      h = list(regex = "^[a-z]$")
    )
  )
)
vm@var_assert(1L, var_nm = "a")
vm@var_assert(21L, var_nm = "b")
vm@var_assert("a", var_nm = "c")
vm@var_assert(100L, var_nm = "d")
vm@var_assert(c(0.0, 10.0), var_nm = "e")
vm@var_assert(as.Date("1901-01-01"), var_nm = "f")
vm@var_assert(data.table::as.IDate("1901-01-01"), var_nm = "g")
vm@var_assert(letters, var_nm = "h")
my_fun <- function(e_values) {
  vm@var_assert(e_values, var_nm = "e")
  e_values + 1
}
my_fun(0.0)

# assignment after creating a VariableMetadata object
vm@var_meta_set(var_nm = "f", meta_nm = "type", value = "my_date")
stopifnot(
  vm@var_meta_get(var_nm = "f", meta_nm = "type") == "my_date"
)
vm@var_set_value_space_set(id = "c", value_space = list(set = c("x", "z")))
stopifnot(
  identical(vm@var_set_value_space_get(id = "c"), list(set = c("x", "z")))
)

# renaming, removing variables
vm <- vame::VariableMetadata(
  var_dt = data.table::data.table(
    var_nm = c("a", "b", "c"),
    flavour = c("tasty", "rancid", "bitter")
  ),
  var_set_dt = data.table::data.table(
    id = "set_01",
    var_nm_set = list(c("a", "b")),
    value_space = list(list(dt = data.table::data.table(
      a = 1:2,
      b = 3:4
    )))
  )
)

vm@var_rename("a", "A")
stopifnot(
  identical(vm@var_meta_get("A", "flavour"), "tasty"),
  identical(names(vm@var_set_value_space_get("set_01")[["dt"]]), c("A", "b")),
  identical(vm@var_set_meta_get("set_01", "var_nm_set"), c("A", "b"))
)

vm@var_set_rename("set_01", "Ab")
stopifnot(
  identical(vm@var_set_meta_get_all("id"), c("Ab" = "Ab"))
)

vm@var_remove("b")
stopifnot(
  identical(names(vm@var_set_value_space_get("Ab")[["dt"]]), "A"),
  identical(vm@var_set_meta_get("Ab", "var_nm_set"), "A")
)

vm@var_set_remove("Ab")
stopifnot(
  identical(length(vm@var_set_meta_get_all("var_nm_set")), 0L)
)

# retrieving category space data.tables
dt_01 <- data.table::CJ(a = 1:3, b = 3:1, c = 1:3)
dt_02 <- data.table::CJ(d = 1:2, e = 2:1)
vm <- vame::VariableMetadata(
  var_dt = data.table::data.table(
    var_nm = c("a", "b", "c", "d", "e", "f"),
    type = "categorical"
  ),
  var_set_dt = data.table::data.table(
    id = c("abc", "de", "f"),
    var_nm_set = list(
      abc = c("a", "b", "c"),
      de = c("d", "e"),
      f = "f"
     ),
    value_space = list(
      abc = list(dt = dt_01),
      de = list(expr = quote({
        dt_02[
          i = !duplicated(dt_02, by = var_nms),
          j = .SD,
          .SDcols = var_nms
        ]
      })),
      f = list(bounds = list(
        lo = 0L, hi = 10L,
        lo_inclusive = TRUE, hi_inclusive = TRUE
      ))
    )
  )
)

stopifnot(
  all.equal(
    vm@vame_category_space_dt(c("a", "b")),
    dt_01[
      i = !duplicated(dt_01, by = c("a", "b")),
      j = .SD,
      .SDcols = c("a", "b")
    ],
    check.attributes = FALSE
  ),
  all.equal(
    vm@vame_category_space_dt(c("d", "e")),
    dt_02,
    check.attributes = FALSE
  ),
  all.equal(
    vm@vame_category_space_dt(c("a", "f")),
    data.table::CJ(a = 1:3, f = 0:10),
    check.attributes = FALSE
  )
)

# getting category space data.tables --- here a variable appears in
# two different value spaces. this can be handy for defining joint value
# spaces and also conversions & aggregations.
dt_01 <- data.table::CJ(a = 1:3, b = 3:1, c = 1:3)
dt_02 <- data.table::CJ(a = 0:1, e = 2:1)
dt_03 <- data.table::data.table(a = 0:3, a_2 = c(1L,1L, 2L,2L))
vm <- vame::VariableMetadata(
  var_dt = data.table::data.table(
    var_nm = c("a", "b", "c", "e", "a_2"),
    type = "categorical"
  ),
  var_set_dt = data.table::data.table(
    id = c("set_01", "set_02", "set_03"),
    var_nm_set = list(c("a", "b", "c"), c("a", "e"), c("a", "a_2")),
    value_space = list(
      list(dt = dt_01),
      list(dt = dt_02),
      list(dt = dt_03)
    )
  )
)

obs <- vm@vame_category_space_dt(c("a", "b", "e"))
exp <- data.table::data.table(
  a = c(0L, 0L, 1L, 1L, 1L, 1L, 1L, 1L, 2L, 2L, 2L, 3L, 3L, 3L),
  b = c(NA, NA, 1L, 1L, 2L, 2L, 3L, 3L, 1L, 2L, 3L, 1L, 2L, 3L),
  e = c(1L, 2L, 1L, 2L, 1L, 2L, 1L, 2L, NA, NA, NA, NA, NA, NA)
)
data.table::setkeyv(obs, names(obs))
data.table::setkeyv(exp, names(exp))
stopifnot(
  all.equal(obs, exp, check.attributes = FALSE)
)

stopifnot(
  vm@var_is_aggregateable_to("a", "a_2"),
  identical(vm@var_aggregate(0:1, "a", "a_2"), c(1L,1L))
)

# getting labels for variable levels
dt_01 <- data.table::CJ(a = 1:3, b = 3:1, c = 4:5)
vm <- vame::VariableMetadata(
  var_dt = data.table::data.table(
    var_nm = c("a", "b", "c"),
    type = "categorical",
    labeler = list(
      a = data.table::data.table(
        x = 1:3,
        en = paste0("a_level_", 1:3)
      ),
      b = quote({
        dt <- data.table::data.table(
          x = 1:3,
          en = paste0("b_level_", 1:3)
        )
        dt[[label_nm]][match(x, dt[["x"]])]
      }),
      c = NULL
    )
  ),
  var_set_dt = data.table::data.table(
    id = c("set_01"),
    var_nm_set = list(c("a", "b", "c")),
    value_space = list(
      list(dt = dt_01)
    )
  )
)

obs <- vm@var_labels_get(x = 1:4, var_nm = "a", label_nm = "en")
exp <- c(paste0("a_level_", 1:3), NA)
stopifnot(
  identical(obs, exp)
)

obs <- tryCatch(
  vm@var_labels_get(
    x = 1:4,
    var_nm = "a",
    label_nm = "this does not exist"
  ),
  error = function(e) e[["message"]]
)
exp <- paste0(
  "label_nm = \"this does not exist\"",
  " not one of the defined label names: \"en\""
)
stopifnot(
  grepl(exp, obs)
)

obs <- tryCatch(
  vm@var_labels_get(
    x = 1:4,
    var_nm = "c",
    label_nm = "en"
  ),
  error = function(e) e[["message"]]
)
exp <- "Variable \"c\" has no labeler defined"
stopifnot(
  grepl(exp, obs)
)

# adding data to a pre-existing VariableMetadata object
vm_1 <- vame::VariableMetadata(
  var_dt = data.table::data.table(
    var_nm = c("a", "b"),
    type = "categorical",
    labeler = list(
      a = data.table::data.table(x = 1:2, label = c("a_1", "a_2")),
      b = NULL
    )
  ),
  var_set_dt = data.table::data.table(
    id = "ab",
    var_nm_set = list(ab = c("a", "b")),
    value_space = list(ab = list(dt = data.table::CJ(a = 1:2, b = 3:4)))
  )
)
# note that vm_2 var_dt does not have columns "type", "labeler" --- those
# will be NA / NULL for "c" and "d".
vm_2 <- vame::VariableMetadata(
  var_dt = data.table::data.table(var_nm = c("c", "d")),
  var_set_dt = data.table::data.table(
    id = "cd",
    var_nm_set = list(cd = c("c", "d")),
    value_space = list(cd = list(dt = data.table::CJ(c = 5:6, d = 7:8)))
  )
)
vm_1@vame_union_append(vm_2)
stopifnot(
  c("ab", "cd") \%in\% vm_1@var_set_meta_get_all("id")
)

# taking a copy of a VariableMetadata object
vm_3 <- vm_2@vame_copy()
vm_2@var_rename("d", "dd")
stopifnot(
  "d" \%in\% vm_3@var_meta_get_all("var_nm"),
  !"d" \%in\% vm_2@var_meta_get_all("var_nm"),
  "dd" \%in\% vm_2@var_meta_get_all("var_nm")
)

vm <- vame::VariableMetadata(
  var_dt = data.table::data.table(
    var_nm = "a"
  ),
  var_set_dt = data.table::data.table(
    id = "A",
    var_nm_set = list("a")
  )
)
a_value_space <- list(set = 1:3)
vm@var_set_meta_set(
  id = "A",
  meta_nm = "value_space",
  value = a_value_space
)
stopifnot(
  identical(vm@var_set_value_space_get(id = "A"), a_value_space)
)
# Example of make feature
make_dg_y <- function(
  dg_date
) {
  out <- data.table::data.table(dg_y = data.table::year(dg_date))
  return(out[])
}
# We do not store `my_fun` here directly because if a `VariableMetadata`
# object is written to disk, the entire enclosing env of `my_fun` is
# included. This can get very messy when it is read back into R.
# It is strongly recommended to store quoted expressions instead
# and store any functions you write somewhere else, ideally in an R package.
my_vame <- vame::VariableMetadata(
  var_dt = data.table::data.table(
    var_nm = c("dg_y", "dg_date", "area_01", "area_02", "area_03"),
    type = c("year", "date", "categorical", "categorical", "categorical")
  ),
  var_set_dt = data.table::data.table(
    id = c("dg_y", "dg_date", "area", "area_01", "area_02"),
    var_nm_set = list(
      dg_y = "dg_y",
      dg_date = "dg_date",
      area = c("area_01", "area_02", "area_03"),
      area_01 = "area_01",
      area_02 = "area_02"
    ),
    maker = list(
      dg_y = list(
        maker = quote(make_dg_y(dg_date = dg_date)),
        dep_var_nm_set = "dg_date"
      ),
      dg_date = NULL,
      area = NULL,
      area_01 = list(
        maker = quote({
          # This is an example of re-using data from the `VariableMetadata`
          # object itself.
          dt <- data.table::setDT(list(
            x = vm@var_aggregate(
              get(dep_var_nm_set),
              from_var_nm = dep_var_nm_set,
              to_var_nm = var_nms
            )
          ))
          data.table::setnames(dt, "x", var_nms)
          dt[]
        }),
        dep_var_nm_set = "area_02"
      ),
      # This example uses the shorthand var_aggregate approach.
      area_02 = list(maker = "var_aggregate", dep_var_nm_set = "area_03")
    ),
    value_space = list(
      dg_y = list(set = 1953:2024),
      dg_date = list(bounds = list(
        lo = as.Date("1953-01-01"),
        hi = as.Date("2024-12-31"),
        lo_inclusive = TRUE,
        hi_inclusive = TRUE
      )),
      area = list(dt = data.table::data.table(
        area_01 = c(1L,1L,1L,2L,2L,2L),
        area_02 = c(11L,12L,12L,21L,21L,22L),
        area_03 = c(111L,121L,122L,211L,212L,221L)
      )),
      area_01 = NULL,
      area_02 = NULL
    )
  )
)
obs <- my_vame@var_set_make(
  id = "dg_y",
  data = data.table::data.table(dg_date = as.Date("2001-01-01"))
)
exp <- data.table::data.table(dg_y = 2001L)
stopifnot(identical(obs[["dg_y"]], exp[["dg_y"]]))

obs <- my_vame@var_set_make(
  id = "area_01",
  data = data.table::data.table(area_02 = c(11L, 21L))
)
exp <- data.table::data.table(area_01 = c(1L,2L))
stopifnot(identical(obs[["area_01"]], exp[["area_01"]]))

obs <- my_vame@var_set_make(
  id = "area_02",
  data = data.table::data.table(area_03 = c(111L, 211L))
)
exp <- data.table::data.table(area_02 = c(11L,21L))
stopifnot(identical(obs[["area_02"]], exp[["area_02"]]))

obs <- my_vame@vame_make(
  ids = c("dg_y", "area_02", "area_01"),
  data = data.table::data.table(
    dg_date = as.Date("2001-01-01"),
    area_03 = c(111L,121L,122L,211L,212L,221L)
  )
)
exp <- data.table::data.table(
  dg_y = 2001L,
  area_02 = my_vame@var_aggregate(
    c(111L,121L,122L,211L,212L,221L),
    from_var_nm = "area_03",
    to_var_nm = "area_02"
  )
)
exp[
  j = "area_01" := my_vame@var_aggregate(
    exp[["area_02"]],
    from_var_nm = "area_02",
    to_var_nm = "area_01"
  )
]
stopifnot(
  identical(obs[["dg_y"]], exp[["dg_y"]]),
  identical(obs[["area_01"]], exp[["area_01"]]),
  identical(obs[["area_02"]], exp[["area_02"]])
)

obs_2 <- my_vame@vame_make(
  var_nms = c("dg_y", "area_02", "area_01"),
  data = data.table::data.table(
    dg_date = as.Date("2001-01-01"),
    area_03 = c(111L,121L,122L,211L,212L,221L)
  )
)
obs_3 <- my_vame@vame_make(
  var_nms = c("dg_y", "area_02", "area_01"),
  data = list(df = data.table::data.table(
    dg_date = as.Date("2001-01-01"),
    area_03 = c(111L,121L,122L,211L,212L,221L)
  ))
)
stopifnot(
  all.equal(obs, obs_2),
  all.equal(obs, obs_3)
)

# Example with a `maker` which works on multiple different input variable sets
vm <- vame::VariableMetadata(
  var_dt = data.table::data.table(
    var_nm = "a"
  ),
  var_set_dt = data.table::data.table(
    id = "a_set",
    var_nm_set = list(a_set = "a"),
    maker = list(
      a_set = list(
        dep_var_nm_sets = list(
          "b",
          "c"
        ),
        maker = quote({
          if (identical(dep_var_nm_set, "b")) {
            out <- b + 1L
          } else if (identical(dep_var_nm_set, "c")) {
            out <- c - 1L
          }
          return(data.table::data.table(a = out)[])
        })
      )
    )
  )
)
obs_b_1 <- vm@var_set_make(var_nms = "a", data = list(b = 0L))
obs_c <- vm@var_set_make(var_nms = "a", data = list(c = 2L))
obs_b_2 <- vm@vame_make(var_nms = "a", data = data.frame(b = 0L))
stopifnot(
  all.equal(obs_b_1, obs_b_2, check.attributes = FALSE),
  all.equal(obs_b_1, obs_c, check.attributes = FALSE),
  identical(
    attr(obs_b_1, "var_set_make_meta"),
    list(id = "a_set", var_nms = "a", dep_var_nm_set = "b")
  ),
  all.equal(
    attr(obs_b_2, "vame_make_meta"),
    data.table::data.table(
      id = "a_set",
      var_nms = list("a"),
      dep_var_nm_set = list("b")
    ),
    check.attributes = FALSE
  )
)

# Example where the same `maker` produces multiple columns
vm <- vame::VariableMetadata(
  var_dt = data.table::data.table(
    var_nm = c("a", "b")
  ),
  var_set_dt = data.table::data.table(
    id = "ab_set",
    var_nm_set = list(ab_set = c("a", "b")),
    maker = list(
      a_set = list(
        dep_var_nm_set = "c",
        maker = quote({
          dt <- data.table::data.table(
            a = c + 1L,
            b = c - 1L
          )
          return(dt[])
        })
      )
    )
  )
)
dt <- data.table::data.table(c = 1:5)
obs_ab <- vm@var_set_make(id = "ab_set", data = dt)
obs_a <- vm@var_set_make(id = "ab_set", var_nms = "a", data = dt)
obs_b <- vm@var_set_make(id = "ab_set", var_nms = "b", data = dt)
stopifnot(
  identical(names(obs_ab), c("a", "b")),
  identical(names(obs_a), "a"),
  identical(names(obs_b), "b")
)
vm <- vame::VariableMetadata(
  var_dt = data.table::data.table(
    var_nm = c("a", "b")
  ),
  var_set_dt = data.table::data.table(
    id = c("a_set", "b_set"),
    var_nm_set = list(a_set = "a", b_set = "b"),
    maker = list(
      a_set = list(
        dep_var_nm_sets = list(
          "b",
          "c"
        ),
        maker = quote({
          if (identical(dep_var_nm_set, "b")) {
            out <- b + 1L
          } else if (identical(dep_var_nm_set, "c")) {
            out <- c - 1L
          }
          return(data.table::data.table(a = out)[])
        })
      ),
      b_set = list(
        dep_var_nm_set = "b_dep",
        maker = quote({data.table::data.table(b = b_dep + 1L)})
      )
    )
  )
)
stopifnot(
  identical(
    vm@var_set_maker_get_dep_var_nm_sets(id = "a_set"),
    vm@var_set_maker_get(id = "a_set")[["dep_var_nm_sets"]]
  ),
  identical(
    vm@var_set_maker_get_dep_var_nm_sets(id = "b_set"),
    list(vm@var_set_maker_get(id = "b_set")[["dep_var_nm_set"]])
  )
)
# vm@var_set_value_space_eval
vm <- vame::VariableMetadata(
  var_dt = data.table::data.table(
    var_nm = c("a", "b", "c")
  ),
  var_set_dt = data.table::data.table(
    id = c("a_set", "b_set", "c_set"),
    var_nm_set = list("a", "b", "c"),
    value_space = list(
      list(expr = quote(list(set = 1:3))),
      list(expr = quote(1:3)),
      list(set = 1:3)
    )
  )
)
stopifnot(
  identical(
    vm@var_set_value_space_eval(id = "a_set"),
    vm@var_set_value_space_eval(id = "b_set")
  ),
  identical(
    vm@var_set_value_space_eval(id = "a_set"),
    vm@var_set_value_space_eval(id = "c_set")
  )
)

# Since v1.6.0, a `labeler` of calss `data.table` can also be used.
vm <- vame::VariableMetadata(
  var_dt = data.table::data.table(
    var_nm = "a",
    labeler = list(data.table::data.table(x = 1:3, my_label = letters[1:3]))
  ),
  var_set_dt = data.table::data.table(
    id = "a_set",
    var_nm_set = list("a")
  )
)
stopifnot(all.equal(
  vm@var_set_value_space_eval(id = "a_set"),
  list(dt = data.table::data.table(a = 1:3)),
  check.attributes = FALSE
))
# random sampling
c_lo <- as.Date("2001-01-01")
c_hi <- as.Date("2020-12-31")
## see what default samplers do with bounds
storage.mode(c_lo) <- storage.mode(c_hi) <- "integer"
vm <- vame::VariableMetadata(
  var_dt = data.table::data.table(
    var_nm = c("a", "d", "b", "c"),
    type = c("categorical", "categorical", "categorical", "my_type")
  ),
  var_set_dt = data.table::data.table(
    id = c("ad", "b", "c", "e"),
    var_nm_set = list(ad = c("a", "d"), b = "b", c = "c", e = "e"),
    value_space = list(
      ad = list(dt = data.table::CJ(a = 1:2, d = 3:4)),
      b = list(set = 3:4),
      c = list(bounds = list(
        lo = c_lo,
        hi = c_hi,
        lo_inclusive = TRUE,
        hi_inclusive = TRUE
      )),
      e = list(set = 1:2)
    ),
    sampler = list(
      ad = NULL,
      b = quote({
        p <- c(0.25, 0.75)
        out <- sample(vs[["set"]], size = n, replace = TRUE, p = p)
        out <- data.table::setDT(list(b = out))
        return(out[])
      }),
      c = NULL,
      e = quote({
        stopifnot(
          inherits(data, "list"),
          "e_cond" \%in\% names(data),
          length(data[["e_cond"]]) == n
        )
        dist <- data.table::data.table(
          e_cond = c(1L, 1L, 2L, 2L),
          e = c(1:2, 1:2),
          p_cond = c(0.25, 0.75, 0.40, 0.60)
        )
        join_dt <- data.table::setDT(list(e_cond = data[["e_cond"]]))
        out <- dist[
          i = join_dt,
          j = list(
            e = sample(.SD[["e"]], replace = TRUE, prob = .SD[["p_cond"]])
          ),
          by = .EACHI
        ]
        data.table::set(out, j = setdiff(names(out), "e"), value = NULL)
        return(out[])
      })
    )
  )
)
vm@var_set_value_space_sampler_set(
  id = "c",
  value = quote({
    pool <- vs[["bounds"]][["lo"]]:vs[["bounds"]][["hi"]]
    p <- dnorm(x = pool, mean = mean(pool), sd = 10)
    class(pool) <- class(vs[["bounds"]][["lo"]])
    out <- pool[sample(length(pool), size = n, replace = FALSE, prob = p)]
    out <- data.table::setDT(list(c = out))
    return(out[])
  })
)

ad_sample <- vm@var_set_value_space_sample(id = "ad", n = 4L)
b_sample <- vm@var_set_value_space_sample(id = "b", n = 4L)
c_sample <- vm@var_set_value_space_sample(id = "c", n = 4L)
stopifnot(
  inherits(ad_sample, "data.table"),
  nrow(ad_sample) == 4,
  inherits(b_sample, "data.table"),
  nrow(b_sample) == 4,
  inherits(c_sample, "data.table"),
  storage.mode(c_sample$c) == "integer",
  nrow(c_sample) == 4
)

vame_sample <- vm@vame_value_space_sample(
  ids = c("ad", "b", "c"),
  n = 10L
)
stopifnot(
  inherits(vame_sample, "data.table"),
  identical(c("a", "d", "b", "c"), names(vame_sample)),
  nrow(vame_sample) == 10
)

# conditional sampling
vm@var_set_value_space_sampler_set(
  id = "c",
  value = list(
    dep_var_nm_set = "a",
    sampler = quote({
      a <- data[["a"]]
      out <- data.table::data.table(c = runif(n = n, min = a - 1, max = a))
      return(out[])
    })
  )
)
c_sample_data <- list(a = 1:2)
c_sample <- vm@var_set_value_space_sample(
  id = "c",
  data = c_sample_data,
  n = 2L
)
vame_sample <- vm@vame_value_space_sample(
  ids = c("ad", "b", "c"),
  n = 10L
)
stopifnot(
  inherits(c_sample, "data.table"),
  identical("c", names(c_sample)),
  nrow(c_sample) == 2,
  c_sample[["c"]] < c_sample_data[["a"]],
  inherits(vame_sample, "data.table"),
  identical(c("a", "d", "b", "c"), names(vame_sample)),
  nrow(vame_sample) == 10,
  vame_sample[["c"]] < vame_sample[["a"]]
)

# You may sometimes want to write the `sampler` and `value_space` in
# separate variable sets for the same variable.
my_vm <- vame::VariableMetadata(
  var_dt = data.table::data.table(var_nm = c("a", "b")),
  var_set_dt = data.table::data.table(
    id = c("a_sampler", "ab_value_space"),
    var_nm_set = list("a", c("a", "b")),
    value_space = list(
      NULL,
      list(
        dt = data.table::data.table(a = 0:5)[
          j = list(b = .SD[["a"]]:5L),
          .SDcols = "a",
          keyby = "a"
        ][]
      )
    ),
    sampler = list(
      list(
        dep_var_nm_set = "b",
        sampler = quote({
          pdt <- data.table::data.table(
            a = 0:5,
            p = 0:5 + 1
          )
          n # must be used in expression, in this case not useful
          out <- vapply(
            data[["b"]],
            function(b_value) {
              pdt[
                i = pdt[["a"]] <= b_value,
                j = sample(.SD[["a"]], size = 1L, prob = .SD[["p"]]),
                .SDcols = c("a", "p")
              ]
            },
            integer(1L)
          )
          out <- data.table::setDT(list(a = out))
          return(out[])
        })
      ),
      NULL
    )
  )
)
# `sampler` is used, not a default sampler on `value_space`.
RNGversion("4.0.0")
set.seed(1337)
a_sample <- my_vm@var_set_value_space_sample(
  var_nms = "a",
  n = 1e6L,
  data = data.table::data.table(b = rep(5L, 1e6))
)
a_sample_distribution <- table(a_sample[["a"]])
stopifnot(
  a_sample_distribution[1] < a_sample_distribution[6]
)
# vm@var_meta_set
vm <- vame::VariableMetadata(
  var_dt = data.table::data.table(
    var_nm = "a"
  ),
  var_set_dt = data.table::data.table(
    id = "A",
    var_nm_set = list("a")
  )
)
a_type <- "this is type for a"
vm@var_meta_set(
  var_nm = "a",
  meta_nm = "type",
  value = a_type
)
a_describer <- list(descr = "this is description for a")
vm@var_meta_set(
  var_nm = "a",
  meta_nm = "describer",
  value = a_describer
)
stopifnot(
  identical(
    vm@var_meta_get(var_nm = "a", meta_nm = "type"),
    a_type
  ),
  identical(
    vm@var_meta_get(var_nm = "a", meta_nm = "describer"),
    a_describer
  )
)

# Example of describing feature
my_vame <- vame::VariableMetadata(
  var_dt = data.table::data.table(
    var_nm = c("sex", "birth_date"),
    describer = list(
      sex = list(
        en = "Sex assigned at birth.",
        fi = "Syntymahetken sukupuoli."
      ),
      birth_date = quote(switch(
        descr_nm,
        en = "Date of birth.",
        fi = "Syntymapaivamaara."
      ))
    )
  ),
  var_set_dt = data.table::data.table(
    id = c("sex", "birth_date"),
    var_nm_set = list(sex = "sex", birth_date = "birth_date")
  )
)
new_descr <- list(en = c("Sex ", "at ", "birth."), fi = "Sukupuoli.")
my_vame@var_describer_set(
  var_nm = "sex",
  value = new_descr
)
stopifnot(
  identical(
    my_vame@var_description_get("sex", descr_nm = "en"),
    new_descr[["en"]]
  ),
  inherits(
    tryCatch(
      my_vame@var_description_get("birth_date"),
      error = function(e) e
    ),
    "error"
  ),
  identical(
    my_vame@var_description_get(
      var_nm = "birth_date",
      descr_nm = "fi"
    ),
    "Syntymapaivamaara."
  )
)
# vm@vame_harmonise_dt
vm <- vame::VariableMetadata(
  var_dt = data.table::data.table(
    var_nm = c("a1", "a2", "official|A"),
    is_harmonised = c(FALSE, FALSE, TRUE)
  ),
  var_set_dt = data.table::data.table(
    id = c("a1", "a2", "official|A"),
    var_nm_set = list("a1", "a2", "official|A"),
    maker = list(
      NULL,
      NULL,
      list(
        dep_var_nm_sets = list("a1", "a2"),
        maker = quote({
          switch(
            intersect(c("a1", "a2"), ls())[1],
            a1 = data.table::data.table("official|A" = a1 + 1L),
            a2 = data.table::data.table("official|A" = a2 + 2L)
          )
        })
      )
    )
  )
)

my_dt_1 <- data.table::data.table(
  a1 = 1:2,
  some_var = runif(2)
)
my_dt_1 <- vm@vame_harmonise_dt(dt = my_dt_1)
my_dt_2 <- data.table::data.table(
  a2 = 1:2,
  some_var = runif(2)
)
my_dt_2 <- vm@vame_harmonise_dt(dt = my_dt_2)
my_dt_3 <- data.table::data.table(
  a1 = 1:2,
  some_var = runif(2)
)
vm@vame_harmonise_dt(dt = my_dt_3, inplace = TRUE)

stopifnot(
  !"a1" \%in\% names(my_dt_1),
  identical(names(my_dt_1), c("official|A", "some_var")),
  my_dt_1[["official|A"]] == 2:3,

  !"a2" \%in\% names(my_dt_2),
  identical(names(my_dt_2), c("official|A", "some_var")),
  my_dt_2[["official|A"]] == 3:4,

  !"a1" \%in\% names(my_dt_3),
  identical(names(my_dt_3), c("official|A", "some_var")),
  my_dt_3[["official|A"]] == 2:3
)

# multiple harmonisation candidates
vm <- vame::VariableMetadata(
  var_dt = data.table::data.table(
    var_nm = c("a", "official|A1", "official|A2"),
    is_harmonised = c(FALSE, TRUE, TRUE)
  ),
  var_set_dt = data.table::data.table(
    id = c("a", "official|A1", "official|A2"),
    var_nm_set = list("a", "official|A1", "official|A2"),
    maker = list(
      NULL,
      list(
        dep_var_nm_set = "a",
        maker = quote({
          data.table::data.table("official|A1" = a + 1L)
        })
      ),
      list(
        dep_var_nm_set = "a",
        maker = quote({
          data.table::data.table("official|A2" = a + 2L)
        })
      )
    )
  )
)

my_dt_1 <- data.table::data.table(
  a = 1:2,
  some_var = runif(2)
)
# Error because of multiple harmonisation candidates --- cannot automatically
# know which one to use.
my_dt_1 <- tryCatch(
  vm@vame_harmonise_dt(dt = my_dt_1),
  error = function(e) e
)
stopifnot(
  inherits(my_dt_1, "error")
)
my_dt_1 <- data.table::data.table(
  a = 1:2,
  some_var = runif(2)
)
my_dt_2 <- data.table::copy(my_dt_1)
my_dt_1 <- vm@vame_harmonise_dt(dt = my_dt_1, var_nms = c("a" = "official|A1"))
my_dt_2 <- vm@vame_harmonise_dt(dt = my_dt_2, var_nms = c("a" = "official|A2"))

stopifnot(
  !"a" \%in\% names(my_dt_1),
  identical(names(my_dt_1), c("official|A1", "some_var")),
  my_dt_1[["official|A1"]] == 2:3,

  !"a" \%in\% names(my_dt_2),
  identical(names(my_dt_2), c("official|A2", "some_var")),
  my_dt_2[["official|A2"]] == 3:4
)
vm@vame_copy
vm_1 <- vame::VariableMetadata(
  var_dt = data.table::data.table(var_nm = "a"),
  var_set_dt = data.table::data.table(id = "a", var_nm_set = list("a")),
  vame_list = list(hello = "there")
)
vm_2 <- vm_1@vame_copy()
stopifnot(
  all.equal(vm_1@var_dt_copy(), vm_2@var_dt_copy()),
  all.equal(vm_1@var_set_dt_copy(), vm_2@var_set_dt_copy())
)
vm_2@var_rename("a", "b")
stopifnot(
  identical(unname(vm_1@var_meta_get_all(meta_nm = "var_nm")), "a"),
  identical(unname(vm_2@var_meta_get_all(meta_nm = "var_nm")), "b"),
  identical(vm_1@vame_list_copy(), vm_2@vame_list_copy())
)
# vm@vame_subset
vm <- vame::VariableMetadata(
var_dt = data.table::data.table(
    var_nm = c("a", "b", "c"),
    flavour = c("tasty", "rancid", "bitter")
  ),
  var_set_dt = data.table::data.table(
    id = "set_01",
    var_nm_set = list(c("a", "b")),
    value_space = list(list(dt = data.table::data.table(
      a = 1:2,
      b = 3:4
    )))
  )
)
vm@vame_subset(var_dt_expr = var_nm == "a")
stopifnot(
  identical(unname(vm@var_meta_get_all(meta_nm = "var_nm")), "a"),
  identical(names(vm@var_set_value_space_eval("set_01")[["dt"]]), "a")
)
vm_1 <- vame::VariableMetadata(
  var_dt = data.table::data.table(
    var_nm = c("a", "b"),
    my_meta = c("vm_1_a", "vm_1_b")
  ),
  var_set_dt = data.table::data.table(
    id = "ab",
    var_nm_set = list(c("a", "b"))
  )
)
vm_2 <- vame::VariableMetadata(
  var_dt = data.table::data.table(
    var_nm = c("b", "c"),
    my_meta = c("vm_2_b", "vm_2_c")
  ),
  var_set_dt = data.table::data.table(
    id = "bc",
    var_nm_set = list(c("b", "c"))
  )
)
vm_1@vame_union_append(vm_2)
stopifnot(
  vm_1@var_meta_get(var_nm = "b", meta_nm = "my_meta") == "vm_1_b",
  vm_1@var_meta_get(var_nm = "c", meta_nm = "my_meta") == "vm_2_c"
)
}
