% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/10_S4.R
\docType{class}
\name{VariableMetadata-class}
\alias{VariableMetadata-class}
\alias{VariableMetadata}
\title{Variable Metadata}
\usage{
VariableMetadata(var_dt, var_set_dt, vame_list = NULL)
}
\arguments{
\item{var_dt}{\verb{[data.table]}

Contains information for individual variables. Must contain at a minimum
column \code{var_nm}.

See \strong{Details} and \strong{Features} for more information.}

\item{var_set_dt}{\verb{[data.table]}

Contains information for sets of variables --- e.g. a common value space.
Must contain at a minimum columns
\itemize{
\item \code{id} \verb{[integer, character]}: Identifies each set of variable names. E.g.
\code{c("my_set_01", "my_set_02")} or \code{1:2}.
\item \code{var_nm_set} \verb{[list]}: Each list element contains a character string
vector of variable names. e.g. \code{list(c("a", "b"))}.
}

See \strong{Details} and \strong{Features} for more information.}

\item{vame_list}{\verb{[NULL, list]} (default \code{NULL})

A list of metadata concerning the whole \code{VariableMetadata} object.
Its elements can be anything you want.
E.g. \code{vame_list = list(dataset_version = "1.0.0")}.}
}
\description{
Create and make use of a \code{VariableMetadata} object. It contains
\itemize{
\item \code{var_dt}: A hidden \code{data.table} containing metadata for variables,
\item \code{var_set_dt}: Hidden metadata for variable sets,
\item \code{vame_list}: A hidden list of metadata for the \code{VariableMetadata} object
itself,
\item A number of functions in S4 slots for making use of the hidden metadata
via e.g. \code{vm@var_assert} where \code{vm} is the \code{VariableMetadata} object.
}

A \code{VariableMetadata} object is created via calling the
\code{vame::VariableMetadata} function.
See section \strong{Features} for what you can do with \code{VariableMetadata}
objects.
}
\details{
\code{var_dt}:

\code{var_dt} is recommended to contain at least some sort of description for
each variable. See the describing feature.
\code{var_set_dt}:

It is recommended that \code{var_set_dt} contains as small variable sets as
possible. This includes even hierarchical variables such as area variables.
The guideline should be to have separate variable sets unless
variables in a set MUST be defined together. A \code{var_set_dt}
that contains only, or almost only, variable sets with one variable in
each is a good \code{var_set_dt}. This has the following benefits:
\itemize{
\item It is a clear rule.
\item It promotes writing smaller wholes of code, e.g. smaller functions.
\item No chance of regret when you realise that you defined something too large.
The opposite kind of regret is more rare. So the total probability of
regret is minimised.
If there really comes a case where formerly separate definitions belong
together (e.g. combining two \code{value_space}s), that is safer than
splitting: Imagine you have used \code{vm@var_set_value_space_eval} in your
code. If the variable set is split, your code may break. If it enlarges,
it less likely breaks.
}

The downside is that your \code{vame::VariableMetadata} object is more complex,
but we hide the complexity anyway by making the data only accessible with
the slot functions.

Variables that depend on each other can be visualised as a DAG where an
arrow points from a parent variable to its child, i.e. a variable that is
created using its parent. For instance, in \code{exit_date -> exit_year},
\code{exit_year} is defined using \code{exit_date}. It can be helpful to think of
a the \code{var_set_dt} as an implementation of such a graph --- and we want the
graph to show all the dependencies as arrows, not to hide dependencies
inside nodes.
}
\section{Slots}{

\describe{
\item{\code{var_set_dt_copy}}{\emph{Description}

Returns a deep copy of \code{var_set_dt_copy}.

\emph{Usage}

\code{vm@var_set_dt_copy()}}

\item{\code{var_set_meta_is_defined}}{\emph{Description}

Returns \code{TRUE} if \code{var_set_dt[[meta_nm]]} exists.

\emph{Usage}

\code{vm@var_set_meta_is_defined(id, meta_nm)}

\emph{Arguments}

id \verb{[any]} (no default)

ID, or "name", of a variable set. The class of \code{id} is defined when you
create the \code{VariableMetadata} object and it can be pretty much anything.

meta_nm \verb{[character]} (no default)

Name of a metadata column in \code{var_set_dt} or \code{var_dt} (depending on context)
of a \code{VariableMetadata} object.}

\item{\code{var_set_meta_get}}{\emph{Description}

Get metadata for a specific variable set.

\emph{Usage}

\code{vm@var_set_meta_get(id, meta_nm)}

\emph{Arguments}

id \verb{[any]} (no default)

ID, or "name", of a variable set. The class of \code{id} is defined when you
create the \code{VariableMetadata} object and it can be pretty much anything.

meta_nm \verb{[character]} (no default)

Name of a metadata column in \code{var_set_dt} or \code{var_dt} (depending on context)
of a \code{VariableMetadata} object.}

\item{\code{var_set_meta_set}}{\emph{Description}

Set metadata for a specific variable set.

\emph{Usage}

\code{vm@var_set_meta_set(id, meta_nm, value)}

\emph{Arguments}

id \verb{[any]} (no default)

ID, or "name", of a variable set. The class of \code{id} is defined when you
create the \code{VariableMetadata} object and it can be pretty much anything.

meta_nm \verb{[character]} (no default)

Name of a metadata column in \code{var_set_dt} or \code{var_dt} (depending on context)
of a \code{VariableMetadata} object.

value \verb{[any]} (no default)

In \verb{_set} functions the value to set for the specified metadata.}

\item{\code{var_set_meta_get_all}}{\emph{Description}

Get all metadata for a specific variable set.

\emph{Usage}

\code{vm@var_set_meta_get_all(meta_nm)}

\emph{Arguments}

meta_nm \verb{[character]} (no default)

Name of a metadata column in \code{var_set_dt} or \code{var_dt} (depending on context)
of a \code{VariableMetadata} object.}

\item{\code{var_set_var_nm_set_get_all}}{\emph{Description}

Get every variable name set.

\emph{Usage}

\code{vm@var_set_var_nm_set_get_all()}}

\item{\code{var_set_var_nm_set_get}}{\emph{Description}

Get a specific variable name set.

\emph{Usage}

\code{vm@var_set_var_nm_set_get(id)}

\emph{Arguments}

id \verb{[any]} (no default)

ID, or "name", of a variable set. The class of \code{id} is defined when you
create the \code{VariableMetadata} object and it can be pretty much anything.}

\item{\code{var_set_var_nm_set_set}}{\emph{Description}

Set a new value for a specific variable name set.

\emph{Usage}

\code{vm@var_set_var_nm_set_set(id, value)}

\emph{Arguments}

id \verb{[any]} (no default)

ID, or "name", of a variable set. The class of \code{id} is defined when you
create the \code{VariableMetadata} object and it can be pretty much anything.

value \verb{[any]} (no default)

In \verb{_set} functions the value to set for the specified metadata.}

\item{\code{var_set_rename}}{\emph{Description}

Rename variable sets --- change \code{var_set_dt$id} values.

\emph{Usage}

\code{vm@var_set_rename(old_ids, new_ids)}

\emph{Arguments}

old_ids \verb{[any]} (no default)

Old variable set IDs.

new_ids \verb{[any]} (no default)

New variable set IDs.}

\item{\code{var_set_remove}}{\emph{Description}

Remove a variable set by \code{id}.

\emph{Usage}

\code{vm@var_set_remove(id)}

\emph{Arguments}

id \verb{[any]} (no default)

ID, or "name", of a variable set. The class of \code{id} is defined when you
create the \code{VariableMetadata} object and it can be pretty much anything.}

\item{\code{var_set_maker_get}}{\emph{Description}

Get specific \code{var_set_dt$maker}.

\emph{Usage}

\code{vm@var_set_maker_get(id)}

\emph{Arguments}

id \verb{[any]} (no default)

ID, or "name", of a variable set. The class of \code{id} is defined when you
create the \code{VariableMetadata} object and it can be pretty much anything.}

\item{\code{var_set_maker_set}}{\emph{Description}

Assign specific \code{var_set_dt$maker}.

\emph{Usage}

\code{vm@var_set_maker_set(id, value)}

\emph{Arguments}

id \verb{[any]} (no default)

ID, or "name", of a variable set. The class of \code{id} is defined when you
create the \code{VariableMetadata} object and it can be pretty much anything.

value \verb{[any]} (no default)

In \verb{_set} functions the value to set for the specified metadata.}

\item{\code{var_set_make}}{\emph{Description}

Call specific \code{var_set_dt$maker}.
\code{vm@var_set_make} performs the following steps:
\itemize{
\item Figures out \code{id} if missing but \code{var_nms} given and vice versa.
\item If \code{maker} is a \code{function}, \code{data} is turned into a list of function
arguments and \code{maker} is called with it. The additional variables
\code{var_nms} and \code{dep_var_nm_set} are also included into the argument list.
See the argument \code{var_nms} of this function for what \code{var_nms} is.
\code{dep_var_nm_set} is the set of dependency variable names.
However, those elements of the argument list ignored which do not have a
corresponding identically named argument in the \code{maker} function
definition.
\item If \code{maker} is a \code{list}, an evaluation env is created with \code{env} as its
parent. This evaluation environment is populated by objects passed via
\code{data} and additionally \code{var_nms} and \code{dep_var_nm_set}.
If \code{maker[["maker"]] == "aggregate"}, it is replaced with an
expression that calls \code{vm@var_aggregate}.
Then \code{maker[["maker"]]} is evaluated in this environment.
\item The resulting \code{data.table} is returned as-is.
}

\emph{Usage}

\code{vm@var_set_make(data, id, var_nms, env)}

\emph{Arguments}

data \verb{[NULL, data.frame, data.table, list]} (default \code{NULL})
\itemize{
\item \code{NULL}: No data is used.
\item \code{data.frame}/\code{data.table}: These variables are used as-is.
\item \code{list}: Must by fully named. \code{list} elements are used as variables
as-is, except the optional element \code{data$df} ---
a \code{data.frame}/\code{data.table} --- is first turned into a \code{list},
and \code{data} (without \code{data$df}) and \code{data$df} are combined into one longer
\code{list}. This allows you to easily pass a \code{data.frame}/\code{data.table} and
necessary accompanying variables for settings etc.
E.g.
\code{data = list(df = data.frame(my_col_1 = 1, my_col_2 = 2), my_custom_setting = "something")}.
Of course you can also pass
\code{data = list(my_col_1 = 1, my_col_2 = 2, my_custom_setting = "something")}
directly if that is more convenient.
}

id \verb{[any]} (no default)

ID, or "name", of a variable set. The class of \code{id} is defined when you
create the \code{VariableMetadata} object and it can be pretty much anything.

var_nms \verb{[NULL, character]} (default \code{NULL})
\itemize{
\item \code{NULL}: Behaviour varies. If the function has the argument \code{ids} or \code{id},
uses all variable names in those variable sets.
\item \code{character}: Use these variable names.
}

env \verb{[NULL, environment]} (default \code{NULL})

Environment where a value space will be evaluated, if applicable.
\itemize{
\item \code{NULL}: Use the environment where the function was called.
\item \code{environment}: Use this environment.
}}

\item{\code{vame_make}}{\emph{Description}

Call multiple \code{var_set_dt$maker}s in sequence. Performs these steps:
\itemize{
\item Infers \code{ids} to use if user gave \code{var_nms} but not \code{ids} and vice versa.
\item Determines order in which the \code{maker}s of \code{ids} should be called.
For instance if \code{maker} for \code{ids[1]} requires the variables
created by the \code{maker} for \code{ids[2]}, then the latter is called first.
\item Calls the corresponding \code{vm@var_set_make} of each \code{ids} element in the
correct order.
\item Returns a \code{data.table} containing the columns created by the \code{maker}s.
}

\emph{Usage}

\code{vm@vame_make(data, ids, var_nms, env)}

\emph{Arguments}

data \verb{[data.frame, data.table, list]} (no default)
\itemize{
\item \code{data.frame}/\code{data.table}: Columns contain necessary data.
\item \code{list}: Element \code{data$df} can be a \code{data.frame}/
\code{data.table} whose columns contain necessary data.
Alternatively the list elements can contain necessary data directly,
or a combination of the two.
}

ids \verb{[NULL, vector]} (default \code{NULL})
\itemize{
\item \code{NULL}: Behaviour varies. An error is raised if this cannot be inferred.
If the function has the argument \code{var_nms}, that will be used
to infer \code{ids}.
\item \code{vector}: One or more values that can be found in \code{var_set_dt$id}.
}

var_nms \verb{[NULL, character]} (default \code{NULL})
\itemize{
\item \code{NULL}: Behaviour varies. If the function has the argument \code{ids} or \code{id},
uses all variable names in those variable sets.
\item \code{character}: Use these variable names.
}

env \verb{[NULL, environment]} (default \code{NULL})

Environment where a value space will be evaluated, if applicable.
\itemize{
\item \code{NULL}: Use the environment where the function was called.
\item \code{environment}: Use this environment.
}}

\item{\code{var_set_value_space_eval}}{\emph{Description}

Retrieve and evaluate value space for a variable set given its \code{id}.

\emph{Usage}

\code{vm@var_set_value_space_eval(id, var_nms, env)}

\emph{Arguments}

id \verb{[any]} (no default)

ID, or "name", of a variable set. The class of \code{id} is defined when you
create the \code{VariableMetadata} object and it can be pretty much anything.

var_nms \verb{[NULL, character]} (default \code{NULL})
\itemize{
\item \code{NULL}: Behaviour varies. If the function has the argument \code{ids} or \code{id},
uses all variable names in those variable sets.
\item \code{character}: Use these variable names.
}

env \verb{[NULL, environment]} (default \code{NULL})

Environment where a value space will be evaluated, if applicable.
\itemize{
\item \code{NULL}: Use the environment where the function was called.
\item \code{environment}: Use this environment.
}}

\item{\code{var_set_value_space_get}}{\emph{Description}

Get the value space of a specific variable set without evaluting it.

\emph{Usage}

\code{vm@var_set_value_space_get(id)}

\emph{Arguments}

id \verb{[any]} (no default)

ID, or "name", of a variable set. The class of \code{id} is defined when you
create the \code{VariableMetadata} object and it can be pretty much anything.}

\item{\code{var_set_value_space_set}}{\emph{Description}

Set the value space of a specific variable set.

\emph{Usage}

\code{vm@var_set_value_space_set(id, value_space)}

\emph{Arguments}

id \verb{[any]} (no default)

ID, or "name", of a variable set. The class of \code{id} is defined when you
create the \code{VariableMetadata} object and it can be pretty much anything.

value_space \verb{[list]} (no default)

A value space to assign for the specified variable set.}

\item{\code{var_set_value_space_dt_subset}}{\emph{Description}

Take a subset of a value space dt for a variable set and set that as the value space.

\emph{Usage}

\code{vm@var_set_value_space_dt_subset(id, expr)}

\emph{Arguments}

id \verb{[any]} (no default)

ID, or "name", of a variable set. The class of \code{id} is defined when you
create the \code{VariableMetadata} object and it can be pretty much anything.

expr \verb{[any]} (no default)

Expression to subset a \code{data.table} object. Available columns depends on
context.}

\item{\code{var_set_value_space_sampler_get}}{\emph{Description}

Retrieve value space sampler for given \code{id} from \code{var_set_dt$sampler}.

\emph{Usage}

\code{vm@var_set_value_space_sampler_get(id)}

\emph{Arguments}

id \verb{[any]} (no default)

ID, or "name", of a variable set. The class of \code{id} is defined when you
create the \code{VariableMetadata} object and it can be pretty much anything.}

\item{\code{var_set_value_space_sampler_set}}{\emph{Description}

Assign value space sampler for given \code{id} in \code{var_set_dt$sampler}.

The \code{sampler} can be \code{NULL}, a \code{list}, a \code{function} or a \code{call} object.
A \code{NULL} \code{sampler}
object is considered to mean that one has not been defined.
A \code{sampler} of type \code{function} must have arguments \code{x}, \code{vs}, and
\code{n}. \code{x} is the \code{vame::VariableMetadata} object itself,
\code{vs} is the pre-evaluated \code{value_space} for the variable set,
and \code{n} the number of samples.
A \code{sampler} of type \code{list} must have elements \code{sampler$dep_var_nm_set} and
\code{sampler$sampler}. \code{sampler$dep_var_nm_set} must be a character string
vector: use this to list names of variables needed for conditional
sampling. E.g. sampling \code{y} conditional on \code{x} means you should have
\code{dep_var_nm_set = "x"}. \code{sampler$sampler} must be a \code{function} or a
\code{call} object.
A \code{sampler} of type \code{call} must contain (mention) variable \code{n} ---
see \code{?all.vars}.

See the documentation for \code{var_set_value_space_sample} to understand how
the \code{sampler} object is used.

\emph{Usage}

\code{vm@var_set_value_space_sampler_set(id, value)}

\emph{Arguments}

id \verb{[any]} (no default)

ID, or "name", of a variable set. The class of \code{id} is defined when you
create the \code{VariableMetadata} object and it can be pretty much anything.

value \verb{[any]} (no default)

In \verb{_set} functions the value to set for the specified metadata.}

\item{\code{var_set_value_space_sample}}{\emph{Description}

Take \code{n} random samples from the value space of \code{id}.

Random sampling is performed as follows:
\itemize{
\item \code{vm@var_set_value_space_eval} is called for the appropriate value space
\item The appropriate \code{sampler} is retrieved --- this is either the
corresponding
sampler stored in \code{var_set_dt$sampler}, or if no sampler exists there,
one of the defaults depending on the type of the value space:
\itemize{
\item \code{dt}: Sample uniformly rows from \code{data.table} with replacement.
\item \code{set}: Sample uniformly from set with replacement.
\item \code{expr} & \code{fun}: Handling depends on the type of output: A vector
output is handled as a \code{set} and a \code{data.table} output as a \code{dt}.
\item \code{unrestricted}: If \code{class_set = "character"}, sample random strings
of length 16 using character pool \code{c(letters, LETTERS, 0:9)}. If
\code{class_set} is anything else, raise an error because no sampler is
defined for the general case.
\item \code{regex}: Raise error because no sampler defined.
\item \code{bounds}: Sample uniformly between \code{lo} and \code{hi} --- with
replacement from \code{lo:hi} if \code{storage.mode(lo) == "integer"}.
}
\item The \code{sampler} is called or evaluated, which results in the random samples,
and these are returned. If the \code{sampler} is a function it is called via
\code{sampler(x = vm, n = n)}, where \code{vm} is the
\code{VariableMetadata} object itself.
The function may also have the optional arguments \code{vs}
(the evaluated value space for \code{id}), \code{data} (see argument \code{data}
of \code{vm@var_set_value_space_sample}), \code{dep_var_nm_set} (this will be
\code{sampler$dep_var_nm_set} if \code{sampler} was a list), \code{id}
(see argument \code{id} of \code{vm@var_set_value_space_sample}), and
\code{var_nms} (see argument \code{var_nms} of \code{vm@var_set_value_space_sample}).
If \code{sampler} is an expression, it is evaluated in a new
environment that contains the arguments mentioned above as objects.
This new environment's parent is \code{env}.
For conditional sampling you must use \code{sampler} of type \code{list} and make
use of \code{data} (and optionally \code{dep_var_nm_set}) in \code{sampler$sampler}.
\code{vm@var_set_value_space_sample} always returns a \code{data.table} with
\code{n} rows.
}

\emph{Usage}

\code{vm@var_set_value_space_sample(id, var_nms, n, data, env)}

\emph{Arguments}

id \verb{[any]} (no default)

ID, or "name", of a variable set. The class of \code{id} is defined when you
create the \code{VariableMetadata} object and it can be pretty much anything.

var_nms \verb{[NULL, character]} (default \code{NULL})
\itemize{
\item \code{NULL}: Behaviour varies. If the function has the argument \code{ids} or \code{id},
uses all variable names in those variable sets.
\item \code{character}: Use these variable names.
}

n \verb{[integer]} (default \code{1L})

Number of random samples to take.

data \verb{[NULL, data.frame, data.table, list]} (default \code{NULL})
\itemize{
\item \code{NULL}: No data is used.
\item \code{data.frame}/\code{data.table}: These variables are used as-is.
\item \code{list}: Must by fully named. \code{list} elements are used as variables
as-is, except the optional element \code{data$df} ---
a \code{data.frame}/\code{data.table} --- is first turned into a \code{list},
and \code{data} (without \code{data$df}) and \code{data$df} are combined into one longer
\code{list}. This allows you to easily pass a \code{data.frame}/\code{data.table} and
necessary accompanying variables for settings etc.
E.g.
\code{data = list(df = data.frame(my_col_1 = 1, my_col_2 = 2), my_custom_setting = "something")}.
Of course you can also pass
\code{data = list(my_col_1 = 1, my_col_2 = 2, my_custom_setting = "something")}
directly if that is more convenient.
}

env \verb{[NULL, environment]} (default \code{NULL})

Environment where a value space will be evaluated, if applicable.
\itemize{
\item \code{NULL}: Use the environment where the function was called.
\item \code{environment}: Use this environment.
}}

\item{\code{var_is_aggregateable_to}}{\emph{Description}

Returns \code{TRUE} if \code{from_var_nm} can be aggregated into \code{to_var_nm}.

\emph{Usage}

\code{vm@var_is_aggregateable_to(from_var_nm, to_var_nm)}

\emph{Arguments}

from_var_nm \verb{[character]} (no default)

Name of a variable. Aggregation from this to another variable.

to_var_nm \verb{[character]} (no default)

Name of a variable. Aggregation to this from another variable.}

\item{\code{var_aggregate}}{\emph{Description}

Returns correspoding level of \code{to_var_nm} for each value in \code{x}.

\emph{Usage}

\code{vm@var_aggregate(x, from_var_nm, to_var_nm)}

\emph{Arguments}

x \verb{[any]} (no default)

Values of a specified variable.

from_var_nm \verb{[character]} (no default)

Name of a variable. Aggregation from this to another variable.

to_var_nm \verb{[character]} (no default)

Name of a variable. Aggregation to this from another variable.}

\item{\code{var_value_space_eval}}{\emph{Description}

Get and evaluate value space for a variable.
This gets tricky when a variable has been defined in more than one
\code{var_set_dt$value_space}. If there is a single \code{var_set_dt$value_space}
for only the variable of interest, that is used. Otherwise:
\itemize{
\item Every value space for the variable is evaluated via
\code{vm@var_set_value_space_eval}. If the exact same value space has been
produced multiple times, duplicates are removed.
\item If we now have only one value space, all is well and that is returned.
\item If the \code{var_dt$type == "categorical"} for this variable, the union of
all separate value spaces is formed and that will be returned.
\item In other cases an error is raised because there does not seem to be
any way to decide which value space to use.
}

\emph{Usage}

\code{vm@var_value_space_eval(var_nm, env)}

\emph{Arguments}

var_nm \verb{[character]} (no default)

Name of a variable.

env \verb{[NULL, environment]} (default \code{NULL})

Environment where a value space will be evaluated, if applicable.
\itemize{
\item \code{NULL}: Use the environment where the function was called.
\item \code{environment}: Use this environment.
}}

\item{\code{var_assert}}{\emph{Description}

Assert that values in \code{x} are proper values of \code{var_nm}.

\emph{Usage}

\code{vm@var_assert(x, var_nm, x_nm, call, assertion_type, env)}

\emph{Arguments}

x \verb{[any]} (no default)

Values of a specified variable.

var_nm \verb{[character]} (no default)

Name of a variable.

x_nm \verb{[NULL, character]} (default \code{NULL})

See \link[dbc:argument_handlers]{dbc::handle_arg_x_nm}.

call \verb{[NULL, language]} (default \code{NULL})

See \link[dbc:argument_handlers]{dbc::handle_arg_call}.

assertion_type \verb{[NULL, character]} (default \code{NULL})

See \link[dbc:assertion_types]{dbc::handle_arg_assertion_type}.

env \verb{[NULL, environment]} (default \code{NULL})

Environment where a value space will be evaluated, if applicable.
\itemize{
\item \code{NULL}: Use the environment where the function was called.
\item \code{environment}: Use this environment.
}}

\item{\code{var_dt_copy}}{\emph{Description}

Returns a deep copy of \code{var_dt}.

\emph{Usage}

\code{vm@var_dt_copy()}}

\item{\code{var_meta_is_defined}}{\emph{Description}

Returns \code{TRUE} if \code{var_dt[[meta_nm]]} exists.

\emph{Usage}

\code{vm@var_meta_is_defined(var_nm, meta_nm)}

\emph{Arguments}

var_nm \verb{[character]} (no default)

Name of a variable.

meta_nm \verb{[character]} (no default)

Name of a metadata column in \code{var_set_dt} or \code{var_dt} (depending on context)
of a \code{VariableMetadata} object.}

\item{\code{var_meta_get}}{\emph{Description}

Get metadata for a variable.

\emph{Usage}

\code{vm@var_meta_get(var_nm, meta_nm)}

\emph{Arguments}

var_nm \verb{[character]} (no default)

Name of a variable.

meta_nm \verb{[character]} (no default)

Name of a metadata column in \code{var_set_dt} or \code{var_dt} (depending on context)
of a \code{VariableMetadata} object.}

\item{\code{var_meta_set}}{\emph{Description}

Set metadata for a variable.

\emph{Usage}

\code{vm@var_meta_set(var_nm, meta_nm, value)}

\emph{Arguments}

var_nm \verb{[character]} (no default)

Name of a variable.

meta_nm \verb{[character]} (no default)

Name of a metadata column in \code{var_set_dt} or \code{var_dt} (depending on context)
of a \code{VariableMetadata} object.

value \verb{[any]} (no default)

In \verb{_set} functions the value to set for the specified metadata.}

\item{\code{var_meta_get_all}}{\emph{Description}

Get metadata for all variables.

\emph{Usage}

\code{vm@var_meta_get_all(meta_nm)}

\emph{Arguments}

meta_nm \verb{[character]} (no default)

Name of a metadata column in \code{var_set_dt} or \code{var_dt} (depending on context)
of a \code{VariableMetadata} object.}

\item{\code{var_rename}}{\emph{Description}

Rename variables. The name is changed in the following places:
\itemize{
\item \code{var_dt$var_nm}
\item \code{var_set_dt$value_space}, if the \code{value_space} object is of type \code{dt}.
If the \code{value_space} is of type \code{expr} or \code{fun}, \code{vm@var_rename} emits
a warning because it does not attempt to alter R expressions or
functions --- you will have to do that youself.
\item \code{var_set_dt$var_nm_set}
}

\emph{Usage}

\code{vm@var_rename(old_var_nms, new_var_nms)}

\emph{Arguments}

old_var_nms \verb{[character]} (no default)

Variable names to change.

new_var_nms \verb{[character]} (no default)

Variable names to change to.}

\item{\code{var_remove}}{\emph{Description}

Remove a variable.

\emph{Usage}

\code{vm@var_remove(var_nm)}

\emph{Arguments}

var_nm \verb{[character]} (no default)

Name of a variable.}

\item{\code{var_labeler_get}}{\emph{Description}

Get the labeler for a variable.
Set the labeler for a variable.

\emph{Usage}

\code{vm@var_labeler_get(var_nm)}

\emph{Arguments}

var_nm \verb{[character]} (no default)

Name of a variable.}

\item{\code{var_labeler_set}}{\emph{Description}

\emph{Usage}

\code{vm@var_labeler_set(var_nm, value)}

\emph{Arguments}

var_nm \verb{[character]} (no default)

Name of a variable.

value \verb{[any]} (no default)

In \verb{_set} functions the value to set for the specified metadata.}

\item{\code{var_labels_get}}{\emph{Description}

Get label for each value in \code{x} for \code{var_nm}.

\emph{Usage}

\code{vm@var_labels_get(x, var_nm, label_nm, labeler_env)}

\emph{Arguments}

x \verb{[any]} (no default)

Values of a specified variable.

var_nm \verb{[character]} (no default)

Name of a variable.

label_nm \verb{[NULL, character]} (default \code{NULL})

Name of a column in the \code{labeler} that has been assigned for the variable.
Labels will be taken from this column.
\itemize{
\item \code{NULL}: Use first column name in \code{labeler} that is not \code{"x"} --- if
\code{labeler} is a \code{data.table}.
\item \code{character}: Use this column name.
}

labeler_env \verb{[NULL, environment]} (default \code{NULL})

Environment where \code{labeler} of class \code{call} is evaluated.
\itemize{
\item \code{NULL}: Use the environment where this function is called.
\item \code{environment}: Use this environment.
}}

\item{\code{var_describer_get}}{\emph{Description}

Get the describer for a variable.
Set the describer for a variable.

\emph{Usage}

\code{vm@var_describer_get(var_nm)}

\emph{Arguments}

var_nm \verb{[character]} (no default)

Name of a variable.}

\item{\code{var_describer_set}}{\emph{Description}

\emph{Usage}

\code{vm@var_describer_set(var_nm, value)}

\emph{Arguments}

var_nm \verb{[character]} (no default)

Name of a variable.

value \verb{[any]} (no default)

In \verb{_set} functions the value to set for the specified metadata.}

\item{\code{var_description_get}}{\emph{Description}

Get description for \code{var_nm}.

\emph{Usage}

\code{vm@var_description_get(var_nm, descr_nm, describer_env)}

\emph{Arguments}

var_nm \verb{[character]} (no default)

Name of a variable.

descr_nm \verb{[NULL, character]} (default \code{NULL})

Name of a description in the \code{describer} that has been assigned for the
variable.
\itemize{
\item \code{NULL}: If \code{describer} is a \code{list}, use first element.
Else raises an error.
\item \code{character}: Use this description name.
}

describer_env \verb{[NULL, environment]} (default \code{NULL})

Environment where \code{describer} of class \code{call} is evaluated.
\itemize{
\item \code{NULL}: Use the environment where this function is called.
\item \code{environment}: Use this environment.
}}

\item{\code{var_value_space_sample}}{\emph{Description}

Wrapper for \code{vm@var_set_value_space_sample} for when you want a random
sample for only one variable.

\emph{Usage}

\code{vm@var_value_space_sample(var_nm, env, n)}

\emph{Arguments}

var_nm \verb{[character]} (no default)

Name of a variable.

env \verb{[NULL, environment]} (default \code{NULL})

Environment where a value space will be evaluated, if applicable.
\itemize{
\item \code{NULL}: Use the environment where the function was called.
\item \code{environment}: Use this environment.
}

n \verb{[integer]} (default \code{1L})

Number of random samples to take.}

\item{\code{vame_copy}}{\emph{Description}

Take a deep copy of a VariableMetadata object. See \code{?data.table::copy}.

\emph{Usage}

\code{vm@vame_copy()}}

\item{\code{vame_subset}}{\emph{Description}

Subset whole \code{VariableMetadata} object. Subset either \code{var_dt} or
\code{var_set_dt} (or both) and keep only metadata for variables that appear in
both \code{var_dt} and \code{var_set_dt}.

\emph{Usage}

\code{vm@vame_subset(var_dt_expr, var_set_dt_expr)}

\emph{Arguments}

var_dt_expr \verb{[NULL, logical, integer]} (default \code{NULL})

An R expression that should evaluate into \code{NULL}, \code{logical}, or \code{integer}.
The latter two are used to subset \code{var_dt}. \code{NULL} implies no subset.

var_set_dt_expr \verb{[NULL, logical, integer]} (default \code{NULL})

An R expression that should evaluate into \code{NULL}, \code{logical}, or \code{integer}.
The latter two are used to subset \code{var_set_dt_expr}. \code{NULL} implies no
subset.}

\item{\code{vame_union_append}}{\emph{Description}

Append new data into \code{VariableMetadata} object from another.
No pre-existing data are overwritten.

\emph{Usage}

\code{vm@vame_union_append(vm_2)}

\emph{Arguments}

vm_2 \verb{[VariableMetadata]} (no default)

\code{VariableMetadata} object whose metadata will be appended to the current
\code{VariableMetadata} object.}

\item{\code{vame_meta_is_defined}}{\emph{Description}

Returns \code{TRUE} if \code{vame_list} has non-\code{NULL} element named \code{meta_nm}.

\emph{Usage}

\code{vm@vame_meta_is_defined(meta_nm)}

\emph{Arguments}

meta_nm \verb{[character]} (no default)

Name of a metadata column in \code{var_set_dt} or \code{var_dt} (depending on context)
of a \code{VariableMetadata} object.}

\item{\code{vame_meta_get}}{\emph{Description}

Retrieve an element of \code{vame_list}.

\emph{Usage}

\code{vm@vame_meta_get(meta_nm)}

\emph{Arguments}

meta_nm \verb{[character]} (no default)

Name of a metadata column in \code{var_set_dt} or \code{var_dt} (depending on context)
of a \code{VariableMetadata} object.}

\item{\code{vame_meta_set}}{\emph{Description}

Assign an element of \code{vame_meta_set}.

\emph{Usage}

\code{vm@vame_meta_set(meta_nm, value)}

\emph{Arguments}

meta_nm \verb{[character]} (no default)

Name of a metadata column in \code{var_set_dt} or \code{var_dt} (depending on context)
of a \code{VariableMetadata} object.

value \verb{[any]} (no default)

In \verb{_set} functions the value to set for the specified metadata.}

\item{\code{vame_value_space_sampler_get}}{\emph{Description}

Retrieve \code{meta_list$sampler}.

\emph{Usage}

\code{vm@vame_value_space_sampler_get()}}

\item{\code{vame_value_space_sampler_set}}{\emph{Description}

Assign \code{meta_list$sampler}.

The \code{sampler} can be \code{NULL}, a \code{list}, a \code{function} or a \code{call} object.
A \code{NULL} \code{sampler}
object is considered to mean that one has not been defined.
A \code{sampler} of type \code{function} must have arguments \code{x}, \code{vs}, and
\code{n}. \code{x} is the \code{vame::VariableMetadata} object itself,
\code{vs} is the pre-evaluated \code{value_space} for the variable set,
and \code{n} the number of samples.
A \code{sampler} of type \code{list} must have elements \code{sampler$dep_var_nm_set} and
\code{sampler$sampler}. \code{sampler$dep_var_nm_set} must be a character string
vector: use this to list names of variables needed for conditional
sampling. E.g. sampling \code{y} conditional on \code{x} means you should have
\code{dep_var_nm_set = "x"}. \code{sampler$sampler} must be a \code{function} or a
\code{call} object.
A \code{sampler} of type \code{call} must contain (mention) variable \code{n} ---
see \code{?all.vars}.

See the documentation for \code{vame_value_space_sample} to understand how
the \code{sampler} object is used.

\emph{Usage}

\code{vm@vame_value_space_sampler_set(value)}

\emph{Arguments}

value \verb{[any]} (no default)

In \verb{_set} functions the value to set for the specified metadata.}

\item{\code{vame_value_space_sample}}{\emph{Description}

\code{vm@var_value_space_sample} always returns a vector of length \code{n}.
If \code{vame_list$sampler} has not been set, \code{vm@vame_value_space_sample}
calls \code{vm@vame_value_space_sample_default}.
Take \code{n} random samples of the value spaces of \code{ids}.

If \code{vame_list$sampler} is a function, it is called via
\code{vame_list$sampler(x = vm, ids = ids, n = n, data = data, var_nms = var_nms)},
where \code{vm} is the pertinent \code{VariableMetadata} object itself.
If \code{vame_list$sampler} is a \code{call} object, it is evaluated in a new
environment whose parent is \code{env}. This new environment contains the
same objects that would be passed as arguments when calling
\code{vame_list$sampler} as a \code{function}.
\code{vm@vame_value_space_sample} always returns a \code{data.table} with \code{n} rows.
If \code{var_nms} was supplied, only those columns are in the output in the
given order.
Else all columns for each variable set identified by \code{ids} are present.

\emph{Usage}

\code{vm@vame_value_space_sample(ids, n, data, var_nms, env)}

\emph{Arguments}

ids \verb{[NULL, vector]} (default \code{NULL})
\itemize{
\item \code{NULL}: Behaviour varies. An error is raised if this cannot be inferred.
If the function has the argument \code{var_nms}, that will be used
to infer \code{ids}.
\item \code{vector}: One or more values that can be found in \code{var_set_dt$id}.
}

n \verb{[integer]} (default \code{1L})

Number of random samples to take.

data \verb{[NULL, data.frame, data.table, list]} (default \code{NULL})
\itemize{
\item \code{NULL}: No data is used.
\item \code{data.frame}/\code{data.table}: These variables are used as-is.
\item \code{list}: Must by fully named. \code{list} elements are used as variables
as-is, except the optional element \code{data$df} ---
a \code{data.frame}/\code{data.table} --- is first turned into a \code{list},
and \code{data} (without \code{data$df}) and \code{data$df} are combined into one longer
\code{list}. This allows you to easily pass a \code{data.frame}/\code{data.table} and
necessary accompanying variables for settings etc.
E.g.
\code{data = list(df = data.frame(my_col_1 = 1, my_col_2 = 2), my_custom_setting = "something")}.
Of course you can also pass
\code{data = list(my_col_1 = 1, my_col_2 = 2, my_custom_setting = "something")}
directly if that is more convenient.
}

var_nms \verb{[NULL, character]} (default \code{NULL})
\itemize{
\item \code{NULL}: Behaviour varies. If the function has the argument \code{ids} or \code{id},
uses all variable names in those variable sets.
\item \code{character}: Use these variable names.
}

env \verb{[NULL, environment]} (default \code{NULL})

Environment where a value space will be evaluated, if applicable.
\itemize{
\item \code{NULL}: Use the environment where the function was called.
\item \code{environment}: Use this environment.
}}

\item{\code{vame_value_space_sample_default}}{\emph{Description}

\code{vm@vame_value_space_sample_default}
calls \code{vm@var_set_value_space_sample} for every pertinent variable set
and combines the results into one large \code{data.table}.
\code{vm@vame_value_space_sample_default} always returns a \code{data.table} with \code{n}
rows.

\emph{Usage}

\code{vm@vame_value_space_sample_default(ids, env, var_nms, data, n)}

\emph{Arguments}

ids \verb{[NULL, vector]} (default \code{NULL})
\itemize{
\item \code{NULL}: Behaviour varies. An error is raised if this cannot be inferred.
If the function has the argument \code{var_nms}, that will be used
to infer \code{ids}.
\item \code{vector}: One or more values that can be found in \code{var_set_dt$id}.
}

env \verb{[NULL, environment]} (default \code{NULL})

Environment where a value space will be evaluated, if applicable.
\itemize{
\item \code{NULL}: Use the environment where the function was called.
\item \code{environment}: Use this environment.
}

var_nms \verb{[NULL, character]} (default \code{NULL})
\itemize{
\item \code{NULL}: Behaviour varies. If the function has the argument \code{ids} or \code{id},
uses all variable names in those variable sets.
\item \code{character}: Use these variable names.
}

data \verb{[NULL, data.frame, data.table, list]} (default \code{NULL})
\itemize{
\item \code{NULL}: No data is used.
\item \code{data.frame}/\code{data.table}: These variables are used as-is.
\item \code{list}: Must by fully named. \code{list} elements are used as variables
as-is, except the optional element \code{data$df} ---
a \code{data.frame}/\code{data.table} --- is first turned into a \code{list},
and \code{data} (without \code{data$df}) and \code{data$df} are combined into one longer
\code{list}. This allows you to easily pass a \code{data.frame}/\code{data.table} and
necessary accompanying variables for settings etc.
E.g.
\code{data = list(df = data.frame(my_col_1 = 1, my_col_2 = 2), my_custom_setting = "something")}.
Of course you can also pass
\code{data = list(my_col_1 = 1, my_col_2 = 2, my_custom_setting = "something")}
directly if that is more convenient.
}

n \verb{[integer]} (default \code{1L})

Number of random samples to take.}

\item{\code{vame_list_copy}}{\emph{Description}

Get a deep copy of \code{meta_list}.

\emph{Usage}

\code{vm@vame_list_copy()}}

\item{\code{vame_category_space_dt_list}}{\emph{Description}

Get list of category space \code{data.table} objects.

\emph{Usage}

\code{vm@vame_category_space_dt_list(var_nms, env)}

\emph{Arguments}

var_nms \verb{[NULL, character]} (default \code{NULL})
\itemize{
\item \code{NULL}: Behaviour varies. If the function has the argument \code{ids} or \code{id},
uses all variable names in those variable sets.
\item \code{character}: Use these variable names.
}

env \verb{[NULL, environment]} (default \code{NULL})

Environment where a value space will be evaluated, if applicable.
\itemize{
\item \code{NULL}: Use the environment where the function was called.
\item \code{environment}: Use this environment.
}}

\item{\code{vame_category_space_dt}}{\emph{Description}

Get a category space \code{data.table}.

\emph{Usage}

\code{vm@vame_category_space_dt(var_nms, env)}

\emph{Arguments}

var_nms \verb{[NULL, character]} (default \code{NULL})
\itemize{
\item \code{NULL}: Behaviour varies. If the function has the argument \code{ids} or \code{id},
uses all variable names in those variable sets.
\item \code{character}: Use these variable names.
}

env \verb{[NULL, environment]} (default \code{NULL})

Environment where a value space will be evaluated, if applicable.
\itemize{
\item \code{NULL}: Use the environment where the function was called.
\item \code{environment}: Use this environment.
}}
}}

\section{Features}{

\strong{Make}

The make feature allows for making variable sets based on other variable
sets. For instance, a year column might be "made" based on a data column,
say \code{start_year} from \code{start_date}. This feature becomes available
when one or more \code{var_set_dt$maker} objects have been defined:

The \code{maker} can be \code{NULL}, a \code{function}, or a \code{list}. A \code{NULL} \code{maker}
object is considered to mean that one has not been defined.
A \code{maker} of type \code{function} must have as arguments the invididual
required variables. Using \code{...} is not allowed to enable proper checks
on inputs when the \code{maker} is called.
A \code{maker} of type \code{list} can be of two kinds. The first kind has named
elements \code{maker} of class \code{call} and
\code{dep_var_nm_set} of class \code{character}, e.g.
\code{list(maker = quote(make(x, y)), dep_var_nm_set = c("x", "y"))}.
The second kind is otherwise the same, but \code{maker} must be string
\code{"var_aggregate"}, and \code{dep_var_nm_set} must be of length one. This second
kind is a shorthand for cases where one variable can be created simply
by aggregating another with \code{vm@var_aggregate}.
The recommended approach to writing a \code{maker} for a variable set is to
write a function and store a call to it as the \code{maker}. See the example
for the \code{make} feature:

\if{html}{\out{<div class="sourceCode">}}\preformatted{# Example of make feature
make_dg_y <- function(
  dg_date
) \{
  out <- data.table::data.table(dg_y = data.table::year(dg_date))
  return(out[])
\}
# We do not store `my_fun` here directly because if a `VariableMetadata`
# object is written to disk, the entire enclosing env of `my_fun` is
# included. This can get very messy when it is read back into R.
# It is strongly recommended to store quoted expressions instead
# and store any functions you write somewhere else, ideally in an R package.
my_vame <- vame::VariableMetadata(
  var_dt = data.table::data.table(
    var_nm = c("dg_y", "dg_date", "area_01", "area_02", "area_03"),
    type = c("year", "date", "categorical", "categorical", "categorical")
  ),
  var_set_dt = data.table::data.table(
    id = c("dg_y", "dg_date", "area", "area_01", "area_02"),
    var_nm_set = list(
      dg_y = "dg_y",
      dg_date = "dg_date",
      area = c("area_01", "area_02", "area_03"),
      area_01 = "area_01",
      area_02 = "area_02"
    ),
    maker = list(
      dg_y = list(
        maker = quote(make_dg_y(dg_date = dg_date)),
        dep_var_nm_set = "dg_date"
      ),
      dg_date = NULL,
      area = NULL,
      area_01 = list(
        maker = quote(\{
          # This is an example of re-using data from the `VariableMetadata`
          # object itself. 
          vm <- vame::self()
          dt <- data.table::setDT(list(
            x = vm@var_aggregate(
              get(dep_var_nm_set),
              from_var_nm = dep_var_nm_set,
              to_var_nm = var_nms
            )
          ))
          data.table::setnames(dt, "x", var_nms)
          dt[]
        \}),
        dep_var_nm_set = "area_02"
      ),
      # This example uses the shorthand var_aggregate approach.
      area_02 = list(maker = "var_aggregate", dep_var_nm_set = "area_03")
    ),
    value_space = list(
      dg_y = list(set = 1953:2024),
      dg_date = list(bounds = list(
        lo = as.Date("1953-01-01"),
        hi = as.Date("2024-12-31"),
        lo_inclusive = TRUE,
        hi_inclusive = TRUE
      )),
      area = list(dt = data.table::data.table(
        area_01 = c(1L,1L,1L,2L,2L,2L),
        area_02 = c(11L,12L,12L,21L,21L,22L),
        area_03 = c(111L,121L,122L,211L,212L,221L)
      )),
      area_01 = NULL,
      area_02 = NULL
    )
  )
)
obs <- my_vame@var_set_make(
  id = "dg_y",
  data = data.table::data.table(dg_date = as.Date("2001-01-01"))
)
exp <- data.table::data.table(dg_y = 2001L)
stopifnot(identical(obs[["dg_y"]], exp[["dg_y"]]))

obs <- my_vame@var_set_make(
  id = "area_01",
  data = data.table::data.table(area_02 = c(11L, 21L))
)
exp <- data.table::data.table(area_01 = c(1L,2L))
stopifnot(identical(obs[["area_01"]], exp[["area_01"]]))

obs <- my_vame@var_set_make(
  id = "area_02",
  data = data.table::data.table(area_03 = c(111L, 211L))
)
exp <- data.table::data.table(area_02 = c(11L,21L))
stopifnot(identical(obs[["area_02"]], exp[["area_02"]]))

obs <- my_vame@vame_make(
  ids = c("dg_y", "area_02", "area_01"),
  data = data.table::data.table(
    dg_date = as.Date("2001-01-01"),
    area_03 = c(111L,121L,122L,211L,212L,221L)
  )
)
exp <- data.table::data.table(
  dg_y = 2001L,
  area_02 = my_vame@var_aggregate(
    c(111L,121L,122L,211L,212L,221L),
    from_var_nm = "area_03",
    to_var_nm = "area_02"
  )
)
exp[
  j = "area_01" := my_vame@var_aggregate(
    exp[["area_02"]],
    from_var_nm = "area_02",
    to_var_nm = "area_01"
  )
]
stopifnot(
  identical(obs[["dg_y"]], exp[["dg_y"]]),
  identical(obs[["area_01"]], exp[["area_01"]]),
  identical(obs[["area_02"]], exp[["area_02"]])
)

obs_2 <- my_vame@vame_make(
  var_nms = c("dg_y", "area_02", "area_01"),
  data = data.table::data.table(
    dg_date = as.Date("2001-01-01"),
    area_03 = c(111L,121L,122L,211L,212L,221L)
  )
)
obs_3 <- my_vame@vame_make(
  var_nms = c("dg_y", "area_02", "area_01"),
  data = list(df = data.table::data.table(
    dg_date = as.Date("2001-01-01"),
    area_03 = c(111L,121L,122L,211L,212L,221L)
  ))
)
stopifnot(
  all.equal(obs, obs_2),
  all.equal(obs, obs_3)
)
}\if{html}{\out{</div>}}

The following functions are related to this feature:
\itemize{
\item \code{vm@var_set_maker_get}
\item \code{vm@var_set_maker_set}
\item \code{vm@var_set_make}
\item \code{vm@vame_make}
}

\strong{Value spaces}

The value spaces feature allows you to define what values (combinations of)
variables can have. This information can then be retrieved from one single
place (the \code{VariableMetadata} object) for use elsewhere, e.g. for computing
something by strata. See also the category spaces and assertions features.

The value spaces feature becomes available when \code{var_set_dt} contains column
\code{value_space}. You can include it when \code{VariableMetadata} is constructed
or you can use \code{vm@var_set_value_space_set} later.

\code{var_set_dt$value_space} must be a list column.
A \code{value_space} for a variable set must be named list of length one or
\code{NULL}. Therefore \code{var_set_dt$value_space} is a list, in turn containing
lists of length one or \code{NULL} values.
The following element names are allowed and determine the type of the
\code{value_space}: c("dt", "set", "expr", "fun", "unrestricted", "regex", "bounds").

The \code{value_space} element must be \code{NULL} or one of the following:
\itemize{
\item \code{"dt"}: A \code{data.table}. The column names must be the same as those
in the variable set. This can be used to define the (joint) value
space of one or more variables.
E.g. \code{list(dt = data.table::CJ(a = 1:2, b = 3:4))}.
\item \code{"set"}: A vector of any kinds of values. Only allowed for a variable
set containing exactly one variable.
E.g. \code{list(set = 1:2)}.
\item \code{"expr"}: An unevaluated R expression.
This can be used to define the (joint) value
space of one or more variables. What to do with the result of the
expression is deduced from the type of the result --- e.g. a
\code{data.table} result will be handled in the same manner as if the
\code{value_space} had been of type \code{dt}. This can be useful for making use
of functions to define the value space:
E.g. \code{list(expr = quote(my_fun()))}.
\item \code{"fun"}: A function.
The idea is the same as \code{expr}, but assigning a function as the
value space is less safe: The function's enclosing environment may
not be what was intended if a \code{VariableMetadata} object is read from
disk.
E.g. \code{list(fun = my_fun)}.
\item \code{"unrestricted"}: A list with named element \code{class_set}.
Sometimes a variable has no restrictions besides its class.
String variables can often have any value.
E.g. \code{list(unrestricted = list(class_set = "character"))}.
\item \code{"regex"}: A character string regular expression.
Some string variables are known in advance to always match a specific
regular expression.
E.g. \code{list(regex = "^C[0-9.]+$")}.
\item \code{"bounds"}: A list defining the upper and lower bounds.
You can define upper and lower limits for one variable with this
approach.
E.g. \code{list(bounds = list(lo = 0.0, hi = 1.0, lo_inclusive = FALSE, hi_inclusive = TRUE))}
}

The following functions are related to this feature:
\itemize{
\item \code{vm@var_set_value_space_eval}
\item \code{vm@var_set_value_space_get}
\item \code{vm@var_set_value_space_set}
\item \code{vm@var_set_value_space_dt_subset}
\item \code{vm@var_value_space_eval}
}

\strong{Random sampling}

The random sampling feature is available when the value spaces feature
is available.

Random sampling is performed as follows:
\itemize{
\item \code{vm@var_set_value_space_eval} is called for the appropriate value space
\item The appropriate \code{sampler} is retrieved --- this is either the
corresponding
sampler stored in \code{var_set_dt$sampler}, or if no sampler exists there,
one of the defaults depending on the type of the value space:
\itemize{
\item \code{dt}: Sample uniformly rows from \code{data.table} with replacement.
\item \code{set}: Sample uniformly from set with replacement.
\item \code{expr} & \code{fun}: Handling depends on the type of output: A vector
output is handled as a \code{set} and a \code{data.table} output as a \code{dt}.
\item \code{unrestricted}: If \code{class_set = "character"}, sample random strings
of length 16 using character pool \code{c(letters, LETTERS, 0:9)}. If
\code{class_set} is anything else, raise an error because no sampler is
defined for the general case.
\item \code{regex}: Raise error because no sampler defined.
\item \code{bounds}: Sample uniformly between \code{lo} and \code{hi} --- with
replacement from \code{lo:hi} if \code{storage.mode(lo) == "integer"}.
}
\item The \code{sampler} is called or evaluated, which results in the random samples,
and these are returned. If the \code{sampler} is a function it is called via
\code{sampler(x = vm, n = n)}, where \code{vm} is the
\code{VariableMetadata} object itself.
The function may also have the optional arguments \code{vs}
(the evaluated value space for \code{id}), \code{data} (see argument \code{data}
of \code{vm@var_set_value_space_sample}), \code{dep_var_nm_set} (this will be
\code{sampler$dep_var_nm_set} if \code{sampler} was a list), \code{id}
(see argument \code{id} of \code{vm@var_set_value_space_sample}), and
\code{var_nms} (see argument \code{var_nms} of \code{vm@var_set_value_space_sample}).
If \code{sampler} is an expression, it is evaluated in a new
environment that contains the arguments mentioned above as objects.
This new environment's parent is \code{env}.
For conditional sampling you must use \code{sampler} of type \code{list} and make
use of \code{data} (and optionally \code{dep_var_nm_set}) in \code{sampler$sampler}.
}

The following functions are related to this feature:
\itemize{
\item \code{vm@var_set_value_space_sampler_get}
\item \code{vm@var_set_value_space_sampler_set}
\item \code{vm@var_set_value_space_sample}
\item \code{vm@var_value_space_sample}
\item \code{vm@vame_value_space_sampler_get}
\item \code{vm@vame_value_space_sampler_set}
\item \code{vm@vame_value_space_sample}
\item \code{vm@vame_value_space_sample_default}
}

\strong{Assertions}

The assertions feature allows you to check that variables look like what
you expect. This feature relies on the value spaces feature --- see that
for more information.

The following functions are related to this feature:
\itemize{
\item \code{vm@var_assert}
}

\strong{Labeling}

The labeling feature becomes available if
the \code{var_dt} of a \code{VariableMetadata} object has a \code{labeler} column value
for a variable. You can include \code{labeler} in \code{var_dt} when the
\code{VariableMetadata} object is constructed or use \code{vm@var_labeler_set} later.

\code{var_dt$labeler} must be a list column.
A \code{labeler} for a variable can be one of these:
\itemize{
\item A function with arguments named \code{x} and \code{label_nm}.
\item A \code{data.table} with column \code{x} and label columns --- you decide
their names. For labels in different languages it is recommended to use
ISO language codes as column names, e.g. "en".
\item An R expression object of class \code{call}.
The expression must contain the variables \code{x} and \code{label_nm}.
}

The following functions are related to this feature:
\itemize{
\item \code{vm@var_labeler_get}
\item \code{vm@var_labeler_set}
\item \code{vm@var_labels_get}
}

\strong{Describing}

The describing feature becomes available if
the \code{var_dt} of a \code{VariableMetadata} object has a \code{describer} column value
for a variable. You can include \code{describer} in \code{var_dt} when the
\code{VariableMetadata} object is constructed or use \code{vm@var_describer_set} later.

The \code{describer} can be \code{NULL}, a \code{list}, a \code{function}, or a \code{call} object.
A \code{NULL} \code{describer} object is considered to mean that one has not been
defined.
A \code{describer} of type \code{list} must be named. Each element must be
a string.
A \code{describer} of type \code{function} must have argument \code{descr_nm}.
A \code{describer} of type \code{call} must contain (mention) variable
\code{descr_nm}.

The following functions are related to this feature:
\itemize{
\item \code{vm@var_describer_getr}
\item \code{vm@var_describer_set}
\item \code{vm@var_description_get}
}

\strong{Category spaces}

The category spaces feature becomes available when the value spaces feature
is available and when
the \code{var_dt} of a \code{VariableMetadata} object has a \code{type} column, with
value \code{"categorical"} for at least one variable.
This features differs from the value spaces feature by being more specific
and being able to produce one (large) \code{data.table} of allowed variable
value combinations.

\code{var_dt$type} must be a character string vector. Missing values are
allowed.

This feature relies on the value spaces feature. See the documentation
for that feature for more information.

The following functions are part of this feature:
\itemize{
\item \code{vm@var_is_aggregateable_to}
\item \code{vm@var_aggregate}
\item \code{vm@vame_category_space_dt_list}
\item \code{vm@vame_category_space_dt}
}
}

\section{News for version 0.5.3}{


\code{vm@var_set_make} passing \code{var_nms} fixed. It used to pass the
\code{var_nm_set} for the corresponding variable set, now it passes arg
\code{var_nms} (whether inferred or user-given) as intended.

\code{maker} objects of type \code{function} can no longer have \code{...} in their
definition to enable proper checks on inputs when the \code{maker} is called.

\code{vm@var_set_maker_set} now ignores arguments passed via \code{data} to a
\code{maker} of type \code{function} that do not correspond to any argument name.

\code{vm@var_set_value_space_sample} arg \code{id} now \code{NULL} by default.
You can supply either \code{id} or \code{var_nms} and the other one is inferred,
if \code{NULL}.
}

\section{News for version 0.5.2}{


\code{vm@vame_make} gains argument \code{var_nms}. You can now pass either \code{ids} or
\code{var_nms} or both.

\code{vm@vame_make} automatically determines the appropriate order of \code{ids}
(whether user-supplied or inferred) in which their \code{maker}s should be
called. For instance if \code{maker} for \code{ids[1]} requires the variables
created by the \code{maker} for \code{ids[2]}, then the latter is called first.

\code{vm@var_set_make} gains argument \code{var_nms}. You can now pass either \code{id} or
\code{var_nms} or both.

\code{vm@var_set_make} now raises an informative error if \code{data} did not
contain something the \code{maker} needs.
}

\section{News for version 0.5.0}{


\code{vame::VariableMetadata} now automatically sets \code{var_dt$type} to
\code{"categorical"} where the variable's \code{value_space} is of type
\code{dt} or \code{set} or when \code{var_dt$labeler} has been defined. Remember that
this only occurs when \code{vame::VariableMetadata} is called and any
additional variables you add later will not be treated automatically.
Also, if \code{var_dt$type} was already something other than \code{NA} for a
variable, the automatic determination is not attempted.
}

\section{News for version 0.4.1}{


\code{vm@var_dt_copy} now actually returns \code{var_dt} instead of \code{var_set_dt}.

\code{vm@var_set_dt_copy} now actually returns \code{var_set_dt} instead of \code{var_dt}.
}

\section{News for version 0.4.0}{


\code{var_dt$labeler} of class \code{data.table} specs changed: Now column
containing values for the variable in question must be named \code{x}.
Formerly this was \code{level}.

Added recommendations for constructing \code{vame::VariableMetadata} objects into
documentation.

\code{vm@vame_value_space_sample} gains arguments \code{ids} and \code{data}.

\code{vm@vame_value_space_sample_default} gains arguments \code{ids} and \code{data}.

\code{vm@var_aggregate} now always considers it possible to aggregate to
\code{to_var_nm} if it only has one value.

New function \code{vm@var_describer_get}.

New function \code{vm@var_describer_set}.

New function \code{vm@var_description_get}.

\code{vm@var_description_get} arg \code{description_name} renamed to \code{descr_nm}.

\code{vm@var_labels_get} arg \code{label_col_nm} renamed to \code{label_nm}.

\code{vm@var_meta_is_defined} internal problem fixed.

\code{vm@var_set_make} argument \code{data} can now also be a \code{list} object.

\code{vm@var_set_value_space_sample} now has new arg \code{data}. Pass your data via
\code{data} when you have a conditional sampling method.
}

\section{News for version 0.3.0}{


New function \code{vm@vame_make}.

New function \code{vm@var_set_make}.

New function \code{vm@var_set_maker_get}.

New function \code{vm@var_set_maker_set}.
}

\section{News for version 0.2.2}{


\code{vame::VariableMetadata} gains arg \code{vame_list}.

New function \code{vm@vame_list_copy}.

New function \code{vm@vame_meta_get}.

New function \code{vm@vame_meta_is_defined}.

New function \code{vm@vame_meta_set}.

New function \code{vm@var_set_meta_is_defined}.

New function \code{vm@vame_value_space_sample_default}.

New function \code{vm@vame_value_space_sampler_get}.

New function \code{vm@vame_value_space_sampler_set}.

New function \code{vm@var_dt_copy}.

New function \code{vm@var_meta_is_defined}.

\code{vm@var_meta_set} now wraps \code{value} into a list if it isn't a list
and if the target column is a list.

Fix renaming multiple variables on one go.

New function \code{vm@var_set_dt_copy}.

New function \code{vm@var_set_meta_is_defined}.

\code{vm@var_set_meta_set} now wraps \code{value} into a list if it isn't a list
and if the target column is a list.

New slot function \code{var_set_value_space_sample}.

New slot function \code{var_set_value_space_sampler_get}.

New slot function \code{var_set_value_space_sampler_set}.

New function \code{vm@var_value_space_sample}.
}

\section{News for version 0.2.1}{


A \code{labeler} can now also be of class \code{call}.

\code{vm@var_labels_get} now can handle \code{labeler}s of class \code{call}.
Added argument \code{labeler_env} for this purpose.
}

\section{News for version 0.2.0}{


Rename \code{expr} to \code{var_dt_expr}. Add arg \code{var_set_dt_expr}.

Rename \code{x} to \code{vm_2}.

A \code{labeler} can now be of type \code{function} in addition to \code{data.table}.

\code{vm@var_labels_get} now can handle \code{labeler}s of type \code{function}.

\code{vm@var_meta_get_all} now always sets \code{var_dt$var_nm} as the names
of the output list or vector.

Rename \code{old} to \code{old_var_nms} and \code{new} to \code{new_var_nms}.

\code{vm@var_set_meta_get_all} now always sets \code{var_set_dt$id} as the names
of the output list or vector.

Rename \code{old} to \code{old_ids} and \code{new} to \code{new_ids}.

Rename \code{vm@var_set_get} to \code{vm@var_set_var_nm_set_get}.

Rename \code{vm@var_set_list_get} to \code{vm@var_set_var_nm_set_get_all}.

New function \code{vm@var_set_var_nm_set_set}.
}

\section{News for version 0.1.9}{


\code{vm@var_remove} can now remove multiple variables in one go.

\code{vame::var_set_value_space_eval} + \code{vm@var_set_value_space_eval} gain
arg \code{var_nms}. You can now evaluate the value space for only a subset of
the variables in the set.
}

\section{News for version 0.1.8}{


New slot fun \code{vm@vame_copy} + new exported fun \code{vame::vame_copy}.
}

\section{News for version 0.1.7}{


New \code{value_space} type: "unrestricted". Use this when a variable must
be of a certain class but can take any value. E.g.
\code{list(unrestricted = list(class_set = c("IDate", "Date")))}.

New \code{value_space} type: "regex". Use this when all values of a variable
must match a specific regex. E.g. \code{list(regex = "^[a-z]$")}.

New exported fun \code{vame::var_set_value_space_eval} --- alternative for
\code{vm@var_set_value_space_eval}.
}

\section{News for version 0.1.6}{


fix \code{vame_union_append} --- no longer attempt to remove duplicates
in rbind'd \code{var_dt} because some \code{by} columns may be of type \code{list}
which is not supported by \code{duplicated}.
}

\section{News for version 0.1.5}{


Robustify \code{vame_union_append} --- use \verb{use.names = TRUE, fill = TRUE}
in \code{rbind} calls.
}

\section{News for version 0.1.4}{


Fixed \code{vame_union_append} --- used to always raise an error due to
a misnamed object.
}

\section{News for version 0.1.3}{


New slot \code{var_aggregate}.

\code{vm@var_assert} gains arg \code{env}. This is passed
to \code{vm@var_value_space_eval}.

New slot \code{var_is_aggregateable_to}.
}

\section{News for version 0.1.2}{


Also \code{bounds} value space can be used when creating category spaces.

Also \code{bounds} value space can be used when creating category spaces.

Added arguments \code{x_nm}, \code{call}.
}

\section{News for version 0.1.1}{


Fixed \code{var_assert} handling of a value space based on \code{bounds}.

New slot \code{vm@var_set_value_space_eval}.

New slot \code{vm@var_value_space_eval}.
}

\section{News for version 0.1.0}{


First release.
}

\examples{
# vame::VariableMetadata ----------------------------------------------------

# basic example of different kinds of variables
value_space_d <- function() 1:3 * 100L
vm <- vame::VariableMetadata(
  var_dt = data.table::data.table(
    var_nm = c("a", "b", "c", "d", "e", "f", "g", "h"),
    type = c("categorical", "categorical",
             "categorical",
             "my_type_1", "my_type_2", "my_type_3", "my_type_4", "my_type_5")
  ),
  var_set_dt = data.table::data.table(
    id = c("ab", "c", "d", "e", "f", "g", "h"),
    var_nm_set = list(
      ab = c("a", "b"),
      c = "c", d = "d", e = "e", f = "f", g = "g", h = "h"),
    value_space = list(
      ab = list(dt = data.table::data.table(
        a = c(1L, 2L, 2L),
        b = c(11L, 21L, 22L)
      )),
      c = list(set = c("a", "b")),
      d = list(expr = quote(value_space_d())),
      e = list(bounds = list(
        lo = 0.0, hi = 10.0,
        lo_inclusive = TRUE, hi_inclusive = TRUE
      )),
      f = list(bounds = list(
        lo = as.Date("1901-01-01"), hi = as.Date("2023-12-31"),
        lo_inclusive = TRUE, hi_inclusive = TRUE
      )),
      g = list(unrestricted = list(class_set = c("IDate", "Date"))),
      h = list(regex = "^[a-z]$")
    )
  )
)
vm@var_assert(1L, var_nm = "a")
vm@var_assert(21L, var_nm = "b")
vm@var_assert("a", var_nm = "c")
vm@var_assert(100L, var_nm = "d")
vm@var_assert(c(0.0, 10.0), var_nm = "e")
vm@var_assert(as.Date("1901-01-01"), var_nm = "f")
vm@var_assert(data.table::as.IDate("1901-01-01"), var_nm = "g")
vm@var_assert(letters, var_nm = "h")
my_fun <- function(e_values) {
  vm@var_assert(e_values, var_nm = "e")
  e_values + 1
}
my_fun(0.0)

# assignment after creating a VariableMetadata object
vm@var_meta_set(var_nm = "f", meta_nm = "type", value = "my_date")
stopifnot(
  vm@var_meta_get(var_nm = "f", meta_nm = "type") == "my_date"
)
vm@var_set_value_space_set(id = "c", value_space = list(set = c("x", "z")))
stopifnot(
  identical(vm@var_set_value_space_get(id = "c"), list(set = c("x", "z")))
)

# renaming, removing variables
vm <- vame::VariableMetadata(
  var_dt = data.table::data.table(
    var_nm = c("a", "b", "c"),
    flavour = c("tasty", "rancid", "bitter")
  ),
  var_set_dt = data.table::data.table(
    id = "set_01",
    var_nm_set = list(c("a", "b")),
    value_space = list(list(dt = data.table::data.table(
      a = 1:2,
      b = 3:4
    )))
  )
)

vm@var_rename("a", "A")
stopifnot(
  identical(vm@var_meta_get("A", "flavour"), "tasty"),
  identical(names(vm@var_set_value_space_get("set_01")[["dt"]]), c("A", "b")),
  identical(vm@var_set_meta_get("set_01", "var_nm_set"), c("A", "b"))
)

vm@var_set_rename("set_01", "Ab")
stopifnot(
  identical(vm@var_set_meta_get_all("id"), c("Ab" = "Ab"))
)

vm@var_remove("b")
stopifnot(
  identical(names(vm@var_set_value_space_get("Ab")[["dt"]]), "A"),
  identical(vm@var_set_meta_get("Ab", "var_nm_set"), "A")
)

vm@var_set_remove("Ab")
stopifnot(
  identical(length(vm@var_set_meta_get_all("var_nm_set")), 0L)
)

# retrieving category space data.tables
dt_01 <- data.table::CJ(a = 1:3, b = 3:1, c = 1:3)
dt_02 <- data.table::CJ(d = 1:2, e = 2:1)
vm <- vame::VariableMetadata(
  var_dt = data.table::data.table(
    var_nm = c("a", "b", "c", "d", "e", "f"),
    type = "categorical"
  ),
  var_set_dt = data.table::data.table(
    id = c("abc", "de", "f"),
    var_nm_set = list(
      abc = c("a", "b", "c"),
      de = c("d", "e"),
      f = "f"
     ),
    value_space = list(
      abc = list(dt = dt_01),
      de = list(expr = quote({
        dt_02[
          i = !duplicated(dt_02, by = var_nms),
          j = .SD,
          .SDcols = var_nms
        ]
      })),
      f = list(bounds = list(
        lo = 0L, hi = 10L,
        lo_inclusive = TRUE, hi_inclusive = TRUE
      ))
    )
  )
)

stopifnot(
  all.equal(
    vm@vame_category_space_dt(c("a", "b")),
    dt_01[
      i = !duplicated(dt_01, by = c("a", "b")),
      j = .SD,
      .SDcols = c("a", "b")
    ],
    check.attributes = FALSE
  ),
  all.equal(
    vm@vame_category_space_dt(c("d", "e")),
    dt_02,
    check.attributes = FALSE
  ),
  all.equal(
    vm@vame_category_space_dt(c("a", "f")),
    data.table::CJ(a = 1:3, f = 0:10),
    check.attributes = FALSE
  )
)

# getting category space data.tables --- here a variable appears in
# two different value spaces. this can be handy for defining joint value
# spaces and also conversions & aggregations.
dt_01 <- data.table::CJ(a = 1:3, b = 3:1, c = 1:3)
dt_02 <- data.table::CJ(a = 0:1, e = 2:1)
dt_03 <- data.table::data.table(a = 0:3, a_2 = c(1L,1L, 2L,2L))
vm <- vame::VariableMetadata(
  var_dt = data.table::data.table(
    var_nm = c("a", "b", "c", "e", "a_2"),
    type = "categorical"
  ),
  var_set_dt = data.table::data.table(
    id = c("set_01", "set_02", "set_03"),
    var_nm_set = list(c("a", "b", "c"), c("a", "e"), c("a", "a_2")),
    value_space = list(
      list(dt = dt_01),
      list(dt = dt_02),
      list(dt = dt_03)
    )
  )
)

obs <- vm@vame_category_space_dt(c("a", "b", "e"))
exp <- data.table::data.table(
  a = c(0L, 0L, 1L, 1L, 1L, 1L, 1L, 1L, 2L, 2L, 2L, 3L, 3L, 3L),
  b = c(NA, NA, 1L, 1L, 2L, 2L, 3L, 3L, 1L, 2L, 3L, 1L, 2L, 3L),
  e = c(1L, 2L, 1L, 2L, 1L, 2L, 1L, 2L, NA, NA, NA, NA, NA, NA)
)
data.table::setkeyv(obs, names(obs))
data.table::setkeyv(exp, names(exp))
stopifnot(
  all.equal(obs, exp, check.attributes = FALSE)
)

stopifnot(
  vm@var_is_aggregateable_to("a", "a_2"),
  identical(vm@var_aggregate(0:1, "a", "a_2"), c(1L,1L))
)

# getting labels for variable levels
dt_01 <- data.table::CJ(a = 1:3, b = 3:1, c = 4:5)
vm <- vame::VariableMetadata(
  var_dt = data.table::data.table(
    var_nm = c("a", "b", "c"),
    type = "categorical",
    labeler = list(
      a = data.table::data.table(
        x = 1:3,
        en = paste0("a_level_", 1:3)
      ),
      b = quote({
        dt <- data.table::data.table(
          x = 1:3,
          en = paste0("b_level_", 1:3)
        )
        dt[[label_nm]][match(x, dt[["x"]])]
      }),
      c = NULL
    )
  ),
  var_set_dt = data.table::data.table(
    id = c("set_01"),
    var_nm_set = list(c("a", "b", "c")),
    value_space = list(
      list(dt = dt_01)
    )
  )
)

obs <- vm@var_labels_get(x = 1:4, var_nm = "a", label_nm = "en")
exp <- c(paste0("a_level_", 1:3), NA)
stopifnot(
  identical(obs, exp)
)

obs <- tryCatch(
  vm@var_labels_get(
    x = 1:4,
    var_nm = "a",
    label_nm = "this does not exist"
  ),
  error = function(e) e[["message"]]
)
exp <- paste0(
  "label_nm = \"this does not exist\"",
  " not one of the defined label names: \"en\""
)
stopifnot(
  grepl(exp, obs)
)

obs <- tryCatch(
  vm@var_labels_get(
    x = 1:4,
    var_nm = "c",
    label_nm = "en"
  ),
  error = function(e) e[["message"]]
)
exp <- "Variable \"c\" has no labeler defined"
stopifnot(
  grepl(exp, obs)
)

# adding data to a pre-existing VariableMetadata object
vm_1 <- vame::VariableMetadata(
  var_dt = data.table::data.table(
    var_nm = c("a", "b"),
    type = "categorical",
    labeler = list(
      a = data.table::data.table(x = 1:2, label = c("a_1", "a_2")),
      b = NULL
    )
  ),
  var_set_dt = data.table::data.table(
    id = "ab",
    var_nm_set = list(ab = c("a", "b")),
    value_space = list(ab = list(dt = data.table::CJ(a = 1:2, b = 3:4)))
  )
)
# note that vm_2 var_dt does not have columns "type", "labeler" --- those
# will be NA / NULL for "c" and "d".
vm_2 <- vame::VariableMetadata(
  var_dt = data.table::data.table(var_nm = c("c", "d")),
  var_set_dt = data.table::data.table(
    id = "cd",
    var_nm_set = list(cd = c("c", "d")),
    value_space = list(cd = list(dt = data.table::CJ(c = 5:6, d = 7:8)))
  )
)
vm_1@vame_union_append(vm_2)
stopifnot(
  c("ab", "cd") \%in\% vm_1@var_set_meta_get_all("id")
)

# taking a copy of a VariableMetadata object
vm_3 <- vm_2@vame_copy()
vm_2@var_rename("d", "dd")
stopifnot(
  "d" \%in\% vm_3@var_meta_get_all("var_nm"),
  !"d" \%in\% vm_2@var_meta_get_all("var_nm"),
  "dd" \%in\% vm_2@var_meta_get_all("var_nm")
)

# Example of make feature
make_dg_y <- function(
  dg_date
) {
  out <- data.table::data.table(dg_y = data.table::year(dg_date))
  return(out[])
}
# We do not store `my_fun` here directly because if a `VariableMetadata`
# object is written to disk, the entire enclosing env of `my_fun` is
# included. This can get very messy when it is read back into R.
# It is strongly recommended to store quoted expressions instead
# and store any functions you write somewhere else, ideally in an R package.
my_vame <- vame::VariableMetadata(
  var_dt = data.table::data.table(
    var_nm = c("dg_y", "dg_date", "area_01", "area_02", "area_03"),
    type = c("year", "date", "categorical", "categorical", "categorical")
  ),
  var_set_dt = data.table::data.table(
    id = c("dg_y", "dg_date", "area", "area_01", "area_02"),
    var_nm_set = list(
      dg_y = "dg_y",
      dg_date = "dg_date",
      area = c("area_01", "area_02", "area_03"),
      area_01 = "area_01",
      area_02 = "area_02"
    ),
    maker = list(
      dg_y = list(
        maker = quote(make_dg_y(dg_date = dg_date)),
        dep_var_nm_set = "dg_date"
      ),
      dg_date = NULL,
      area = NULL,
      area_01 = list(
        maker = quote({
          # This is an example of re-using data from the `VariableMetadata`
          # object itself. 
          vm <- vame::self()
          dt <- data.table::setDT(list(
            x = vm@var_aggregate(
              get(dep_var_nm_set),
              from_var_nm = dep_var_nm_set,
              to_var_nm = var_nms
            )
          ))
          data.table::setnames(dt, "x", var_nms)
          dt[]
        }),
        dep_var_nm_set = "area_02"
      ),
      # This example uses the shorthand var_aggregate approach.
      area_02 = list(maker = "var_aggregate", dep_var_nm_set = "area_03")
    ),
    value_space = list(
      dg_y = list(set = 1953:2024),
      dg_date = list(bounds = list(
        lo = as.Date("1953-01-01"),
        hi = as.Date("2024-12-31"),
        lo_inclusive = TRUE,
        hi_inclusive = TRUE
      )),
      area = list(dt = data.table::data.table(
        area_01 = c(1L,1L,1L,2L,2L,2L),
        area_02 = c(11L,12L,12L,21L,21L,22L),
        area_03 = c(111L,121L,122L,211L,212L,221L)
      )),
      area_01 = NULL,
      area_02 = NULL
    )
  )
)
obs <- my_vame@var_set_make(
  id = "dg_y",
  data = data.table::data.table(dg_date = as.Date("2001-01-01"))
)
exp <- data.table::data.table(dg_y = 2001L)
stopifnot(identical(obs[["dg_y"]], exp[["dg_y"]]))

obs <- my_vame@var_set_make(
  id = "area_01",
  data = data.table::data.table(area_02 = c(11L, 21L))
)
exp <- data.table::data.table(area_01 = c(1L,2L))
stopifnot(identical(obs[["area_01"]], exp[["area_01"]]))

obs <- my_vame@var_set_make(
  id = "area_02",
  data = data.table::data.table(area_03 = c(111L, 211L))
)
exp <- data.table::data.table(area_02 = c(11L,21L))
stopifnot(identical(obs[["area_02"]], exp[["area_02"]]))

obs <- my_vame@vame_make(
  ids = c("dg_y", "area_02", "area_01"),
  data = data.table::data.table(
    dg_date = as.Date("2001-01-01"),
    area_03 = c(111L,121L,122L,211L,212L,221L)
  )
)
exp <- data.table::data.table(
  dg_y = 2001L,
  area_02 = my_vame@var_aggregate(
    c(111L,121L,122L,211L,212L,221L),
    from_var_nm = "area_03",
    to_var_nm = "area_02"
  )
)
exp[
  j = "area_01" := my_vame@var_aggregate(
    exp[["area_02"]],
    from_var_nm = "area_02",
    to_var_nm = "area_01"
  )
]
stopifnot(
  identical(obs[["dg_y"]], exp[["dg_y"]]),
  identical(obs[["area_01"]], exp[["area_01"]]),
  identical(obs[["area_02"]], exp[["area_02"]])
)

obs_2 <- my_vame@vame_make(
  var_nms = c("dg_y", "area_02", "area_01"),
  data = data.table::data.table(
    dg_date = as.Date("2001-01-01"),
    area_03 = c(111L,121L,122L,211L,212L,221L)
  )
)
obs_3 <- my_vame@vame_make(
  var_nms = c("dg_y", "area_02", "area_01"),
  data = list(df = data.table::data.table(
    dg_date = as.Date("2001-01-01"),
    area_03 = c(111L,121L,122L,211L,212L,221L)
  ))
)
stopifnot(
  all.equal(obs, obs_2),
  all.equal(obs, obs_3)
)
# random sampling
c_lo <- as.Date("2001-01-01")
c_hi <- as.Date("2020-12-31")
## see what default samplers do with bounds
storage.mode(c_lo) <- storage.mode(c_hi) <- "integer"
vm <- vame::VariableMetadata(
  var_dt = data.table::data.table(
    var_nm = c("a", "d", "b", "c"),
    type = c("categorical", "categorical", "categorical", "my_type")
  ),
  var_set_dt = data.table::data.table(
    id = c("ad", "b", "c", "e"),
    var_nm_set = list(ad = c("a", "d"), b = "b", c = "c", e = "e"),
    value_space = list(
      ad = list(dt = data.table::CJ(a = 1:2, d = 3:4)),
      b = list(set = 3:4),
      c = list(bounds = list(
        lo = c_lo,
        hi = c_hi,
        lo_inclusive = TRUE,
        hi_inclusive = TRUE
      )),
      e = list(set = 1:2)
    ),
    sampler = list(
      ad = NULL,
      b = quote({
        p <- c(0.25, 0.75)
        out <- sample(vs[["set"]], size = n, replace = TRUE, p = p)
        out <- data.table::setDT(list(b = out))
        return(out[])
      }),
      c = NULL,
      e = quote({
        stopifnot(
          inherits(data, "list"),
          "e_cond" \%in\% names(data),
          length(data[["e_cond"]]) == n
        )
        dist <- data.table::data.table(
          e_cond = c(1L, 1L, 2L, 2L),
          e = c(1:2, 1:2),
          p_cond = c(0.25, 0.75, 0.40, 0.60)
        )
        join_dt <- data.table::setDT(list(e_cond = data[["e_cond"]]))
        out <- dist[
          i = join_dt,
          j = list(
            e = sample(.SD[["e"]], replace = TRUE, prob = .SD[["p_cond"]])
          ),
          by = .EACHI
        ]
        data.table::set(out, j = setdiff(names(out), "e"), value = NULL)
        return(out[])
      })
    )
  )
)
vm@var_set_value_space_sampler_set(
  id = "c",
  value = quote({
    pool <- vs[["bounds"]][["lo"]]:vs[["bounds"]][["hi"]]
    p <- dnorm(x = pool, mean = mean(pool), sd = 10)
    class(pool) <- class(vs[["bounds"]][["lo"]])
    out <- pool[sample(length(pool), size = n, replace = FALSE, prob = p)]
    out <- data.table::setDT(list(c = out))
    return(out[])
  })
)

ad_sample <- vm@var_set_value_space_sample(id = "ad", n = 4L)
b_sample <- vm@var_set_value_space_sample(id = "b", n = 4L)
c_sample <- vm@var_set_value_space_sample(id = "c", n = 4L)
stopifnot(
  inherits(ad_sample, "data.table"),
  nrow(ad_sample) == 4,
  inherits(b_sample, "data.table"),
  nrow(b_sample) == 4,
  inherits(c_sample, "data.table"),
  storage.mode(c_sample$c) == "integer",
  nrow(c_sample) == 4
)

vame_sample <- vm@vame_value_space_sample(
  ids = c("ad", "b", "c"),
  n = 10L
)
stopifnot(
  inherits(vame_sample, "data.table"),
  identical(c("a", "d", "b", "c"), names(vame_sample)),
  nrow(vame_sample) == 10
)

# conditional sampling
vm@var_set_value_space_sampler_set(
  id = "c",
  value = list(
    dep_var_nm_set = "a",
    sampler = quote({
      a <- data[["a"]]
      out <- data.table::data.table(c = runif(n = n, min = a - 1, max = a))
      return(out[])
    })
  )
)
c_sample_data <- list(a = 1:2)
c_sample <- vm@var_set_value_space_sample(
  id = "c",
  data = c_sample_data,
  n = 2L
)
vame_sample <- vm@vame_value_space_sample(
  ids = c("ad", "b", "c"),
  n = 10L
)
stopifnot(
  inherits(c_sample, "data.table"),
  identical("c", names(c_sample)),
  nrow(c_sample) == 2,
  c_sample[["c"]] < c_sample_data[["a"]],
  inherits(vame_sample, "data.table"),
  identical(c("a", "d", "b", "c"), names(vame_sample)),
  nrow(vame_sample) == 10,
  vame_sample[["c"]] < vame_sample[["a"]]
)

# Example of describing feature
my_vame <- vame::VariableMetadata(
  var_dt = data.table::data.table(
    var_nm = c("sex", "birth_date"),
    describer = list(
      sex = list(
        en = "Sex assigned at birth.",
        fi = "Syntymahetken sukupuoli."
      ),
      birth_date = quote(switch(
        descr_nm,
        en = "Date of birth.",
        fi = "Syntymapaivamaara."
      ))
    )
  ),
  var_set_dt = data.table::data.table(
    id = c("sex", "birth_date"),
    var_nm_set = list(sex = "sex", birth_date = "birth_date")
  )
)
stopifnot(
  identical(
    my_vame@var_description_get("sex"),
    "Sex assigned at birth."
  ),
  inherits(
    tryCatch(
      my_vame@var_description_get("birth_date"),
      error = function(e) e
    ),
    "error"
  ),
  identical(
    my_vame@var_description_get(
      var_nm = "birth_date",
      descr_nm = "fi"
    ),
    "Syntymapaivamaara."
  )
)
}
